"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/unified";
exports.ids = ["vendor-chunks/unified"];
exports.modules = {

/***/ "(ssr)/./node_modules/unified/node_modules/is-buffer/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/unified/node_modules/is-buffer/index.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ \nmodule.exports = function isBuffer(obj) {\n    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5pZmllZC9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDO0FBRURBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxTQUFVQyxHQUFHO0lBQ3JDLE9BQU9BLE9BQU8sUUFBUUEsSUFBSUMsV0FBVyxJQUFJLFFBQ3ZDLE9BQU9ELElBQUlDLFdBQVcsQ0FBQ0YsUUFBUSxLQUFLLGNBQWNDLElBQUlDLFdBQVcsQ0FBQ0YsUUFBUSxDQUFDQztBQUMvRSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tYWktdGVtcGxhdGUtcHJvLy4vbm9kZV9tb2R1bGVzL3VuaWZpZWQvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcz8yZDAzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiaXNCdWZmZXIiLCJvYmoiLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/unified/node_modules/is-buffer/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/unified/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/unified/lib/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unified: () => (/* binding */ unified)\n/* harmony export */ });\n/* harmony import */ var bail__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bail */ \"(ssr)/./node_modules/bail/index.js\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-buffer */ \"(ssr)/./node_modules/unified/node_modules/is-buffer/index.js\");\n/* harmony import */ var extend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! extend */ \"(ssr)/./node_modules/extend/index.js\");\n/* harmony import */ var is_plain_obj__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! is-plain-obj */ \"(ssr)/./node_modules/is-plain-obj/index.js\");\n/* harmony import */ var trough__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! trough */ \"(ssr)/./node_modules/trough/lib/index.js\");\n/* harmony import */ var vfile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vfile */ \"(ssr)/./node_modules/vfile/lib/index.js\");\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */ \n\n\n\n\n\n// Expose a frozen processor.\nconst unified = base().freeze();\nconst own = {}.hasOwnProperty;\n// Function to create the first processor.\n/**\n * @returns {Processor}\n */ function base() {\n    const transformers = (0,trough__WEBPACK_IMPORTED_MODULE_3__.trough)();\n    /** @type {Processor['attachers']} */ const attachers = [];\n    /** @type {Record<string, unknown>} */ let namespace = {};\n    /** @type {boolean|undefined} */ let frozen;\n    let freezeIndex = -1;\n    // Data management.\n    // @ts-expect-error: overloads are handled.\n    processor.data = data;\n    processor.Parser = undefined;\n    processor.Compiler = undefined;\n    // Lock.\n    processor.freeze = freeze;\n    // Plugins.\n    processor.attachers = attachers;\n    // @ts-expect-error: overloads are handled.\n    processor.use = use;\n    // API.\n    processor.parse = parse;\n    processor.stringify = stringify;\n    // @ts-expect-error: overloads are handled.\n    processor.run = run;\n    processor.runSync = runSync;\n    // @ts-expect-error: overloads are handled.\n    processor.process = process;\n    processor.processSync = processSync;\n    // Expose.\n    return processor;\n    // Create a new processor based on the processor in the current scope.\n    /** @type {Processor} */ function processor() {\n        const destination = base();\n        let index = -1;\n        while(++index < attachers.length){\n            destination.use(...attachers[index]);\n        }\n        destination.data(extend__WEBPACK_IMPORTED_MODULE_1__(true, {}, namespace));\n        return destination;\n    }\n    /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */ function data(key, value) {\n        if (typeof key === \"string\") {\n            // Set `key`.\n            if (arguments.length === 2) {\n                assertUnfrozen(\"data\", frozen);\n                namespace[key] = value;\n                return processor;\n            }\n            // Get `key`.\n            return own.call(namespace, key) && namespace[key] || null;\n        }\n        // Set space.\n        if (key) {\n            assertUnfrozen(\"data\", frozen);\n            namespace = key;\n            return processor;\n        }\n        // Get space.\n        return namespace;\n    }\n    /** @type {Processor['freeze']} */ function freeze() {\n        if (frozen) {\n            return processor;\n        }\n        while(++freezeIndex < attachers.length){\n            const [attacher, ...options] = attachers[freezeIndex];\n            if (options[0] === false) {\n                continue;\n            }\n            if (options[0] === true) {\n                options[0] = undefined;\n            }\n            /** @type {Transformer|void} */ const transformer = attacher.call(processor, ...options);\n            if (typeof transformer === \"function\") {\n                transformers.use(transformer);\n            }\n        }\n        frozen = true;\n        freezeIndex = Number.POSITIVE_INFINITY;\n        return processor;\n    }\n    /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */ function use(value, ...options) {\n        /** @type {Record<string, unknown>|undefined} */ let settings;\n        assertUnfrozen(\"use\", frozen);\n        if (value === null || value === undefined) {\n        // Empty.\n        } else if (typeof value === \"function\") {\n            addPlugin(value, ...options);\n        } else if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                addList(value);\n            } else {\n                addPreset(value);\n            }\n        } else {\n            throw new TypeError(\"Expected usable value, not `\" + value + \"`\");\n        }\n        if (settings) {\n            namespace.settings = Object.assign(namespace.settings || {}, settings);\n        }\n        return processor;\n        /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */ function add(value) {\n            if (typeof value === \"function\") {\n                addPlugin(value);\n            } else if (typeof value === \"object\") {\n                if (Array.isArray(value)) {\n                    const [plugin, ...options] = value;\n                    addPlugin(plugin, ...options);\n                } else {\n                    addPreset(value);\n                }\n            } else {\n                throw new TypeError(\"Expected usable value, not `\" + value + \"`\");\n            }\n        }\n        /**\n     * @param {Preset} result\n     * @returns {void}\n     */ function addPreset(result) {\n            addList(result.plugins);\n            if (result.settings) {\n                settings = Object.assign(settings || {}, result.settings);\n            }\n        }\n        /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */ function addList(plugins) {\n            let index = -1;\n            if (plugins === null || plugins === undefined) {\n            // Empty.\n            } else if (Array.isArray(plugins)) {\n                while(++index < plugins.length){\n                    const thing = plugins[index];\n                    add(thing);\n                }\n            } else {\n                throw new TypeError(\"Expected a list of plugins, not `\" + plugins + \"`\");\n            }\n        }\n        /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */ function addPlugin(plugin, value) {\n            let index = -1;\n            /** @type {Processor['attachers'][number]|undefined} */ let entry;\n            while(++index < attachers.length){\n                if (attachers[index][0] === plugin) {\n                    entry = attachers[index];\n                    break;\n                }\n            }\n            if (entry) {\n                if ((0,is_plain_obj__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(entry[1]) && (0,is_plain_obj__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(value)) {\n                    value = extend__WEBPACK_IMPORTED_MODULE_1__(true, entry[1], value);\n                }\n                entry[1] = value;\n            } else {\n                // @ts-expect-error: fine.\n                attachers.push([\n                    ...arguments\n                ]);\n            }\n        }\n    }\n    /** @type {Processor['parse']} */ function parse(doc) {\n        processor.freeze();\n        const file = vfile(doc);\n        const Parser = processor.Parser;\n        assertParser(\"parse\", Parser);\n        if (newable(Parser, \"parse\")) {\n            // @ts-expect-error: `newable` checks this.\n            return new Parser(String(file), file).parse();\n        }\n        // @ts-expect-error: `newable` checks this.\n        return Parser(String(file), file) // eslint-disable-line new-cap\n        ;\n    }\n    /** @type {Processor['stringify']} */ function stringify(node, doc) {\n        processor.freeze();\n        const file = vfile(doc);\n        const Compiler = processor.Compiler;\n        assertCompiler(\"stringify\", Compiler);\n        assertNode(node);\n        if (newable(Compiler, \"compile\")) {\n            // @ts-expect-error: `newable` checks this.\n            return new Compiler(node, file).compile();\n        }\n        // @ts-expect-error: `newable` checks this.\n        return Compiler(node, file) // eslint-disable-line new-cap\n        ;\n    }\n    /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */ function run(node, doc, callback) {\n        assertNode(node);\n        processor.freeze();\n        if (!callback && typeof doc === \"function\") {\n            callback = doc;\n            doc = undefined;\n        }\n        if (!callback) {\n            return new Promise(executor);\n        }\n        executor(null, callback);\n        /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */ function executor(resolve, reject) {\n            // @ts-expect-error: `doc` can’t be a callback anymore, we checked.\n            transformers.run(node, vfile(doc), done);\n            /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */ function done(error, tree, file) {\n                tree = tree || node;\n                if (error) {\n                    reject(error);\n                } else if (resolve) {\n                    resolve(tree);\n                } else {\n                    // @ts-expect-error: `callback` is defined if `resolve` is not.\n                    callback(null, tree, file);\n                }\n            }\n        }\n    }\n    /** @type {Processor['runSync']} */ function runSync(node, file) {\n        /** @type {Node|undefined} */ let result;\n        /** @type {boolean|undefined} */ let complete;\n        processor.run(node, file, done);\n        assertDone(\"runSync\", \"run\", complete);\n        // @ts-expect-error: we either bailed on an error or have a tree.\n        return result;\n        /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */ function done(error, tree) {\n            (0,bail__WEBPACK_IMPORTED_MODULE_4__.bail)(error);\n            result = tree;\n            complete = true;\n        }\n    }\n    /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */ function process(doc, callback) {\n        processor.freeze();\n        assertParser(\"process\", processor.Parser);\n        assertCompiler(\"process\", processor.Compiler);\n        if (!callback) {\n            return new Promise(executor);\n        }\n        executor(null, callback);\n        /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */ function executor(resolve, reject) {\n            const file = vfile(doc);\n            processor.run(processor.parse(file), file, (error, tree, file)=>{\n                if (error || !tree || !file) {\n                    done(error);\n                } else {\n                    /** @type {unknown} */ const result = processor.stringify(tree, file);\n                    if (result === undefined || result === null) {\n                    // Empty.\n                    } else if (looksLikeAVFileValue(result)) {\n                        file.value = result;\n                    } else {\n                        file.result = result;\n                    }\n                    done(error, file);\n                }\n            });\n            /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */ function done(error, file) {\n                if (error || !file) {\n                    reject(error);\n                } else if (resolve) {\n                    resolve(file);\n                } else {\n                    // @ts-expect-error: `callback` is defined if `resolve` is not.\n                    callback(null, file);\n                }\n            }\n        }\n    }\n    /** @type {Processor['processSync']} */ function processSync(doc) {\n        /** @type {boolean|undefined} */ let complete;\n        processor.freeze();\n        assertParser(\"processSync\", processor.Parser);\n        assertCompiler(\"processSync\", processor.Compiler);\n        const file = vfile(doc);\n        processor.process(file, done);\n        assertDone(\"processSync\", \"process\", complete);\n        return file;\n        /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */ function done(error) {\n            complete = true;\n            (0,bail__WEBPACK_IMPORTED_MODULE_4__.bail)(error);\n        }\n    }\n}\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */ function newable(value, name) {\n    return typeof value === \"function\" && // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    value.prototype && // A function with keys in its prototype is probably a constructor.\n    // Classes’ prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    // type-coverage:ignore-next-line\n    (keys(value.prototype) || name in value.prototype);\n}\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */ function keys(value) {\n    /** @type {string} */ let key;\n    for(key in value){\n        if (own.call(value, key)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */ function assertParser(name, value) {\n    if (typeof value !== \"function\") {\n        throw new TypeError(\"Cannot `\" + name + \"` without `Parser`\");\n    }\n}\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */ function assertCompiler(name, value) {\n    if (typeof value !== \"function\") {\n        throw new TypeError(\"Cannot `\" + name + \"` without `Compiler`\");\n    }\n}\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */ function assertUnfrozen(name, frozen) {\n    if (frozen) {\n        throw new Error(\"Cannot call `\" + name + \"` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.\");\n    }\n}\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */ function assertNode(node) {\n    // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n    // type-coverage:ignore-next-line\n    if (!(0,is_plain_obj__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node) || typeof node.type !== \"string\") {\n        throw new TypeError(\"Expected node, got `\" + node + \"`\");\n    // Fine.\n    }\n}\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */ function assertDone(name, asyncName, complete) {\n    if (!complete) {\n        throw new Error(\"`\" + name + \"` finished async. Use `\" + asyncName + \"` instead\");\n    }\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */ function vfile(value) {\n    return looksLikeAVFile(value) ? value : new vfile__WEBPACK_IMPORTED_MODULE_5__.VFile(value);\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */ function looksLikeAVFile(value) {\n    return Boolean(value && typeof value === \"object\" && \"message\" in value && \"messages\" in value);\n}\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */ function looksLikeAVFileValue(value) {\n    return typeof value === \"string\" || is_buffer__WEBPACK_IMPORTED_MODULE_0__(value);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5pZmllZC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FFd0I7QUFDTztBQUNMO0FBQ1U7QUFDUjtBQUNGO0FBRTNCLDZCQUE2QjtBQUN0QixNQUFNTSxVQUFVQyxPQUFPQyxNQUFNLEdBQUU7QUFFdEMsTUFBTUMsTUFBTSxDQUFDLEVBQUVDLGNBQWM7QUFFN0IsMENBQTBDO0FBQzFDOztDQUVDLEdBQ0QsU0FBU0g7SUFDUCxNQUFNSSxlQUFlUCw4Q0FBTUE7SUFDM0IsbUNBQW1DLEdBQ25DLE1BQU1RLFlBQVksRUFBRTtJQUNwQixvQ0FBb0MsR0FDcEMsSUFBSUMsWUFBWSxDQUFDO0lBQ2pCLDhCQUE4QixHQUM5QixJQUFJQztJQUNKLElBQUlDLGNBQWMsQ0FBQztJQUVuQixtQkFBbUI7SUFDbkIsMkNBQTJDO0lBQzNDQyxVQUFVQyxJQUFJLEdBQUdBO0lBQ2pCRCxVQUFVRSxNQUFNLEdBQUdDO0lBQ25CSCxVQUFVSSxRQUFRLEdBQUdEO0lBRXJCLFFBQVE7SUFDUkgsVUFBVVIsTUFBTSxHQUFHQTtJQUVuQixXQUFXO0lBQ1hRLFVBQVVKLFNBQVMsR0FBR0E7SUFDdEIsMkNBQTJDO0lBQzNDSSxVQUFVSyxHQUFHLEdBQUdBO0lBRWhCLE9BQU87SUFDUEwsVUFBVU0sS0FBSyxHQUFHQTtJQUNsQk4sVUFBVU8sU0FBUyxHQUFHQTtJQUN0QiwyQ0FBMkM7SUFDM0NQLFVBQVVRLEdBQUcsR0FBR0E7SUFDaEJSLFVBQVVTLE9BQU8sR0FBR0E7SUFDcEIsMkNBQTJDO0lBQzNDVCxVQUFVVSxPQUFPLEdBQUdBO0lBQ3BCVixVQUFVVyxXQUFXLEdBQUdBO0lBRXhCLFVBQVU7SUFDVixPQUFPWDtJQUVQLHNFQUFzRTtJQUN0RSxzQkFBc0IsR0FDdEIsU0FBU0E7UUFDUCxNQUFNWSxjQUFjckI7UUFDcEIsSUFBSXNCLFFBQVEsQ0FBQztRQUViLE1BQU8sRUFBRUEs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QUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU3hCLE1BQU0zQixLQUFLO0lBQ2xCLE9BQU9vRCxnQkFBZ0JwRCxTQUFTQSxRQUFRLElBQUkzQix3Q0FBS0EsQ0FBQzJCO0FBQ3BEO0FBRUE7OztDQUdDLEdBQ0QsU0FBU29ELGdCQUFnQnBELEtBQUs7SUFDNUIsT0FBT3FELFFBQ0xyRCxTQUNFLE9BQU9BLFVBQVUsWUFDakIsYUFBYUEsU0FDYixjQUFjQTtBQUVwQjtBQUVBOzs7Q0FHQyxHQUNELFNBQVM2QyxxQkFBcUI3QyxLQUFLO0lBQ2pDLE9BQU8sT0FBT0EsVUFBVSxZQUFZL0Isc0NBQVFBLENBQUMrQjtBQUMvQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tYWktdGVtcGxhdGUtcHJvLy4vbm9kZV9tb2R1bGVzL3VuaWZpZWQvbGliL2luZGV4LmpzPzM5MzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLk5vZGV9IE5vZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3ZmaWxlJykuVkZpbGVDb21wYXRpYmxlfSBWRmlsZUNvbXBhdGlibGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3ZmaWxlJykuVkZpbGVWYWx1ZX0gVkZpbGVWYWx1ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5Qcm9jZXNzb3J9IFByb2Nlc3NvclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5QbHVnaW59IFBsdWdpblxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5QcmVzZXR9IFByZXNldFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5QbHVnZ2FibGV9IFBsdWdnYWJsZVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5QbHVnZ2FibGVMaXN0fSBQbHVnZ2FibGVMaXN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlRyYW5zZm9ybWVyfSBUcmFuc2Zvcm1lclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5QYXJzZXJ9IFBhcnNlclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5Db21waWxlcn0gQ29tcGlsZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uJykuUnVuQ2FsbGJhY2t9IFJ1bkNhbGxiYWNrXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlByb2Nlc3NDYWxsYmFja30gUHJvY2Vzc0NhbGxiYWNrXG4gKlxuICogQHR5cGVkZWYgQ29udGV4dFxuICogQHByb3BlcnR5IHtOb2RlfSB0cmVlXG4gKiBAcHJvcGVydHkge1ZGaWxlfSBmaWxlXG4gKi9cblxuaW1wb3J0IHtiYWlsfSBmcm9tICdiYWlsJ1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJ2lzLWJ1ZmZlcidcbmltcG9ydCBleHRlbmQgZnJvbSAnZXh0ZW5kJ1xuaW1wb3J0IGlzUGxhaW5PYmogZnJvbSAnaXMtcGxhaW4tb2JqJ1xuaW1wb3J0IHt0cm91Z2h9IGZyb20gJ3Ryb3VnaCdcbmltcG9ydCB7VkZpbGV9IGZyb20gJ3ZmaWxlJ1xuXG4vLyBFeHBvc2UgYSBmcm96ZW4gcHJvY2Vzc29yLlxuZXhwb3J0IGNvbnN0IHVuaWZpZWQgPSBiYXNlKCkuZnJlZXplKClcblxuY29uc3Qgb3duID0ge30uaGFzT3duUHJvcGVydHlcblxuLy8gRnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBmaXJzdCBwcm9jZXNzb3IuXG4vKipcbiAqIEByZXR1cm5zIHtQcm9jZXNzb3J9XG4gKi9cbmZ1bmN0aW9uIGJhc2UoKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVycyA9IHRyb3VnaCgpXG4gIC8qKiBAdHlwZSB7UHJvY2Vzc29yWydhdHRhY2hlcnMnXX0gKi9cbiAgY29uc3QgYXR0YWNoZXJzID0gW11cbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gKi9cbiAgbGV0IG5hbWVzcGFjZSA9IHt9XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9ICovXG4gIGxldCBmcm96ZW5cbiAgbGV0IGZyZWV6ZUluZGV4ID0gLTFcblxuICAvLyBEYXRhIG1hbmFnZW1lbnQuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IG92ZXJsb2FkcyBhcmUgaGFuZGxlZC5cbiAgcHJvY2Vzc29yLmRhdGEgPSBkYXRhXG4gIHByb2Nlc3Nvci5QYXJzZXIgPSB1bmRlZmluZWRcbiAgcHJvY2Vzc29yLkNvbXBpbGVyID0gdW5kZWZpbmVkXG5cbiAgLy8gTG9jay5cbiAgcHJvY2Vzc29yLmZyZWV6ZSA9IGZyZWV6ZVxuXG4gIC8vIFBsdWdpbnMuXG4gIHByb2Nlc3Nvci5hdHRhY2hlcnMgPSBhdHRhY2hlcnNcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogb3ZlcmxvYWRzIGFyZSBoYW5kbGVkLlxuICBwcm9jZXNzb3IudXNlID0gdXNlXG5cbiAgLy8gQVBJLlxuICBwcm9jZXNzb3IucGFyc2UgPSBwYXJzZVxuICBwcm9jZXNzb3Iuc3RyaW5naWZ5ID0gc3RyaW5naWZ5XG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IG92ZXJsb2FkcyBhcmUgaGFuZGxlZC5cbiAgcHJvY2Vzc29yLnJ1biA9IHJ1blxuICBwcm9jZXNzb3IucnVuU3luYyA9IHJ1blN5bmNcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogb3ZlcmxvYWRzIGFyZSBoYW5kbGVkLlxuICBwcm9jZXNzb3IucHJvY2VzcyA9IHByb2Nlc3NcbiAgcHJvY2Vzc29yLnByb2Nlc3NTeW5jID0gcHJvY2Vzc1N5bmNcblxuICAvLyBFeHBvc2UuXG4gIHJldHVybiBwcm9jZXNzb3JcblxuICAvLyBDcmVhdGUgYSBuZXcgcHJvY2Vzc29yIGJhc2VkIG9uIHRoZSBwcm9jZXNzb3IgaW4gdGhlIGN1cnJlbnQgc2NvcGUuXG4gIC8qKiBAdHlwZSB7UHJvY2Vzc29yfSAqL1xuICBmdW5jdGlvbiBwcm9jZXNzb3IoKSB7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSBiYXNlKClcbiAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBhdHRhY2hlcnMubGVuZ3RoKSB7XG4gICAgICBkZXN0aW5hdGlvbi51c2UoLi4uYXR0YWNoZXJzW2luZGV4XSlcbiAgICB9XG5cbiAgICBkZXN0aW5hdGlvbi5kYXRhKGV4dGVuZCh0cnVlLCB7fSwgbmFtZXNwYWNlKSlcblxuICAgIHJldHVybiBkZXN0aW5hdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfFJlY29yZDxzdHJpbmcsIHVua25vd24+fSBba2V5XVxuICAgKiBAcGFyYW0ge3Vua25vd259IFt2YWx1ZV1cbiAgICogQHJldHVybnMge3Vua25vd259XG4gICAqL1xuICBmdW5jdGlvbiBkYXRhKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFNldCBga2V5YC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGFzc2VydFVuZnJvemVuKCdkYXRhJywgZnJvemVuKVxuICAgICAgICBuYW1lc3BhY2Vba2V5XSA9IHZhbHVlXG4gICAgICAgIHJldHVybiBwcm9jZXNzb3JcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGBrZXlgLlxuICAgICAgcmV0dXJuIChvd24uY2FsbChuYW1lc3BhY2UsIGtleSkgJiYgbmFtZXNwYWNlW2tleV0pIHx8IG51bGxcbiAgICB9XG5cbiAgICAvLyBTZXQgc3BhY2UuXG4gICAgaWYgKGtleSkge1xuICAgICAgYXNzZXJ0VW5mcm96ZW4oJ2RhdGEnLCBmcm96ZW4pXG4gICAgICBuYW1lc3BhY2UgPSBrZXlcbiAgICAgIHJldHVybiBwcm9jZXNzb3JcbiAgICB9XG5cbiAgICAvLyBHZXQgc3BhY2UuXG4gICAgcmV0dXJuIG5hbWVzcGFjZVxuICB9XG5cbiAgLyoqIEB0eXBlIHtQcm9jZXNzb3JbJ2ZyZWV6ZSddfSAqL1xuICBmdW5jdGlvbiBmcmVlemUoKSB7XG4gICAgaWYgKGZyb3plbikge1xuICAgICAgcmV0dXJuIHByb2Nlc3NvclxuICAgIH1cblxuICAgIHdoaWxlICgrK2ZyZWV6ZUluZGV4IDwgYXR0YWNoZXJzLmxlbmd0aCkge1xuICAgICAgY29uc3QgW2F0dGFjaGVyLCAuLi5vcHRpb25zXSA9IGF0dGFjaGVyc1tmcmVlemVJbmRleF1cblxuICAgICAgaWYgKG9wdGlvbnNbMF0gPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zWzBdID09PSB0cnVlKSB7XG4gICAgICAgIG9wdGlvbnNbMF0gPSB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgLyoqIEB0eXBlIHtUcmFuc2Zvcm1lcnx2b2lkfSAqL1xuICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSBhdHRhY2hlci5jYWxsKHByb2Nlc3NvciwgLi4ub3B0aW9ucylcblxuICAgICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm1lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0cmFuc2Zvcm1lcnMudXNlKHRyYW5zZm9ybWVyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZyb3plbiA9IHRydWVcbiAgICBmcmVlemVJbmRleCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuXG4gICAgcmV0dXJuIHByb2Nlc3NvclxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UGx1Z2dhYmxlfG51bGx8dW5kZWZpbmVkfSBbdmFsdWVdXG4gICAqIEBwYXJhbSB7Li4udW5rbm93bn0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvY2Vzc29yfVxuICAgKi9cbiAgZnVuY3Rpb24gdXNlKHZhbHVlLCAuLi5vcHRpb25zKSB7XG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPnx1bmRlZmluZWR9ICovXG4gICAgbGV0IHNldHRpbmdzXG5cbiAgICBhc3NlcnRVbmZyb3plbigndXNlJywgZnJvemVuKVxuXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEVtcHR5LlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRQbHVnaW4odmFsdWUsIC4uLm9wdGlvbnMpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgYWRkTGlzdCh2YWx1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZFByZXNldCh2YWx1ZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdXNhYmxlIHZhbHVlLCBub3QgYCcgKyB2YWx1ZSArICdgJylcbiAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgIG5hbWVzcGFjZS5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24obmFtZXNwYWNlLnNldHRpbmdzIHx8IHt9LCBzZXR0aW5ncylcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvY2Vzc29yXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4nKS5QbHVnZ2FibGU8dW5rbm93bltdPn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYWRkUGx1Z2luKHZhbHVlKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGNvbnN0IFtwbHVnaW4sIC4uLm9wdGlvbnNdID0gdmFsdWVcbiAgICAgICAgICBhZGRQbHVnaW4ocGx1Z2luLCAuLi5vcHRpb25zKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZFByZXNldCh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdXNhYmxlIHZhbHVlLCBub3QgYCcgKyB2YWx1ZSArICdgJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1ByZXNldH0gcmVzdWx0XG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkUHJlc2V0KHJlc3VsdCkge1xuICAgICAgYWRkTGlzdChyZXN1bHQucGx1Z2lucylcblxuICAgICAgaWYgKHJlc3VsdC5zZXR0aW5ncykge1xuICAgICAgICBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oc2V0dGluZ3MgfHwge30sIHJlc3VsdC5zZXR0aW5ncylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BsdWdnYWJsZUxpc3R8bnVsbHx1bmRlZmluZWR9IFtwbHVnaW5zXVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZExpc3QocGx1Z2lucykge1xuICAgICAgbGV0IGluZGV4ID0gLTFcblxuICAgICAgaWYgKHBsdWdpbnMgPT09IG51bGwgfHwgcGx1Z2lucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEVtcHR5LlxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBsdWdpbnMpKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgcGx1Z2lucy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB0aGluZyA9IHBsdWdpbnNbaW5kZXhdXG4gICAgICAgICAgYWRkKHRoaW5nKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIGxpc3Qgb2YgcGx1Z2lucywgbm90IGAnICsgcGx1Z2lucyArICdgJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BsdWdpbn0gcGx1Z2luXG4gICAgICogQHBhcmFtIHsuLi51bmtub3dufSBbdmFsdWVdXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkUGx1Z2luKHBsdWdpbiwgdmFsdWUpIHtcbiAgICAgIGxldCBpbmRleCA9IC0xXG4gICAgICAvKiogQHR5cGUge1Byb2Nlc3NvclsnYXR0YWNoZXJzJ11bbnVtYmVyXXx1bmRlZmluZWR9ICovXG4gICAgICBsZXQgZW50cnlcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBhdHRhY2hlcnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChhdHRhY2hlcnNbaW5kZXhdWzBdID09PSBwbHVnaW4pIHtcbiAgICAgICAgICBlbnRyeSA9IGF0dGFjaGVyc1tpbmRleF1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICBpZiAoaXNQbGFpbk9iaihlbnRyeVsxXSkgJiYgaXNQbGFpbk9iaih2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGV4dGVuZCh0cnVlLCBlbnRyeVsxXSwgdmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBlbnRyeVsxXSA9IHZhbHVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBmaW5lLlxuICAgICAgICBhdHRhY2hlcnMucHVzaChbLi4uYXJndW1lbnRzXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQHR5cGUge1Byb2Nlc3NvclsncGFyc2UnXX0gKi9cbiAgZnVuY3Rpb24gcGFyc2UoZG9jKSB7XG4gICAgcHJvY2Vzc29yLmZyZWV6ZSgpXG4gICAgY29uc3QgZmlsZSA9IHZmaWxlKGRvYylcbiAgICBjb25zdCBQYXJzZXIgPSBwcm9jZXNzb3IuUGFyc2VyXG4gICAgYXNzZXJ0UGFyc2VyKCdwYXJzZScsIFBhcnNlcilcblxuICAgIGlmIChuZXdhYmxlKFBhcnNlciwgJ3BhcnNlJykpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBuZXdhYmxlYCBjaGVja3MgdGhpcy5cbiAgICAgIHJldHVybiBuZXcgUGFyc2VyKFN0cmluZyhmaWxlKSwgZmlsZSkucGFyc2UoKVxuICAgIH1cblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBuZXdhYmxlYCBjaGVja3MgdGhpcy5cbiAgICByZXR1cm4gUGFyc2VyKFN0cmluZyhmaWxlKSwgZmlsZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gIH1cblxuICAvKiogQHR5cGUge1Byb2Nlc3Nvclsnc3RyaW5naWZ5J119ICovXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlLCBkb2MpIHtcbiAgICBwcm9jZXNzb3IuZnJlZXplKClcbiAgICBjb25zdCBmaWxlID0gdmZpbGUoZG9jKVxuICAgIGNvbnN0IENvbXBpbGVyID0gcHJvY2Vzc29yLkNvbXBpbGVyXG4gICAgYXNzZXJ0Q29tcGlsZXIoJ3N0cmluZ2lmeScsIENvbXBpbGVyKVxuICAgIGFzc2VydE5vZGUobm9kZSlcblxuICAgIGlmIChuZXdhYmxlKENvbXBpbGVyLCAnY29tcGlsZScpKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgbmV3YWJsZWAgY2hlY2tzIHRoaXMuXG4gICAgICByZXR1cm4gbmV3IENvbXBpbGVyKG5vZGUsIGZpbGUpLmNvbXBpbGUoKVxuICAgIH1cblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBuZXdhYmxlYCBjaGVja3MgdGhpcy5cbiAgICByZXR1cm4gQ29tcGlsZXIobm9kZSwgZmlsZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7VkZpbGVDb21wYXRpYmxlfFJ1bkNhbGxiYWNrfSBbZG9jXVxuICAgKiBAcGFyYW0ge1J1bkNhbGxiYWNrfSBbY2FsbGJhY2tdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE5vZGU+fHZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiBydW4obm9kZSwgZG9jLCBjYWxsYmFjaykge1xuICAgIGFzc2VydE5vZGUobm9kZSlcbiAgICBwcm9jZXNzb3IuZnJlZXplKClcblxuICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIGRvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBkb2NcbiAgICAgIGRvYyA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShleGVjdXRvcilcbiAgICB9XG5cbiAgICBleGVjdXRvcihudWxsLCBjYWxsYmFjaylcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVsbHwoKG5vZGU6IE5vZGUpID0+IHZvaWQpfSByZXNvbHZlXG4gICAgICogQHBhcmFtIHsoZXJyb3I6IEVycm9yKSA9PiB2b2lkfSByZWplY3RcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBkb2NgIGNhbuKAmXQgYmUgYSBjYWxsYmFjayBhbnltb3JlLCB3ZSBjaGVja2VkLlxuICAgICAgdHJhbnNmb3JtZXJzLnJ1bihub2RlLCB2ZmlsZShkb2MpLCBkb25lKVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3JcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gdHJlZVxuICAgICAgICogQHBhcmFtIHtWRmlsZX0gZmlsZVxuICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyb3IsIHRyZWUsIGZpbGUpIHtcbiAgICAgICAgdHJlZSA9IHRyZWUgfHwgbm9kZVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgIH0gZWxzZSBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUodHJlZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgY2FsbGJhY2tgIGlzIGRlZmluZWQgaWYgYHJlc29sdmVgIGlzIG5vdC5cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCB0cmVlLCBmaWxlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEB0eXBlIHtQcm9jZXNzb3JbJ3J1blN5bmMnXX0gKi9cbiAgZnVuY3Rpb24gcnVuU3luYyhub2RlLCBmaWxlKSB7XG4gICAgLyoqIEB0eXBlIHtOb2RlfHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgcmVzdWx0XG4gICAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgY29tcGxldGVcblxuICAgIHByb2Nlc3Nvci5ydW4obm9kZSwgZmlsZSwgZG9uZSlcblxuICAgIGFzc2VydERvbmUoJ3J1blN5bmMnLCAncnVuJywgY29tcGxldGUpXG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZSBlaXRoZXIgYmFpbGVkIG9uIGFuIGVycm9yIG9yIGhhdmUgYSB0cmVlLlxuICAgIHJldHVybiByZXN1bHRcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gW2Vycm9yXVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gW3RyZWVdXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9uZShlcnJvciwgdHJlZSkge1xuICAgICAgYmFpbChlcnJvcilcbiAgICAgIHJlc3VsdCA9IHRyZWVcbiAgICAgIGNvbXBsZXRlID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1ZGaWxlQ29tcGF0aWJsZX0gZG9jXG4gICAqIEBwYXJhbSB7UHJvY2Vzc0NhbGxiYWNrfSBbY2FsbGJhY2tdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFZGaWxlPnx1bmRlZmluZWR9XG4gICAqL1xuICBmdW5jdGlvbiBwcm9jZXNzKGRvYywgY2FsbGJhY2spIHtcbiAgICBwcm9jZXNzb3IuZnJlZXplKClcbiAgICBhc3NlcnRQYXJzZXIoJ3Byb2Nlc3MnLCBwcm9jZXNzb3IuUGFyc2VyKVxuICAgIGFzc2VydENvbXBpbGVyKCdwcm9jZXNzJywgcHJvY2Vzc29yLkNvbXBpbGVyKVxuXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGV4ZWN1dG9yKVxuICAgIH1cblxuICAgIGV4ZWN1dG9yKG51bGwsIGNhbGxiYWNrKVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudWxsfCgoZmlsZTogVkZpbGUpID0+IHZvaWQpfSByZXNvbHZlXG4gICAgICogQHBhcmFtIHsoZXJyb3I/OiBFcnJvcnxudWxsfHVuZGVmaW5lZCkgPT4gdm9pZH0gcmVqZWN0XG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBjb25zdCBmaWxlID0gdmZpbGUoZG9jKVxuXG4gICAgICBwcm9jZXNzb3IucnVuKHByb2Nlc3Nvci5wYXJzZShmaWxlKSwgZmlsZSwgKGVycm9yLCB0cmVlLCBmaWxlKSA9PiB7XG4gICAgICAgIGlmIChlcnJvciB8fCAhdHJlZSB8fCAhZmlsZSkge1xuICAgICAgICAgIGRvbmUoZXJyb3IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHt1bmtub3dufSAqL1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3Nvci5zdHJpbmdpZnkodHJlZSwgZmlsZSlcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCB8fCByZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEVtcHR5LlxuICAgICAgICAgIH0gZWxzZSBpZiAobG9va3NMaWtlQVZGaWxlVmFsdWUocmVzdWx0KSkge1xuICAgICAgICAgICAgZmlsZS52YWx1ZSA9IHJlc3VsdFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWxlLnJlc3VsdCA9IHJlc3VsdFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvbmUoZXJyb3IsIGZpbGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtFcnJvcnxudWxsfHVuZGVmaW5lZH0gW2Vycm9yXVxuICAgICAgICogQHBhcmFtIHtWRmlsZXx1bmRlZmluZWR9IFtmaWxlXVxuICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyb3IsIGZpbGUpIHtcbiAgICAgICAgaWYgKGVycm9yIHx8ICFmaWxlKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9IGVsc2UgaWYgKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKGZpbGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYGNhbGxiYWNrYCBpcyBkZWZpbmVkIGlmIGByZXNvbHZlYCBpcyBub3QuXG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgZmlsZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAdHlwZSB7UHJvY2Vzc29yWydwcm9jZXNzU3luYyddfSAqL1xuICBmdW5jdGlvbiBwcm9jZXNzU3luYyhkb2MpIHtcbiAgICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuICAgIGxldCBjb21wbGV0ZVxuXG4gICAgcHJvY2Vzc29yLmZyZWV6ZSgpXG4gICAgYXNzZXJ0UGFyc2VyKCdwcm9jZXNzU3luYycsIHByb2Nlc3Nvci5QYXJzZXIpXG4gICAgYXNzZXJ0Q29tcGlsZXIoJ3Byb2Nlc3NTeW5jJywgcHJvY2Vzc29yLkNvbXBpbGVyKVxuXG4gICAgY29uc3QgZmlsZSA9IHZmaWxlKGRvYylcblxuICAgIHByb2Nlc3Nvci5wcm9jZXNzKGZpbGUsIGRvbmUpXG5cbiAgICBhc3NlcnREb25lKCdwcm9jZXNzU3luYycsICdwcm9jZXNzJywgY29tcGxldGUpXG5cbiAgICByZXR1cm4gZmlsZVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFcnJvcnxudWxsfHVuZGVmaW5lZH0gW2Vycm9yXVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvbmUoZXJyb3IpIHtcbiAgICAgIGNvbXBsZXRlID0gdHJ1ZVxuICAgICAgYmFpbChlcnJvcilcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgdmFsdWVgIGlzIGEgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBuZXdhYmxlKHZhbHVlLCBuYW1lKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmXG4gICAgLy8gUHJvdG90eXBlcyBkbyBleGlzdC5cbiAgICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgICB2YWx1ZS5wcm90b3R5cGUgJiZcbiAgICAvLyBBIGZ1bmN0aW9uIHdpdGgga2V5cyBpbiBpdHMgcHJvdG90eXBlIGlzIHByb2JhYmx5IGEgY29uc3RydWN0b3IuXG4gICAgLy8gQ2xhc3Nlc+KAmSBwcm90b3R5cGUgbWV0aG9kcyBhcmUgbm90IGVudW1lcmFibGUsIHNvIHdlIGNoZWNrIGlmIHNvbWUgdmFsdWVcbiAgICAvLyBleGlzdHMgaW4gdGhlIHByb3RvdHlwZS5cbiAgICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgICAoa2V5cyh2YWx1ZS5wcm90b3R5cGUpIHx8IG5hbWUgaW4gdmFsdWUucHJvdG90eXBlKVxuICApXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3Qgd2l0aCBrZXlzLlxuICpcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24ga2V5cyh2YWx1ZSkge1xuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgbGV0IGtleVxuXG4gIGZvciAoa2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKG93bi5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIEFzc2VydCBhIHBhcnNlciBpcyBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIFBhcnNlcn1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UGFyc2VyKG5hbWUsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgYCcgKyBuYW1lICsgJ2Agd2l0aG91dCBgUGFyc2VyYCcpXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgYSBjb21waWxlciBpcyBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIENvbXBpbGVyfVxuICovXG5mdW5jdGlvbiBhc3NlcnRDb21waWxlcihuYW1lLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGAnICsgbmFtZSArICdgIHdpdGhvdXQgYENvbXBpbGVyYCcpXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhlIHByb2Nlc3NvciBpcyBub3QgZnJvemVuLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3Vua25vd259IGZyb3plblxuICogQHJldHVybnMge2Fzc2VydHMgZnJvemVuIGlzIGZhbHNlfVxuICovXG5mdW5jdGlvbiBhc3NlcnRVbmZyb3plbihuYW1lLCBmcm96ZW4pIHtcbiAgaWYgKGZyb3plbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW5ub3QgY2FsbCBgJyArXG4gICAgICAgIG5hbWUgK1xuICAgICAgICAnYCBvbiBhIGZyb3plbiBwcm9jZXNzb3IuXFxuQ3JlYXRlIGEgbmV3IHByb2Nlc3NvciBmaXJzdCwgYnkgY2FsbGluZyBpdDogdXNlIGBwcm9jZXNzb3IoKWAgaW5zdGVhZCBvZiBgcHJvY2Vzc29yYC4nXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IGBub2RlYCBpcyBhIHVuaXN0IG5vZGUuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSBub2RlXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyBub2RlIGlzIE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydE5vZGUobm9kZSkge1xuICAvLyBgaXNQbGFpbk9iamAgdW5mb3J0dW5hdGVseSB1c2VzIGBhbnlgIGluc3RlYWQgb2YgYHVua25vd25gLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgaWYgKCFpc1BsYWluT2JqKG5vZGUpIHx8IHR5cGVvZiBub2RlLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgbm9kZSwgZ290IGAnICsgbm9kZSArICdgJylcbiAgICAvLyBGaW5lLlxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgYGNvbXBsZXRlYCBpcyBgdHJ1ZWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhc3luY05hbWVcbiAqIEBwYXJhbSB7dW5rbm93bn0gY29tcGxldGVcbiAqIEByZXR1cm5zIHthc3NlcnRzIGNvbXBsZXRlIGlzIHRydWV9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydERvbmUobmFtZSwgYXN5bmNOYW1lLCBjb21wbGV0ZSkge1xuICBpZiAoIWNvbXBsZXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2AnICsgbmFtZSArICdgIGZpbmlzaGVkIGFzeW5jLiBVc2UgYCcgKyBhc3luY05hbWUgKyAnYCBpbnN0ZWFkJ1xuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VkZpbGVDb21wYXRpYmxlfSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7VkZpbGV9XG4gKi9cbmZ1bmN0aW9uIHZmaWxlKHZhbHVlKSB7XG4gIHJldHVybiBsb29rc0xpa2VBVkZpbGUodmFsdWUpID8gdmFsdWUgOiBuZXcgVkZpbGUodmFsdWUpXG59XG5cbi8qKlxuICogQHBhcmFtIHtWRmlsZUNvbXBhdGlibGV9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBWRmlsZX1cbiAqL1xuZnVuY3Rpb24gbG9va3NMaWtlQVZGaWxlKHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIHZhbHVlICYmXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAnbWVzc2FnZScgaW4gdmFsdWUgJiZcbiAgICAgICdtZXNzYWdlcycgaW4gdmFsdWVcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gW3ZhbHVlXVxuICogQHJldHVybnMge3ZhbHVlIGlzIFZGaWxlVmFsdWV9XG4gKi9cbmZ1bmN0aW9uIGxvb2tzTGlrZUFWRmlsZVZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IGlzQnVmZmVyKHZhbHVlKVxufVxuIl0sIm5hbWVzIjpbImJhaWwiLCJpc0J1ZmZlciIsImV4dGVuZCIsImlzUGxhaW5PYmoiLCJ0cm91Z2giLCJWRmlsZSIsInVuaWZpZWQiLCJiYXNlIiwiZnJlZXplIiwib3duIiwiaGFzT3duUHJvcGVydHkiLCJ0cmFuc2Zvcm1lcnMiLCJhdHRhY2hlcnMiLCJuYW1lc3BhY2UiLCJmcm96ZW4iLCJmcmVlemVJbmRleCIsInByb2Nlc3NvciIsImRhdGEiLCJQYXJzZXIiLCJ1bmRlZmluZWQiLCJDb21waWxlciIsInVzZSIsInBhcnNlIiwic3RyaW5naWZ5IiwicnVuIiwicnVuU3luYyIsInByb2Nlc3MiLCJwcm9jZXNzU3luYyIsImRlc3RpbmF0aW9uIiwiaW5kZXgiLCJsZW5ndGgiLCJrZXkiLCJ2YWx1ZSIsImFyZ3VtZW50cyIsImFzc2VydFVuZnJvemVuIiwiY2FsbCIsImF0dGFjaGVyIiwib3B0aW9ucyIsInRyYW5zZm9ybWVyIiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJzZXR0aW5ncyIsImFkZFBsdWdpbiIsIkFycmF5IiwiaXNBcnJheSIsImFkZExpc3QiLCJhZGRQcmVzZXQiLCJUeXBlRXJyb3IiLCJPYmplY3QiLCJhc3NpZ24iLCJhZGQiLCJwbHVnaW4iLCJyZXN1bHQiLCJwbHVnaW5zIiwidGhpbmciLCJlbnRyeSIsInB1c2giLCJkb2MiLCJmaWxlIiwidmZpbGUiLCJhc3NlcnRQYXJzZXIiLCJuZXdhYmxlIiwiU3RyaW5nIiwibm9kZSIsImFzc2VydENvbXBpbGVyIiwiYXNzZXJ0Tm9kZSIsImNvbXBpbGUiLCJjYWxsYmFjayIsIlByb21pc2UiLCJleGVjdXRvciIsInJlc29sdmUiLCJyZWplY3QiLCJkb25lIiwiZXJyb3IiLCJ0cmVlIiwiY29tcGxldGUiLCJhc3NlcnREb25lIiwibG9va3NMaWtlQVZGaWxlVmFsdWUiLCJuYW1lIiwicHJvdG90eXBlIiwia2V5cyIsIkVycm9yIiwidHlwZSIsImFzeW5jTmFtZSIsImxvb2tzTGlrZUFWRmlsZSIsIkJvb2xlYW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/unified/lib/index.js\n");

/***/ })

};
;