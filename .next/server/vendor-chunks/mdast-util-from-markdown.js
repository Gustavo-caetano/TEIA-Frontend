"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdast-util-from-markdown";
exports.ids = ["vendor-chunks/mdast-util-from-markdown"];
exports.modules = {

/***/ "(ssr)/./node_modules/mdast-util-from-markdown/dev/lib/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/mdast-util-from-markdown/dev/lib/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromMarkdown: () => (/* binding */ fromMarkdown)\n/* harmony export */ });\n/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uvu/assert */ \"(ssr)/./node_modules/uvu/assert/index.mjs\");\n/* harmony import */ var mdast_util_to_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! mdast-util-to-string */ \"(ssr)/./node_modules/mdast-util-to-string/lib/index.js\");\n/* harmony import */ var micromark_lib_parse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark/lib/parse.js */ \"(ssr)/./node_modules/micromark/dev/lib/parse.js\");\n/* harmony import */ var micromark_lib_preprocess_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark/lib/preprocess.js */ \"(ssr)/./node_modules/micromark/dev/lib/preprocess.js\");\n/* harmony import */ var micromark_lib_postprocess_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark/lib/postprocess.js */ \"(ssr)/./node_modules/micromark/dev/lib/postprocess.js\");\n/* harmony import */ var micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! micromark-util-decode-numeric-character-reference */ \"(ssr)/./node_modules/micromark-util-decode-numeric-character-reference/dev/index.js\");\n/* harmony import */ var micromark_util_decode_string__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! micromark-util-decode-string */ \"(ssr)/./node_modules/micromark-util-decode-string/dev/index.js\");\n/* harmony import */ var micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! micromark-util-normalize-identifier */ \"(ssr)/./node_modules/micromark-util-normalize-identifier/dev/index.js\");\n/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ \"(ssr)/./node_modules/micromark-util-symbol/codes.js\");\n/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ \"(ssr)/./node_modules/micromark-util-symbol/constants.js\");\n/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/types.js */ \"(ssr)/./node_modules/micromark-util-symbol/types.js\");\n/* harmony import */ var decode_named_character_reference__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! decode-named-character-reference */ \"(ssr)/./node_modules/decode-named-character-reference/index.js\");\n/* harmony import */ var unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-stringify-position */ \"(ssr)/./node_modules/unist-util-stringify-position/lib/index.js\");\n/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('../index.js').CompileData} CompileData\n */ /**\n * @typedef {Root | Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n *\n * @typedef {Omit<UnistParent, 'type' | 'children'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */ /**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | undefined | null | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isn’t closed properly.\n */ /**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Node | Fragment>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {<Key extends keyof CompileData>(key: Key) => CompileData[Key]} getData\n *   Get data from the key/value store.\n * @property {<Key extends keyof CompileData>(key: Key, value?: CompileData[Key]) => void} setData\n *   Set data into the key/value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<Kind extends Node>(this: CompileContext, node: Kind, token: Token, onError?: OnEnterError) => Kind} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */ // To do: micromark: create a registry of tokens?\n// To do: next major: don’t return given `Node` from `enter`.\n// To do: next major: remove setter/getter.\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst own = {}.hasOwnProperty;\n/**\n * @param value\n *   Markdown to parse.\n * @param encoding\n *   Character encoding for when `value` is `Buffer`.\n * @param options\n *   Configuration.\n * @returns\n *   mdast tree.\n */ const fromMarkdown = /**\n   * @type {(\n   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &\n   *   ((value: Value, options?: Options | null | undefined) => Root)\n   * )}\n   */ /**\n     * @param {Value} value\n     * @param {Encoding | Options | null | undefined} [encoding]\n     * @param {Options | null | undefined} [options]\n     * @returns {Root}\n     */ function(value, encoding, options) {\n    if (typeof encoding !== \"string\") {\n        options = encoding;\n        encoding = undefined;\n    }\n    return compiler(options)((0,micromark_lib_postprocess_js__WEBPACK_IMPORTED_MODULE_1__.postprocess)((0,micromark_lib_parse_js__WEBPACK_IMPORTED_MODULE_2__.parse)(options).document().write((0,micromark_lib_preprocess_js__WEBPACK_IMPORTED_MODULE_3__.preprocess)()(value, encoding, true))));\n};\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */ function compiler(options) {\n    /** @type {Config} */ const config = {\n        transforms: [],\n        canContainEols: [\n            \"emphasis\",\n            \"fragment\",\n            \"heading\",\n            \"paragraph\",\n            \"strong\"\n        ],\n        enter: {\n            autolink: opener(link),\n            autolinkProtocol: onenterdata,\n            autolinkEmail: onenterdata,\n            atxHeading: opener(heading),\n            blockQuote: opener(blockQuote),\n            characterEscape: onenterdata,\n            characterReference: onenterdata,\n            codeFenced: opener(codeFlow),\n            codeFencedFenceInfo: buffer,\n            codeFencedFenceMeta: buffer,\n            codeIndented: opener(codeFlow, buffer),\n            codeText: opener(codeText, buffer),\n            codeTextData: onenterdata,\n            data: onenterdata,\n            codeFlowValue: onenterdata,\n            definition: opener(definition),\n            definitionDestinationString: buffer,\n            definitionLabelString: buffer,\n            definitionTitleString: buffer,\n            emphasis: opener(emphasis),\n            hardBreakEscape: opener(hardBreak),\n            hardBreakTrailing: opener(hardBreak),\n            htmlFlow: opener(html, buffer),\n            htmlFlowData: onenterdata,\n            htmlText: opener(html, buffer),\n            htmlTextData: onenterdata,\n            image: opener(image),\n            label: buffer,\n            link: opener(link),\n            listItem: opener(listItem),\n            listItemValue: onenterlistitemvalue,\n            listOrdered: opener(list, onenterlistordered),\n            listUnordered: opener(list),\n            paragraph: opener(paragraph),\n            reference: onenterreference,\n            referenceString: buffer,\n            resourceDestinationString: buffer,\n            resourceTitleString: buffer,\n            setextHeading: opener(heading),\n            strong: opener(strong),\n            thematicBreak: opener(thematicBreak)\n        },\n        exit: {\n            atxHeading: closer(),\n            atxHeadingSequence: onexitatxheadingsequence,\n            autolink: closer(),\n            autolinkEmail: onexitautolinkemail,\n            autolinkProtocol: onexitautolinkprotocol,\n            blockQuote: closer(),\n            characterEscapeValue: onexitdata,\n            characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n            characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n            characterReferenceValue: onexitcharacterreferencevalue,\n            codeFenced: closer(onexitcodefenced),\n            codeFencedFence: onexitcodefencedfence,\n            codeFencedFenceInfo: onexitcodefencedfenceinfo,\n            codeFencedFenceMeta: onexitcodefencedfencemeta,\n            codeFlowValue: onexitdata,\n            codeIndented: closer(onexitcodeindented),\n            codeText: closer(onexitcodetext),\n            codeTextData: onexitdata,\n            data: onexitdata,\n            definition: closer(),\n            definitionDestinationString: onexitdefinitiondestinationstring,\n            definitionLabelString: onexitdefinitionlabelstring,\n            definitionTitleString: onexitdefinitiontitlestring,\n            emphasis: closer(),\n            hardBreakEscape: closer(onexithardbreak),\n            hardBreakTrailing: closer(onexithardbreak),\n            htmlFlow: closer(onexithtmlflow),\n            htmlFlowData: onexitdata,\n            htmlText: closer(onexithtmltext),\n            htmlTextData: onexitdata,\n            image: closer(onexitimage),\n            label: onexitlabel,\n            labelText: onexitlabeltext,\n            lineEnding: onexitlineending,\n            link: closer(onexitlink),\n            listItem: closer(),\n            listOrdered: closer(),\n            listUnordered: closer(),\n            paragraph: closer(),\n            referenceString: onexitreferencestring,\n            resourceDestinationString: onexitresourcedestinationstring,\n            resourceTitleString: onexitresourcetitlestring,\n            resource: onexitresource,\n            setextHeading: closer(onexitsetextheading),\n            setextHeadingLineSequence: onexitsetextheadinglinesequence,\n            setextHeadingText: onexitsetextheadingtext,\n            strong: closer(),\n            thematicBreak: closer()\n        }\n    };\n    configure(config, (options || {}).mdastExtensions || []);\n    /** @type {CompileData} */ const data = {};\n    return compile;\n    /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */ function compile(events) {\n        /** @type {Root} */ let tree = {\n            type: \"root\",\n            children: []\n        };\n        /** @type {Omit<CompileContext, 'sliceSerialize'>} */ const context = {\n            stack: [\n                tree\n            ],\n            tokenStack: [],\n            config,\n            enter,\n            exit,\n            buffer,\n            resume,\n            setData,\n            getData\n        };\n        /** @type {Array<number>} */ const listStack = [];\n        let index = -1;\n        while(++index < events.length){\n            // We preprocess lists to add `listItem` tokens, and to infer whether\n            // items the list itself are spread out.\n            if (events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listOrdered || events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listUnordered) {\n                if (events[index][0] === \"enter\") {\n                    listStack.push(index);\n                } else {\n                    const tail = listStack.pop();\n                    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tail === \"number\", \"expected list ot be open\");\n                    index = prepareList(events, tail, index);\n                }\n            }\n        }\n        index = -1;\n        while(++index < events.length){\n            const handler = config[events[index][0]];\n            if (own.call(handler, events[index][1].type)) {\n                handler[events[index][1].type].call(Object.assign({\n                    sliceSerialize: events[index][2].sliceSerialize\n                }, context), events[index][1]);\n            }\n        }\n        // Handle tokens still being open.\n        if (context.tokenStack.length > 0) {\n            const tail = context.tokenStack[context.tokenStack.length - 1];\n            const handler = tail[1] || defaultOnError;\n            handler.call(context, undefined, tail[0]);\n        }\n        // Figure out `root` position.\n        tree.position = {\n            start: point(events.length > 0 ? events[0][1].start : {\n                line: 1,\n                column: 1,\n                offset: 0\n            }),\n            end: point(events.length > 0 ? events[events.length - 2][1].end : {\n                line: 1,\n                column: 1,\n                offset: 0\n            })\n        };\n        // Call transforms.\n        index = -1;\n        while(++index < config.transforms.length){\n            tree = config.transforms[index](tree) || tree;\n        }\n        return tree;\n    }\n    /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */ function prepareList(events, start, length) {\n        let index = start - 1;\n        let containerBalance = -1;\n        let listSpread = false;\n        /** @type {Token | undefined} */ let listItem;\n        /** @type {number | undefined} */ let lineIndex;\n        /** @type {number | undefined} */ let firstBlankLineIndex;\n        /** @type {boolean | undefined} */ let atMarker;\n        while(++index <= length){\n            const event = events[index];\n            if (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listUnordered || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listOrdered || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuote) {\n                if (event[0] === \"enter\") {\n                    containerBalance++;\n                } else {\n                    containerBalance--;\n                }\n                atMarker = undefined;\n            } else if (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEndingBlank) {\n                if (event[0] === \"enter\") {\n                    if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n                        firstBlankLineIndex = index;\n                    }\n                    atMarker = undefined;\n                }\n            } else if (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemValue || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemMarker || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefix || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefixWhitespace) {\n            // Empty.\n            } else {\n                atMarker = undefined;\n            }\n            if (!containerBalance && event[0] === \"enter\" && event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefix || containerBalance === -1 && event[0] === \"exit\" && (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listUnordered || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listOrdered)) {\n                if (listItem) {\n                    let tailIndex = index;\n                    lineIndex = undefined;\n                    while(tailIndex--){\n                        const tailEvent = events[tailIndex];\n                        if (tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding || tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEndingBlank) {\n                            if (tailEvent[0] === \"exit\") continue;\n                            if (lineIndex) {\n                                events[lineIndex][1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEndingBlank;\n                                listSpread = true;\n                            }\n                            tailEvent[1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding;\n                            lineIndex = tailIndex;\n                        } else if (tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix || tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuotePrefix || tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuotePrefixWhitespace || tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuoteMarker || tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemIndent) {\n                        // Empty\n                        } else {\n                            break;\n                        }\n                    }\n                    if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n                        listItem._spread = true;\n                    }\n                    // Fix position.\n                    listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n                    events.splice(lineIndex || index, 0, [\n                        \"exit\",\n                        listItem,\n                        event[2]\n                    ]);\n                    index++;\n                    length++;\n                }\n                // Create a new list item.\n                if (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefix) {\n                    listItem = {\n                        type: \"listItem\",\n                        _spread: false,\n                        start: Object.assign({}, event[1].start),\n                        // @ts-expect-error: we’ll add `end` in a second.\n                        end: undefined\n                    };\n                    // @ts-expect-error: `listItem` is most definitely defined, TS...\n                    events.splice(index, 0, [\n                        \"enter\",\n                        listItem,\n                        event[2]\n                    ]);\n                    index++;\n                    length++;\n                    firstBlankLineIndex = undefined;\n                    atMarker = true;\n                }\n            }\n        }\n        events[start][1]._spread = listSpread;\n        return length;\n    }\n    /**\n   * Set data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @param {CompileData[Key]} [value]\n   *   New value.\n   * @returns {void}\n   *   Nothing.\n   */ function setData(key, value) {\n        data[key] = value;\n    }\n    /**\n   * Get data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @returns {CompileData[Key]}\n   *   Value.\n   */ function getData(key) {\n        return data[key];\n    }\n    /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Node} create\n   *   Create a node.\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */ function opener(create, and) {\n        return open;\n        /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */ function open(token) {\n            enter.call(this, create(token), token);\n            if (and) and.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @returns {void}\n   */ function buffer() {\n        this.stack.push({\n            type: \"fragment\",\n            children: []\n        });\n    }\n    /**\n   * @template {Node} Kind\n   *   Node type.\n   * @this {CompileContext}\n   *   Context.\n   * @param {Kind} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {Kind}\n   *   The given node.\n   */ function enter(node, token, errorHandler) {\n        const parent = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(parent, \"expected `parent`\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(\"children\" in parent, \"expected `parent`\");\n        // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n        parent.children.push(node);\n        this.stack.push(node);\n        this.tokenStack.push([\n            token,\n            errorHandler\n        ]);\n        // @ts-expect-error: `end` will be patched later.\n        node.position = {\n            start: point(token.start)\n        };\n        return node;\n    }\n    /**\n   * Create a closer handle.\n   *\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */ function closer(and) {\n        return close;\n        /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */ function close(token) {\n            if (and) and.call(this, token);\n            exit.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {Node}\n   *   The closed node.\n   */ function exit(token, onExitError) {\n        const node = this.stack.pop();\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected `node`\");\n        const open = this.tokenStack.pop();\n        if (!open) {\n            throw new Error(\"Cannot close `\" + token.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n                start: token.start,\n                end: token.end\n            }) + \"): it’s not open\");\n        } else if (open[0].type !== token.type) {\n            if (onExitError) {\n                onExitError.call(this, token, open[0]);\n            } else {\n                const handler = open[1] || defaultOnError;\n                handler.call(this, token, open[0]);\n            }\n        }\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type !== \"fragment\", \"unexpected fragment `exit`ed\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.position, \"expected `position` to be defined\");\n        node.position.end = point(token.end);\n        return node;\n    }\n    /**\n   * @this {CompileContext}\n   * @returns {string}\n   */ function resume() {\n        return (0,mdast_util_to_string__WEBPACK_IMPORTED_MODULE_6__.toString)(this.stack.pop());\n    }\n    //\n    // Handlers.\n    //\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterlistordered() {\n        setData(\"expectingFirstListItemValue\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterlistitemvalue(token) {\n        if (getData(\"expectingFirstListItemValue\")) {\n            const ancestor = this.stack[this.stack.length - 2];\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(ancestor, \"expected nodes on stack\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(ancestor.type === \"list\", \"expected list on stack\");\n            ancestor.start = Number.parseInt(this.sliceSerialize(token), micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseDecimal);\n            setData(\"expectingFirstListItemValue\");\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfenceinfo() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.lang = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfencemeta() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.meta = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfence() {\n        // Exit if this is the closing fence.\n        if (getData(\"flowCodeInside\")) return;\n        this.buffer();\n        setData(\"flowCodeInside\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefenced() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, \"\");\n        setData(\"flowCodeInside\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodeindented() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.value = data.replace(/(\\r?\\n|\\r)$/g, \"\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitionlabelstring(token) {\n        const label = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.label = label;\n        node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitiontitlestring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.title = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitiondestinationstring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.url = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitatxheadingsequence(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"heading\", \"expected heading on stack\");\n        if (!node.depth) {\n            const depth = this.sliceSerialize(token).length;\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6, \"expected `depth` between `1` and `6`\");\n            node.depth = depth;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheadingtext() {\n        setData(\"setextHeadingSlurpLineEnding\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheadinglinesequence(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"heading\", \"expected heading on stack\");\n        node.depth = this.sliceSerialize(token).charCodeAt(0) === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_9__.codes.equalsTo ? 1 : 2;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheading() {\n        setData(\"setextHeadingSlurpLineEnding\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterdata(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(\"children\" in node, \"expected parent on stack\");\n        let tail = node.children[node.children.length - 1];\n        if (!tail || tail.type !== \"text\") {\n            // Add a new text node.\n            tail = text();\n            // @ts-expect-error: we’ll add `end` later.\n            tail.position = {\n                start: point(token.start)\n            };\n            // @ts-expect-error: Assume `parent` accepts `text`.\n            node.children.push(tail);\n        }\n        this.stack.push(tail);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdata(token) {\n        const tail = this.stack.pop();\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail, \"expected a `node` to be on the stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(\"value\" in tail, \"expected a `literal` to be on the stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position, \"expected `node` to have an open position\");\n        tail.value += this.sliceSerialize(token);\n        tail.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlineending(token) {\n        const context = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(context, \"expected `node`\");\n        // If we’re at a hard break, include the line ending in there.\n        if (getData(\"atHardBreak\")) {\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(\"children\" in context, \"expected `parent`\");\n            const tail = context.children[context.children.length - 1];\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position, \"expected tail to have a starting position\");\n            tail.position.end = point(token.end);\n            setData(\"atHardBreak\");\n            return;\n        }\n        if (!getData(\"setextHeadingSlurpLineEnding\") && config.canContainEols.includes(context.type)) {\n            onenterdata.call(this, token);\n            onexitdata.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithardbreak() {\n        setData(\"atHardBreak\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithtmlflow() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"html\", \"expected html on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithtmltext() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"html\", \"expected html on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodetext() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"inlineCode\", \"expected inline code on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlink() {\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"link\", \"expected link on stack\");\n        // Note: there are also `identifier` and `label` fields on this link node!\n        // These are used / cleaned here.\n        // To do: clean.\n        if (getData(\"inReference\")) {\n            /** @type {ReferenceType} */ const referenceType = getData(\"referenceType\") || \"shortcut\";\n            node.type += \"Reference\";\n            // @ts-expect-error: mutate.\n            node.referenceType = referenceType;\n            // @ts-expect-error: mutate.\n            delete node.url;\n            delete node.title;\n        } else {\n            // @ts-expect-error: mutate.\n            delete node.identifier;\n            // @ts-expect-error: mutate.\n            delete node.label;\n        }\n        setData(\"referenceType\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitimage() {\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"image\", \"expected image on stack\");\n        // Note: there are also `identifier` and `label` fields on this link node!\n        // These are used / cleaned here.\n        // To do: clean.\n        if (getData(\"inReference\")) {\n            /** @type {ReferenceType} */ const referenceType = getData(\"referenceType\") || \"shortcut\";\n            node.type += \"Reference\";\n            // @ts-expect-error: mutate.\n            node.referenceType = referenceType;\n            // @ts-expect-error: mutate.\n            delete node.url;\n            delete node.title;\n        } else {\n            // @ts-expect-error: mutate.\n            delete node.identifier;\n            // @ts-expect-error: mutate.\n            delete node.label;\n        }\n        setData(\"referenceType\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlabeltext(token) {\n        const string = this.sliceSerialize(token);\n        const ancestor = this.stack[this.stack.length - 2];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(ancestor, \"expected ancestor on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(ancestor.type === \"image\" || ancestor.type === \"link\", \"expected image or link on stack\");\n        // @ts-expect-error: stash this on the node, as it might become a reference\n        // later.\n        ancestor.label = (0,micromark_util_decode_string__WEBPACK_IMPORTED_MODULE_10__.decodeString)(string);\n        // @ts-expect-error: same as above.\n        ancestor.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(string).toLowerCase();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlabel() {\n        const fragment = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(fragment, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(fragment.type === \"fragment\", \"expected fragment on stack\");\n        const value = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        // Assume a reference.\n        setData(\"inReference\", true);\n        if (node.type === \"link\") {\n            /** @type {Array<StaticPhrasingContent>} */ // @ts-expect-error: Assume static phrasing content.\n            const children = fragment.children;\n            node.children = children;\n        } else {\n            node.alt = value;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresourcedestinationstring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        node.url = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresourcetitlestring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        node.title = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresource() {\n        setData(\"inReference\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterreference() {\n        setData(\"referenceType\", \"collapsed\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitreferencestring(token) {\n        const label = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image reference or link reference on stack\");\n        // @ts-expect-error: stash this on the node, as it might become a reference\n        // later.\n        node.label = label;\n        // @ts-expect-error: same as above.\n        node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n        setData(\"referenceType\", \"full\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcharacterreferencemarker(token) {\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(token.type === \"characterReferenceMarkerNumeric\" || token.type === \"characterReferenceMarkerHexadecimal\");\n        setData(\"characterReferenceType\", token.type);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcharacterreferencevalue(token) {\n        const data = this.sliceSerialize(token);\n        const type = getData(\"characterReferenceType\");\n        /** @type {string} */ let value;\n        if (type) {\n            value = (0,micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_11__.decodeNumericCharacterReference)(data, type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReferenceMarkerNumeric ? micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseDecimal : micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseHexadecimal);\n            setData(\"characterReferenceType\");\n        } else {\n            const result = (0,decode_named_character_reference__WEBPACK_IMPORTED_MODULE_12__.decodeNamedCharacterReference)(data);\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(result !== false, \"expected reference to decode\");\n            value = result;\n        }\n        const tail = this.stack.pop();\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail, \"expected `node`\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position, \"expected `node.position`\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(\"value\" in tail, \"expected `node.value`\");\n        tail.value += value;\n        tail.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitautolinkprotocol(token) {\n        onexitdata.call(this, token);\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"link\", \"expected link on stack\");\n        node.url = this.sliceSerialize(token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitautolinkemail(token) {\n        onexitdata.call(this, token);\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"link\", \"expected link on stack\");\n        node.url = \"mailto:\" + this.sliceSerialize(token);\n    }\n    //\n    // Creaters.\n    //\n    /** @returns {Blockquote} */ function blockQuote() {\n        return {\n            type: \"blockquote\",\n            children: []\n        };\n    }\n    /** @returns {Code} */ function codeFlow() {\n        return {\n            type: \"code\",\n            lang: null,\n            meta: null,\n            value: \"\"\n        };\n    }\n    /** @returns {InlineCode} */ function codeText() {\n        return {\n            type: \"inlineCode\",\n            value: \"\"\n        };\n    }\n    /** @returns {Definition} */ function definition() {\n        return {\n            type: \"definition\",\n            identifier: \"\",\n            label: null,\n            title: null,\n            url: \"\"\n        };\n    }\n    /** @returns {Emphasis} */ function emphasis() {\n        return {\n            type: \"emphasis\",\n            children: []\n        };\n    }\n    /** @returns {Heading} */ function heading() {\n        // @ts-expect-error `depth` will be set later.\n        return {\n            type: \"heading\",\n            depth: undefined,\n            children: []\n        };\n    }\n    /** @returns {Break} */ function hardBreak() {\n        return {\n            type: \"break\"\n        };\n    }\n    /** @returns {HTML} */ function html() {\n        return {\n            type: \"html\",\n            value: \"\"\n        };\n    }\n    /** @returns {Image} */ function image() {\n        return {\n            type: \"image\",\n            title: null,\n            url: \"\",\n            alt: null\n        };\n    }\n    /** @returns {Link} */ function link() {\n        return {\n            type: \"link\",\n            title: null,\n            url: \"\",\n            children: []\n        };\n    }\n    /**\n   * @param {Token} token\n   * @returns {List}\n   */ function list(token) {\n        return {\n            type: \"list\",\n            ordered: token.type === \"listOrdered\",\n            start: null,\n            spread: token._spread,\n            children: []\n        };\n    }\n    /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */ function listItem(token) {\n        return {\n            type: \"listItem\",\n            spread: token._spread,\n            checked: null,\n            children: []\n        };\n    }\n    /** @returns {Paragraph} */ function paragraph() {\n        return {\n            type: \"paragraph\",\n            children: []\n        };\n    }\n    /** @returns {Strong} */ function strong() {\n        return {\n            type: \"strong\",\n            children: []\n        };\n    }\n    /** @returns {Text} */ function text() {\n        return {\n            type: \"text\",\n            value: \"\"\n        };\n    }\n    /** @returns {ThematicBreak} */ function thematicBreak() {\n        return {\n            type: \"thematicBreak\"\n        };\n    }\n}\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */ function point(d) {\n    return {\n        line: d.line,\n        column: d.column,\n        offset: d.offset\n    };\n}\n/**\n * @param {Config} combined\n * @param {Array<Extension | Array<Extension>>} extensions\n * @returns {void}\n */ function configure(combined, extensions) {\n    let index = -1;\n    while(++index < extensions.length){\n        const value = extensions[index];\n        if (Array.isArray(value)) {\n            configure(combined, value);\n        } else {\n            extension(combined, value);\n        }\n    }\n}\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {void}\n */ function extension(combined, extension) {\n    /** @type {keyof Extension} */ let key;\n    for(key in extension){\n        if (own.call(extension, key)) {\n            if (key === \"canContainEols\") {\n                const right = extension[key];\n                if (right) {\n                    combined[key].push(...right);\n                }\n            } else if (key === \"transforms\") {\n                const right = extension[key];\n                if (right) {\n                    combined[key].push(...right);\n                }\n            } else if (key === \"enter\" || key === \"exit\") {\n                const right = extension[key];\n                if (right) {\n                    Object.assign(combined[key], right);\n                }\n            }\n        }\n    }\n}\n/** @type {OnEnterError} */ function defaultOnError(left, right) {\n    if (left) {\n        throw new Error(\"Cannot close `\" + left.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: left.start,\n            end: left.end\n        }) + \"): a different token (`\" + right.type + \"`, \" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: right.start,\n            end: right.end\n        }) + \") is open\");\n    } else {\n        throw new Error(\"Cannot close document, a token (`\" + right.type + \"`, \" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: right.start,\n            end: right.end\n        }) + \") is still open\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duL2Rldi9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQ0MsR0FFRDs7Ozs7Q0FLQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQStDQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQStDQyxHQUVELGlEQUFpRDtBQUNqRCw2REFBNkQ7QUFDN0QsMkNBQTJDO0FBRUo7QUFDTTtBQUNEO0FBQ1U7QUFDRTtBQUN5QztBQUN4QztBQUNjO0FBQ25CO0FBQ1E7QUFDUjtBQUMwQjtBQUNmO0FBRS9ELE1BQU1jLE1BQU0sQ0FBQyxFQUFFQyxjQUFjO0FBRTdCOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1DLGVBQ1g7Ozs7O0dBS0MsR0FFQzs7Ozs7S0FLQyxHQUNELFNBQVVDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxPQUFPO0lBQ2hDLElBQUksT0FBT0QsYUFBYSxVQUFVO1FBQ2hDQyxVQUFVRDtRQUNWQSxXQUFXRTtJQUNiO0lBRUEsT0FBT0MsU0FBU0YsU0FDZGQseUVBQVdBLENBQ1RGLDZEQUFLQSxDQUFDZ0IsU0FBU0csUUFBUSxHQUFHQyxLQUFLLENBQUNuQix1RUFBVUEsR0FBR2EsT0FBT0MsVUFBVTtBQUdwRSxFQUNEO0FBRUg7Ozs7Q0FJQyxHQUNELFNBQVNHLFNBQVNGLE9BQU87SUFDdkIsbUJBQW1CLEdBQ25CLE1BQU1LLFNBQVM7UUFDYkMsWUFBWSxFQUFFO1FBQ2RDLGdCQUFnQjtZQUFDO1lBQVk7WUFBWTtZQUFXO1lBQWE7U0FBUztRQUMxRUMsT0FBTztZQUNMQyxVQUFVQyxPQUFPQztZQUNqQkMsa0JBQWtCQztZQUNsQkMsZUFBZUQ7WUFDZkUsWUFBWUwsT0FBT007WUFDbkJD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ZGFzdC11dGlsLWZyb20tbWFya2Rvd24vZGV2L2xpYi9pbmRleC5qcz9iZWI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FbmNvZGluZ30gRW5jb2RpbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlBhcnNlT3B0aW9uc30gUGFyc2VPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZUNvbnRleHR9IFRva2VuaXplQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5WYWx1ZX0gVmFsdWVcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLlBhcmVudH0gVW5pc3RQYXJlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuUG9pbnR9IFBvaW50XG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QaHJhc2luZ0NvbnRlbnR9IFBocmFzaW5nQ29udGVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5TdGF0aWNQaHJhc2luZ0NvbnRlbnR9IFN0YXRpY1BocmFzaW5nQ29udGVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5Db250ZW50fSBDb250ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkJyZWFrfSBCcmVha1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5CbG9ja3F1b3RlfSBCbG9ja3F1b3RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkNvZGV9IENvZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuRGVmaW5pdGlvbn0gRGVmaW5pdGlvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5FbXBoYXNpc30gRW1waGFzaXNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSGVhZGluZ30gSGVhZGluZ1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5IVE1MfSBIVE1MXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkltYWdlfSBJbWFnZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5JbWFnZVJlZmVyZW5jZX0gSW1hZ2VSZWZlcmVuY2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSW5saW5lQ29kZX0gSW5saW5lQ29kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5MaW5rfSBMaW5rXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkxpbmtSZWZlcmVuY2V9IExpbmtSZWZlcmVuY2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuTGlzdH0gTGlzdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5MaXN0SXRlbX0gTGlzdEl0ZW1cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuUGFyYWdyYXBofSBQYXJhZ3JhcGhcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuUm9vdH0gUm9vdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5TdHJvbmd9IFN0cm9uZ1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5UZXh0fSBUZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlRoZW1hdGljQnJlYWt9IFRoZW1hdGljQnJlYWtcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuUmVmZXJlbmNlVHlwZX0gUmVmZXJlbmNlVHlwZVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vaW5kZXguanMnKS5Db21waWxlRGF0YX0gQ29tcGlsZURhdGFcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtSb290IHwgQ29udGVudH0gTm9kZVxuICogQHR5cGVkZWYge0V4dHJhY3Q8Tm9kZSwgVW5pc3RQYXJlbnQ+fSBQYXJlbnRcbiAqXG4gKiBAdHlwZWRlZiB7T21pdDxVbmlzdFBhcmVudCwgJ3R5cGUnIHwgJ2NoaWxkcmVuJz4gJiB7dHlwZTogJ2ZyYWdtZW50JywgY2hpbGRyZW46IEFycmF5PFBocmFzaW5nQ29udGVudD59fSBGcmFnbWVudFxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFRyYW5zZm9ybVxuICogICBFeHRyYSB0cmFuc2Zvcm0sIHRvIGNoYW5nZSB0aGUgQVNUIGFmdGVyd2FyZHMuXG4gKiBAcGFyYW0ge1Jvb3R9IHRyZWVcbiAqICAgVHJlZSB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7Um9vdCB8IHVuZGVmaW5lZCB8IG51bGwgfCB2b2lkfVxuICogICBOZXcgdHJlZSBvciBub3RoaW5nIChpbiB3aGljaCBjYXNlIHRoZSBjdXJyZW50IHRyZWUgaXMgdXNlZCkuXG4gKlxuICogQGNhbGxiYWNrIEhhbmRsZVxuICogICBIYW5kbGUgYSB0b2tlbi5cbiAqIEBwYXJhbSB7Q29tcGlsZUNvbnRleHR9IHRoaXNcbiAqICAgQ29udGV4dC5cbiAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gKiAgIEN1cnJlbnQgdG9rZW4uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqICAgTm90aGluZy5cbiAqXG4gKiBAdHlwZWRlZiB7UmVjb3JkPHN0cmluZywgSGFuZGxlPn0gSGFuZGxlc1xuICogICBUb2tlbiB0eXBlcyBtYXBwaW5nIHRvIGhhbmRsZXNcbiAqXG4gKiBAY2FsbGJhY2sgT25FbnRlckVycm9yXG4gKiAgIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgYHJpZ2h0YCB0b2tlbiBpcyBvcGVuLCBidXQgaXQgaXMgY2xvc2VkIChieSB0aGVcbiAqICAgYGxlZnRgIHRva2VuKSBvciBiZWNhdXNlIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge09taXQ8Q29tcGlsZUNvbnRleHQsICdzbGljZVNlcmlhbGl6ZSc+fSB0aGlzXG4gKiAgIENvbnRleHQuXG4gKiBAcGFyYW0ge1Rva2VuIHwgdW5kZWZpbmVkfSBsZWZ0XG4gKiAgIExlZnQgdG9rZW4uXG4gKiBAcGFyYW0ge1Rva2VufSByaWdodFxuICogICBSaWdodCB0b2tlbi5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogICBOb3RoaW5nLlxuICpcbiAqIEBjYWxsYmFjayBPbkV4aXRFcnJvclxuICogICBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGByaWdodGAgdG9rZW4gaXMgb3BlbiBidXQgaXQgaXMgY2xvc2VkIGJ5XG4gKiAgIGV4aXRpbmcgdGhlIGBsZWZ0YCB0b2tlbi5cbiAqIEBwYXJhbSB7T21pdDxDb21waWxlQ29udGV4dCwgJ3NsaWNlU2VyaWFsaXplJz59IHRoaXNcbiAqICAgQ29udGV4dC5cbiAqIEBwYXJhbSB7VG9rZW59IGxlZnRcbiAqICAgTGVmdCB0b2tlbi5cbiAqIEBwYXJhbSB7VG9rZW59IHJpZ2h0XG4gKiAgIFJpZ2h0IHRva2VuLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiAgIE5vdGhpbmcuXG4gKlxuICogQHR5cGVkZWYge1tUb2tlbiwgT25FbnRlckVycm9yIHwgdW5kZWZpbmVkXX0gVG9rZW5UdXBsZVxuICogICBPcGVuIHRva2VuIG9uIHRoZSBzdGFjaywgd2l0aCBhbiBvcHRpb25hbCBlcnJvciBoYW5kbGVyIGZvciB3aGVuXG4gKiAgIHRoYXQgdG9rZW4gaXNu4oCZdCBjbG9zZWQgcHJvcGVybHkuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBDb25maWdcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqXG4gKiAgIFdlIGhhdmUgb3VyIGRlZmF1bHRzLCBidXQgZXh0ZW5zaW9ucyB3aWxsIGFkZCBtb3JlLlxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBjYW5Db250YWluRW9sc1xuICogICBUb2tlbiB0eXBlcyB3aGVyZSBsaW5lIGVuZGluZ3MgYXJlIHVzZWQuXG4gKiBAcHJvcGVydHkge0hhbmRsZXN9IGVudGVyXG4gKiAgIE9wZW5pbmcgaGFuZGxlcy5cbiAqIEBwcm9wZXJ0eSB7SGFuZGxlc30gZXhpdFxuICogICBDbG9zaW5nIGhhbmRsZXMuXG4gKiBAcHJvcGVydHkge0FycmF5PFRyYW5zZm9ybT59IHRyYW5zZm9ybXNcbiAqICAgVHJlZSB0cmFuc2Zvcm1zLlxuICpcbiAqIEB0eXBlZGVmIHtQYXJ0aWFsPENvbmZpZz59IEV4dGVuc2lvblxuICogICBDaGFuZ2UgaG93IG1hcmtkb3duIHRva2VucyBmcm9tIG1pY3JvbWFyayBhcmUgdHVybmVkIGludG8gbWRhc3QuXG4gKlxuICogQHR5cGVkZWYgQ29tcGlsZUNvbnRleHRcbiAqICAgbWRhc3QgY29tcGlsZXIgY29udGV4dC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8Tm9kZSB8IEZyYWdtZW50Pn0gc3RhY2tcbiAqICAgU3RhY2sgb2Ygbm9kZXMuXG4gKiBAcHJvcGVydHkge0FycmF5PFRva2VuVHVwbGU+fSB0b2tlblN0YWNrXG4gKiAgIFN0YWNrIG9mIHRva2Vucy5cbiAqIEBwcm9wZXJ0eSB7PEtleSBleHRlbmRzIGtleW9mIENvbXBpbGVEYXRhPihrZXk6IEtleSkgPT4gQ29tcGlsZURhdGFbS2V5XX0gZ2V0RGF0YVxuICogICBHZXQgZGF0YSBmcm9tIHRoZSBrZXkvdmFsdWUgc3RvcmUuXG4gKiBAcHJvcGVydHkgezxLZXkgZXh0ZW5kcyBrZXlvZiBDb21waWxlRGF0YT4oa2V5OiBLZXksIHZhbHVlPzogQ29tcGlsZURhdGFbS2V5XSkgPT4gdm9pZH0gc2V0RGF0YVxuICogICBTZXQgZGF0YSBpbnRvIHRoZSBrZXkvdmFsdWUgc3RvcmUuXG4gKiBAcHJvcGVydHkgeyh0aGlzOiBDb21waWxlQ29udGV4dCkgPT4gdm9pZH0gYnVmZmVyXG4gKiAgIENhcHR1cmUgc29tZSBvZiB0aGUgb3V0cHV0IGRhdGEuXG4gKiBAcHJvcGVydHkgeyh0aGlzOiBDb21waWxlQ29udGV4dCkgPT4gc3RyaW5nfSByZXN1bWVcbiAqICAgU3RvcCBjYXB0dXJpbmcgYW5kIGFjY2VzcyB0aGUgb3V0cHV0IGRhdGEuXG4gKiBAcHJvcGVydHkgezxLaW5kIGV4dGVuZHMgTm9kZT4odGhpczogQ29tcGlsZUNvbnRleHQsIG5vZGU6IEtpbmQsIHRva2VuOiBUb2tlbiwgb25FcnJvcj86IE9uRW50ZXJFcnJvcikgPT4gS2luZH0gZW50ZXJcbiAqICAgRW50ZXIgYSB0b2tlbi5cbiAqIEBwcm9wZXJ0eSB7KHRoaXM6IENvbXBpbGVDb250ZXh0LCB0b2tlbjogVG9rZW4sIG9uRXJyb3I/OiBPbkV4aXRFcnJvcikgPT4gTm9kZX0gZXhpdFxuICogICBFeGl0IGEgdG9rZW4uXG4gKiBAcHJvcGVydHkge1Rva2VuaXplQ29udGV4dFsnc2xpY2VTZXJpYWxpemUnXX0gc2xpY2VTZXJpYWxpemVcbiAqICAgR2V0IHRoZSBzdHJpbmcgdmFsdWUgb2YgYSB0b2tlbi5cbiAqIEBwcm9wZXJ0eSB7Q29uZmlnfSBjb25maWdcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqXG4gKiBAdHlwZWRlZiBGcm9tTWFya2Rvd25PcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24gZm9yIGhvdyB0byBidWlsZCBtZGFzdC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8RXh0ZW5zaW9uIHwgQXJyYXk8RXh0ZW5zaW9uPj4gfCBudWxsIHwgdW5kZWZpbmVkfSBbbWRhc3RFeHRlbnNpb25zXVxuICogICBFeHRlbnNpb25zIGZvciB0aGlzIHV0aWxpdHkgdG8gY2hhbmdlIGhvdyB0b2tlbnMgYXJlIHR1cm5lZCBpbnRvIGEgdHJlZS5cbiAqXG4gKiBAdHlwZWRlZiB7UGFyc2VPcHRpb25zICYgRnJvbU1hcmtkb3duT3B0aW9uc30gT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uLlxuICovXG5cbi8vIFRvIGRvOiBtaWNyb21hcms6IGNyZWF0ZSBhIHJlZ2lzdHJ5IG9mIHRva2Vucz9cbi8vIFRvIGRvOiBuZXh0IG1ham9yOiBkb27igJl0IHJldHVybiBnaXZlbiBgTm9kZWAgZnJvbSBgZW50ZXJgLlxuLy8gVG8gZG86IG5leHQgbWFqb3I6IHJlbW92ZSBzZXR0ZXIvZ2V0dGVyLlxuXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAndXZ1L2Fzc2VydCdcbmltcG9ydCB7dG9TdHJpbmd9IGZyb20gJ21kYXN0LXV0aWwtdG8tc3RyaW5nJ1xuaW1wb3J0IHtwYXJzZX0gZnJvbSAnbWljcm9tYXJrL2xpYi9wYXJzZS5qcydcbmltcG9ydCB7cHJlcHJvY2Vzc30gZnJvbSAnbWljcm9tYXJrL2xpYi9wcmVwcm9jZXNzLmpzJ1xuaW1wb3J0IHtwb3N0cHJvY2Vzc30gZnJvbSAnbWljcm9tYXJrL2xpYi9wb3N0cHJvY2Vzcy5qcydcbmltcG9ydCB7ZGVjb2RlTnVtZXJpY0NoYXJhY3RlclJlZmVyZW5jZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtZGVjb2RlLW51bWVyaWMtY2hhcmFjdGVyLXJlZmVyZW5jZSdcbmltcG9ydCB7ZGVjb2RlU3RyaW5nfSBmcm9tICdtaWNyb21hcmstdXRpbC1kZWNvZGUtc3RyaW5nJ1xuaW1wb3J0IHtub3JtYWxpemVJZGVudGlmaWVyfSBmcm9tICdtaWNyb21hcmstdXRpbC1ub3JtYWxpemUtaWRlbnRpZmllcidcbmltcG9ydCB7Y29kZXN9IGZyb20gJ21pY3JvbWFyay11dGlsLXN5bWJvbC9jb2Rlcy5qcydcbmltcG9ydCB7Y29uc3RhbnRzfSBmcm9tICdtaWNyb21hcmstdXRpbC1zeW1ib2wvY29uc3RhbnRzLmpzJ1xuaW1wb3J0IHt0eXBlc30gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3ltYm9sL3R5cGVzLmpzJ1xuaW1wb3J0IHtkZWNvZGVOYW1lZENoYXJhY3RlclJlZmVyZW5jZX0gZnJvbSAnZGVjb2RlLW5hbWVkLWNoYXJhY3Rlci1yZWZlcmVuY2UnXG5pbXBvcnQge3N0cmluZ2lmeVBvc2l0aW9ufSBmcm9tICd1bmlzdC11dGlsLXN0cmluZ2lmeS1wb3NpdGlvbidcblxuY29uc3Qgb3duID0ge30uaGFzT3duUHJvcGVydHlcblxuLyoqXG4gKiBAcGFyYW0gdmFsdWVcbiAqICAgTWFya2Rvd24gdG8gcGFyc2UuXG4gKiBAcGFyYW0gZW5jb2RpbmdcbiAqICAgQ2hhcmFjdGVyIGVuY29kaW5nIGZvciB3aGVuIGB2YWx1ZWAgaXMgYEJ1ZmZlcmAuXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uLlxuICogQHJldHVybnNcbiAqICAgbWRhc3QgdHJlZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21NYXJrZG93biA9XG4gIC8qKlxuICAgKiBAdHlwZSB7KFxuICAgKiAgICgodmFsdWU6IFZhbHVlLCBlbmNvZGluZzogRW5jb2RpbmcsIG9wdGlvbnM/OiBPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gUm9vdCkgJlxuICAgKiAgICgodmFsdWU6IFZhbHVlLCBvcHRpb25zPzogT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFJvb3QpXG4gICAqICl9XG4gICAqL1xuICAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtWYWx1ZX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0VuY29kaW5nIHwgT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtlbmNvZGluZ11cbiAgICAgKiBAcGFyYW0ge09wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJucyB7Um9vdH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nLCBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zID0gZW5jb2RpbmdcbiAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbXBpbGVyKG9wdGlvbnMpKFxuICAgICAgICBwb3N0cHJvY2VzcyhcbiAgICAgICAgICBwYXJzZShvcHRpb25zKS5kb2N1bWVudCgpLndyaXRlKHByZXByb2Nlc3MoKSh2YWx1ZSwgZW5jb2RpbmcsIHRydWUpKVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICApXG5cbi8qKlxuICogTm90ZSB0aGlzIGNvbXBpbGVyIG9ubHkgdW5kZXJzdGFuZCBjb21wbGV0ZSBidWZmZXJpbmcsIG5vdCBzdHJlYW1pbmcuXG4gKlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVyKG9wdGlvbnMpIHtcbiAgLyoqIEB0eXBlIHtDb25maWd9ICovXG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICB0cmFuc2Zvcm1zOiBbXSxcbiAgICBjYW5Db250YWluRW9sczogWydlbXBoYXNpcycsICdmcmFnbWVudCcsICdoZWFkaW5nJywgJ3BhcmFncmFwaCcsICdzdHJvbmcnXSxcbiAgICBlbnRlcjoge1xuICAgICAgYXV0b2xpbms6IG9wZW5lcihsaW5rKSxcbiAgICAgIGF1dG9saW5rUHJvdG9jb2w6IG9uZW50ZXJkYXRhLFxuICAgICAgYXV0b2xpbmtFbWFpbDogb25lbnRlcmRhdGEsXG4gICAgICBhdHhIZWFkaW5nOiBvcGVuZXIoaGVhZGluZyksXG4gICAgICBibG9ja1F1b3RlOiBvcGVuZXIoYmxvY2tRdW90ZSksXG4gICAgICBjaGFyYWN0ZXJFc2NhcGU6IG9uZW50ZXJkYXRhLFxuICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlOiBvbmVudGVyZGF0YSxcbiAgICAgIGNvZGVGZW5jZWQ6IG9wZW5lcihjb2RlRmxvdyksXG4gICAgICBjb2RlRmVuY2VkRmVuY2VJbmZvOiBidWZmZXIsXG4gICAgICBjb2RlRmVuY2VkRmVuY2VNZXRhOiBidWZmZXIsXG4gICAgICBjb2RlSW5kZW50ZWQ6IG9wZW5lcihjb2RlRmxvdywgYnVmZmVyKSxcbiAgICAgIGNvZGVUZXh0OiBvcGVuZXIoY29kZVRleHQsIGJ1ZmZlciksXG4gICAgICBjb2RlVGV4dERhdGE6IG9uZW50ZXJkYXRhLFxuICAgICAgZGF0YTogb25lbnRlcmRhdGEsXG4gICAgICBjb2RlRmxvd1ZhbHVlOiBvbmVudGVyZGF0YSxcbiAgICAgIGRlZmluaXRpb246IG9wZW5lcihkZWZpbml0aW9uKSxcbiAgICAgIGRlZmluaXRpb25EZXN0aW5hdGlvblN0cmluZzogYnVmZmVyLFxuICAgICAgZGVmaW5pdGlvbkxhYmVsU3RyaW5nOiBidWZmZXIsXG4gICAgICBkZWZpbml0aW9uVGl0bGVTdHJpbmc6IGJ1ZmZlcixcbiAgICAgIGVtcGhhc2lzOiBvcGVuZXIoZW1waGFzaXMpLFxuICAgICAgaGFyZEJyZWFrRXNjYXBlOiBvcGVuZXIoaGFyZEJyZWFrKSxcbiAgICAgIGhhcmRCcmVha1RyYWlsaW5nOiBvcGVuZXIoaGFyZEJyZWFrKSxcbiAgICAgIGh0bWxGbG93OiBvcGVuZXIoaHRtbCwgYnVmZmVyKSxcbiAgICAgIGh0bWxGbG93RGF0YTogb25lbnRlcmRhdGEsXG4gICAgICBodG1sVGV4dDogb3BlbmVyKGh0bWwsIGJ1ZmZlciksXG4gICAgICBodG1sVGV4dERhdGE6IG9uZW50ZXJkYXRhLFxuICAgICAgaW1hZ2U6IG9wZW5lcihpbWFnZSksXG4gICAgICBsYWJlbDogYnVmZmVyLFxuICAgICAgbGluazogb3BlbmVyKGxpbmspLFxuICAgICAgbGlzdEl0ZW06IG9wZW5lcihsaXN0SXRlbSksXG4gICAgICBsaXN0SXRlbVZhbHVlOiBvbmVudGVybGlzdGl0ZW12YWx1ZSxcbiAgICAgIGxpc3RPcmRlcmVkOiBvcGVuZXIobGlzdCwgb25lbnRlcmxpc3RvcmRlcmVkKSxcbiAgICAgIGxpc3RVbm9yZGVyZWQ6IG9wZW5lcihsaXN0KSxcbiAgICAgIHBhcmFncmFwaDogb3BlbmVyKHBhcmFncmFwaCksXG4gICAgICByZWZlcmVuY2U6IG9uZW50ZXJyZWZlcmVuY2UsXG4gICAgICByZWZlcmVuY2VTdHJpbmc6IGJ1ZmZlcixcbiAgICAgIHJlc291cmNlRGVzdGluYXRpb25TdHJpbmc6IGJ1ZmZlcixcbiAgICAgIHJlc291cmNlVGl0bGVTdHJpbmc6IGJ1ZmZlcixcbiAgICAgIHNldGV4dEhlYWRpbmc6IG9wZW5lcihoZWFkaW5nKSxcbiAgICAgIHN0cm9uZzogb3BlbmVyKHN0cm9uZyksXG4gICAgICB0aGVtYXRpY0JyZWFrOiBvcGVuZXIodGhlbWF0aWNCcmVhaylcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIGF0eEhlYWRpbmc6IGNsb3NlcigpLFxuICAgICAgYXR4SGVhZGluZ1NlcXVlbmNlOiBvbmV4aXRhdHhoZWFkaW5nc2VxdWVuY2UsXG4gICAgICBhdXRvbGluazogY2xvc2VyKCksXG4gICAgICBhdXRvbGlua0VtYWlsOiBvbmV4aXRhdXRvbGlua2VtYWlsLFxuICAgICAgYXV0b2xpbmtQcm90b2NvbDogb25leGl0YXV0b2xpbmtwcm90b2NvbCxcbiAgICAgIGJsb2NrUXVvdGU6IGNsb3NlcigpLFxuICAgICAgY2hhcmFjdGVyRXNjYXBlVmFsdWU6IG9uZXhpdGRhdGEsXG4gICAgICBjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJIZXhhZGVjaW1hbDogb25leGl0Y2hhcmFjdGVycmVmZXJlbmNlbWFya2VyLFxuICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyTnVtZXJpYzogb25leGl0Y2hhcmFjdGVycmVmZXJlbmNlbWFya2VyLFxuICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlVmFsdWU6IG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZXZhbHVlLFxuICAgICAgY29kZUZlbmNlZDogY2xvc2VyKG9uZXhpdGNvZGVmZW5jZWQpLFxuICAgICAgY29kZUZlbmNlZEZlbmNlOiBvbmV4aXRjb2RlZmVuY2VkZmVuY2UsXG4gICAgICBjb2RlRmVuY2VkRmVuY2VJbmZvOiBvbmV4aXRjb2RlZmVuY2VkZmVuY2VpbmZvLFxuICAgICAgY29kZUZlbmNlZEZlbmNlTWV0YTogb25leGl0Y29kZWZlbmNlZGZlbmNlbWV0YSxcbiAgICAgIGNvZGVGbG93VmFsdWU6IG9uZXhpdGRhdGEsXG4gICAgICBjb2RlSW5kZW50ZWQ6IGNsb3NlcihvbmV4aXRjb2RlaW5kZW50ZWQpLFxuICAgICAgY29kZVRleHQ6IGNsb3NlcihvbmV4aXRjb2RldGV4dCksXG4gICAgICBjb2RlVGV4dERhdGE6IG9uZXhpdGRhdGEsXG4gICAgICBkYXRhOiBvbmV4aXRkYXRhLFxuICAgICAgZGVmaW5pdGlvbjogY2xvc2VyKCksXG4gICAgICBkZWZpbml0aW9uRGVzdGluYXRpb25TdHJpbmc6IG9uZXhpdGRlZmluaXRpb25kZXN0aW5hdGlvbnN0cmluZyxcbiAgICAgIGRlZmluaXRpb25MYWJlbFN0cmluZzogb25leGl0ZGVmaW5pdGlvbmxhYmVsc3RyaW5nLFxuICAgICAgZGVmaW5pdGlvblRpdGxlU3RyaW5nOiBvbmV4aXRkZWZpbml0aW9udGl0bGVzdHJpbmcsXG4gICAgICBlbXBoYXNpczogY2xvc2VyKCksXG4gICAgICBoYXJkQnJlYWtFc2NhcGU6IGNsb3NlcihvbmV4aXRoYXJkYnJlYWspLFxuICAgICAgaGFyZEJyZWFrVHJhaWxpbmc6IGNsb3NlcihvbmV4aXRoYXJkYnJlYWspLFxuICAgICAgaHRtbEZsb3c6IGNsb3NlcihvbmV4aXRodG1sZmxvdyksXG4gICAgICBodG1sRmxvd0RhdGE6IG9uZXhpdGRhdGEsXG4gICAgICBodG1sVGV4dDogY2xvc2VyKG9uZXhpdGh0bWx0ZXh0KSxcbiAgICAgIGh0bWxUZXh0RGF0YTogb25leGl0ZGF0YSxcbiAgICAgIGltYWdlOiBjbG9zZXIob25leGl0aW1hZ2UpLFxuICAgICAgbGFiZWw6IG9uZXhpdGxhYmVsLFxuICAgICAgbGFiZWxUZXh0OiBvbmV4aXRsYWJlbHRleHQsXG4gICAgICBsaW5lRW5kaW5nOiBvbmV4aXRsaW5lZW5kaW5nLFxuICAgICAgbGluazogY2xvc2VyKG9uZXhpdGxpbmspLFxuICAgICAgbGlzdEl0ZW06IGNsb3NlcigpLFxuICAgICAgbGlzdE9yZGVyZWQ6IGNsb3NlcigpLFxuICAgICAgbGlzdFVub3JkZXJlZDogY2xvc2VyKCksXG4gICAgICBwYXJhZ3JhcGg6IGNsb3NlcigpLFxuICAgICAgcmVmZXJlbmNlU3RyaW5nOiBvbmV4aXRyZWZlcmVuY2VzdHJpbmcsXG4gICAgICByZXNvdXJjZURlc3RpbmF0aW9uU3RyaW5nOiBvbmV4aXRyZXNvdXJjZWRlc3RpbmF0aW9uc3RyaW5nLFxuICAgICAgcmVzb3VyY2VUaXRsZVN0cmluZzogb25leGl0cmVzb3VyY2V0aXRsZXN0cmluZyxcbiAgICAgIHJlc291cmNlOiBvbmV4aXRyZXNvdXJjZSxcbiAgICAgIHNldGV4dEhlYWRpbmc6IGNsb3NlcihvbmV4aXRzZXRleHRoZWFkaW5nKSxcbiAgICAgIHNldGV4dEhlYWRpbmdMaW5lU2VxdWVuY2U6IG9uZXhpdHNldGV4dGhlYWRpbmdsaW5lc2VxdWVuY2UsXG4gICAgICBzZXRleHRIZWFkaW5nVGV4dDogb25leGl0c2V0ZXh0aGVhZGluZ3RleHQsXG4gICAgICBzdHJvbmc6IGNsb3NlcigpLFxuICAgICAgdGhlbWF0aWNCcmVhazogY2xvc2VyKClcbiAgICB9XG4gIH1cblxuICBjb25maWd1cmUoY29uZmlnLCAob3B0aW9ucyB8fCB7fSkubWRhc3RFeHRlbnNpb25zIHx8IFtdKVxuXG4gIC8qKiBAdHlwZSB7Q29tcGlsZURhdGF9ICovXG4gIGNvbnN0IGRhdGEgPSB7fVxuXG4gIHJldHVybiBjb21waWxlXG5cbiAgLyoqXG4gICAqIFR1cm4gbWljcm9tYXJrIGV2ZW50cyBpbnRvIGFuIG1kYXN0IHRyZWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBldmVudHNcbiAgICogICBFdmVudHMuXG4gICAqIEByZXR1cm5zIHtSb290fVxuICAgKiAgIG1kYXN0IHRyZWUuXG4gICAqL1xuICBmdW5jdGlvbiBjb21waWxlKGV2ZW50cykge1xuICAgIC8qKiBAdHlwZSB7Um9vdH0gKi9cbiAgICBsZXQgdHJlZSA9IHt0eXBlOiAncm9vdCcsIGNoaWxkcmVuOiBbXX1cbiAgICAvKiogQHR5cGUge09taXQ8Q29tcGlsZUNvbnRleHQsICdzbGljZVNlcmlhbGl6ZSc+fSAqL1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBzdGFjazogW3RyZWVdLFxuICAgICAgdG9rZW5TdGFjazogW10sXG4gICAgICBjb25maWcsXG4gICAgICBlbnRlcixcbiAgICAgIGV4aXQsXG4gICAgICBidWZmZXIsXG4gICAgICByZXN1bWUsXG4gICAgICBzZXREYXRhLFxuICAgICAgZ2V0RGF0YVxuICAgIH1cbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3QgbGlzdFN0YWNrID0gW11cbiAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBXZSBwcmVwcm9jZXNzIGxpc3RzIHRvIGFkZCBgbGlzdEl0ZW1gIHRva2VucywgYW5kIHRvIGluZmVyIHdoZXRoZXJcbiAgICAgIC8vIGl0ZW1zIHRoZSBsaXN0IGl0c2VsZiBhcmUgc3ByZWFkIG91dC5cbiAgICAgIGlmIChcbiAgICAgICAgZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSB0eXBlcy5saXN0T3JkZXJlZCB8fFxuICAgICAgICBldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09IHR5cGVzLmxpc3RVbm9yZGVyZWRcbiAgICAgICkge1xuICAgICAgICBpZiAoZXZlbnRzW2luZGV4XVswXSA9PT0gJ2VudGVyJykge1xuICAgICAgICAgIGxpc3RTdGFjay5wdXNoKGluZGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRhaWwgPSBsaXN0U3RhY2sucG9wKClcbiAgICAgICAgICBhc3NlcnQodHlwZW9mIHRhaWwgPT09ICdudW1iZXInLCAnZXhwZWN0ZWQgbGlzdCBvdCBiZSBvcGVuJylcbiAgICAgICAgICBpbmRleCA9IHByZXBhcmVMaXN0KGV2ZW50cywgdGFpbCwgaW5kZXgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleCA9IC0xXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBjb25maWdbZXZlbnRzW2luZGV4XVswXV1cblxuICAgICAgaWYgKG93bi5jYWxsKGhhbmRsZXIsIGV2ZW50c1tpbmRleF1bMV0udHlwZSkpIHtcbiAgICAgICAgaGFuZGxlcltldmVudHNbaW5kZXhdWzFdLnR5cGVdLmNhbGwoXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHtzbGljZVNlcmlhbGl6ZTogZXZlbnRzW2luZGV4XVsyXS5zbGljZVNlcmlhbGl6ZX0sXG4gICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgKSxcbiAgICAgICAgICBldmVudHNbaW5kZXhdWzFdXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdG9rZW5zIHN0aWxsIGJlaW5nIG9wZW4uXG4gICAgaWYgKGNvbnRleHQudG9rZW5TdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB0YWlsID0gY29udGV4dC50b2tlblN0YWNrW2NvbnRleHQudG9rZW5TdGFjay5sZW5ndGggLSAxXVxuICAgICAgY29uc3QgaGFuZGxlciA9IHRhaWxbMV0gfHwgZGVmYXVsdE9uRXJyb3JcbiAgICAgIGhhbmRsZXIuY2FsbChjb250ZXh0LCB1bmRlZmluZWQsIHRhaWxbMF0pXG4gICAgfVxuXG4gICAgLy8gRmlndXJlIG91dCBgcm9vdGAgcG9zaXRpb24uXG4gICAgdHJlZS5wb3NpdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBwb2ludChcbiAgICAgICAgZXZlbnRzLmxlbmd0aCA+IDAgPyBldmVudHNbMF1bMV0uc3RhcnQgOiB7bGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDB9XG4gICAgICApLFxuICAgICAgZW5kOiBwb2ludChcbiAgICAgICAgZXZlbnRzLmxlbmd0aCA+IDBcbiAgICAgICAgICA/IGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMl1bMV0uZW5kXG4gICAgICAgICAgOiB7bGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDB9XG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gQ2FsbCB0cmFuc2Zvcm1zLlxuICAgIGluZGV4ID0gLTFcbiAgICB3aGlsZSAoKytpbmRleCA8IGNvbmZpZy50cmFuc2Zvcm1zLmxlbmd0aCkge1xuICAgICAgdHJlZSA9IGNvbmZpZy50cmFuc2Zvcm1zW2luZGV4XSh0cmVlKSB8fCB0cmVlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gZXZlbnRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBwcmVwYXJlTGlzdChldmVudHMsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgICBsZXQgaW5kZXggPSBzdGFydCAtIDFcbiAgICBsZXQgY29udGFpbmVyQmFsYW5jZSA9IC0xXG4gICAgbGV0IGxpc3RTcHJlYWQgPSBmYWxzZVxuICAgIC8qKiBAdHlwZSB7VG9rZW4gfCB1bmRlZmluZWR9ICovXG4gICAgbGV0IGxpc3RJdGVtXG4gICAgLyoqIEB0eXBlIHtudW1iZXIgfCB1bmRlZmluZWR9ICovXG4gICAgbGV0IGxpbmVJbmRleFxuICAgIC8qKiBAdHlwZSB7bnVtYmVyIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBmaXJzdEJsYW5rTGluZUluZGV4XG4gICAgLyoqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBhdE1hcmtlclxuXG4gICAgd2hpbGUgKCsraW5kZXggPD0gbGVuZ3RoKSB7XG4gICAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpbmRleF1cblxuICAgICAgaWYgKFxuICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0VW5vcmRlcmVkIHx8XG4gICAgICAgIGV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpc3RPcmRlcmVkIHx8XG4gICAgICAgIGV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmJsb2NrUXVvdGVcbiAgICAgICkge1xuICAgICAgICBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgICAgICBjb250YWluZXJCYWxhbmNlKytcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250YWluZXJCYWxhbmNlLS1cbiAgICAgICAgfVxuXG4gICAgICAgIGF0TWFya2VyID0gdW5kZWZpbmVkXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpbmVFbmRpbmdCbGFuaykge1xuICAgICAgICBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBsaXN0SXRlbSAmJlxuICAgICAgICAgICAgIWF0TWFya2VyICYmXG4gICAgICAgICAgICAhY29udGFpbmVyQmFsYW5jZSAmJlxuICAgICAgICAgICAgIWZpcnN0QmxhbmtMaW5lSW5kZXhcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGZpcnN0QmxhbmtMaW5lSW5kZXggPSBpbmRleFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGF0TWFya2VyID0gdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpbmVQcmVmaXggfHxcbiAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdEl0ZW1WYWx1ZSB8fFxuICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0SXRlbU1hcmtlciB8fFxuICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0SXRlbVByZWZpeCB8fFxuICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0SXRlbVByZWZpeFdoaXRlc3BhY2VcbiAgICAgICkge1xuICAgICAgICAvLyBFbXB0eS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0TWFya2VyID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgKCFjb250YWluZXJCYWxhbmNlICYmXG4gICAgICAgICAgZXZlbnRbMF0gPT09ICdlbnRlcicgJiZcbiAgICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0SXRlbVByZWZpeCkgfHxcbiAgICAgICAgKGNvbnRhaW5lckJhbGFuY2UgPT09IC0xICYmXG4gICAgICAgICAgZXZlbnRbMF0gPT09ICdleGl0JyAmJlxuICAgICAgICAgIChldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0VW5vcmRlcmVkIHx8XG4gICAgICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0T3JkZXJlZCkpXG4gICAgICApIHtcbiAgICAgICAgaWYgKGxpc3RJdGVtKSB7XG4gICAgICAgICAgbGV0IHRhaWxJbmRleCA9IGluZGV4XG4gICAgICAgICAgbGluZUluZGV4ID0gdW5kZWZpbmVkXG5cbiAgICAgICAgICB3aGlsZSAodGFpbEluZGV4LS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRhaWxFdmVudCA9IGV2ZW50c1t0YWlsSW5kZXhdXG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpbmVFbmRpbmcgfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpbmVFbmRpbmdCbGFua1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICh0YWlsRXZlbnRbMF0gPT09ICdleGl0JykgY29udGludWVcblxuICAgICAgICAgICAgICBpZiAobGluZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzW2xpbmVJbmRleF1bMV0udHlwZSA9IHR5cGVzLmxpbmVFbmRpbmdCbGFua1xuICAgICAgICAgICAgICAgIGxpc3RTcHJlYWQgPSB0cnVlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9IHR5cGVzLmxpbmVFbmRpbmdcbiAgICAgICAgICAgICAgbGluZUluZGV4ID0gdGFpbEluZGV4XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGluZVByZWZpeCB8fFxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9PT0gdHlwZXMuYmxvY2tRdW90ZVByZWZpeCB8fFxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9PT0gdHlwZXMuYmxvY2tRdW90ZVByZWZpeFdoaXRlc3BhY2UgfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmJsb2NrUXVvdGVNYXJrZXIgfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpc3RJdGVtSW5kZW50XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gRW1wdHlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZmlyc3RCbGFua0xpbmVJbmRleCAmJlxuICAgICAgICAgICAgKCFsaW5lSW5kZXggfHwgZmlyc3RCbGFua0xpbmVJbmRleCA8IGxpbmVJbmRleClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGxpc3RJdGVtLl9zcHJlYWQgPSB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRml4IHBvc2l0aW9uLlxuICAgICAgICAgIGxpc3RJdGVtLmVuZCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGxpbmVJbmRleCA/IGV2ZW50c1tsaW5lSW5kZXhdWzFdLnN0YXJ0IDogZXZlbnRbMV0uZW5kXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgZXZlbnRzLnNwbGljZShsaW5lSW5kZXggfHwgaW5kZXgsIDAsIFsnZXhpdCcsIGxpc3RJdGVtLCBldmVudFsyXV0pXG4gICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgIGxlbmd0aCsrXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgbGlzdCBpdGVtLlxuICAgICAgICBpZiAoZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdEl0ZW1QcmVmaXgpIHtcbiAgICAgICAgICBsaXN0SXRlbSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdsaXN0SXRlbScsXG4gICAgICAgICAgICBfc3ByZWFkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBldmVudFsxXS5zdGFydCksXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZeKAmWxsIGFkZCBgZW5kYCBpbiBhIHNlY29uZC5cbiAgICAgICAgICAgIGVuZDogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBsaXN0SXRlbWAgaXMgbW9zdCBkZWZpbml0ZWx5IGRlZmluZWQsIFRTLi4uXG4gICAgICAgICAgZXZlbnRzLnNwbGljZShpbmRleCwgMCwgWydlbnRlcicsIGxpc3RJdGVtLCBldmVudFsyXV0pXG4gICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgIGxlbmd0aCsrXG4gICAgICAgICAgZmlyc3RCbGFua0xpbmVJbmRleCA9IHVuZGVmaW5lZFxuICAgICAgICAgIGF0TWFya2VyID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXZlbnRzW3N0YXJ0XVsxXS5fc3ByZWFkID0gbGlzdFNwcmVhZFxuICAgIHJldHVybiBsZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZGF0YS5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBDb21waWxlRGF0YX0gS2V5XG4gICAqICAgRmllbGQgdHlwZS5cbiAgICogQHBhcmFtIHtLZXl9IGtleVxuICAgKiAgIEtleSBvZiBmaWVsZC5cbiAgICogQHBhcmFtIHtDb21waWxlRGF0YVtLZXldfSBbdmFsdWVdXG4gICAqICAgTmV3IHZhbHVlLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogICBOb3RoaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0RGF0YShrZXksIHZhbHVlKSB7XG4gICAgZGF0YVtrZXldID0gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGF0YS5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBDb21waWxlRGF0YX0gS2V5XG4gICAqICAgRmllbGQgdHlwZS5cbiAgICogQHBhcmFtIHtLZXl9IGtleVxuICAgKiAgIEtleSBvZiBmaWVsZC5cbiAgICogQHJldHVybnMge0NvbXBpbGVEYXRhW0tleV19XG4gICAqICAgVmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXREYXRhKGtleSkge1xuICAgIHJldHVybiBkYXRhW2tleV1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gb3BlbmVyIGhhbmRsZS5cbiAgICpcbiAgICogQHBhcmFtIHsodG9rZW46IFRva2VuKSA9PiBOb2RlfSBjcmVhdGVcbiAgICogICBDcmVhdGUgYSBub2RlLlxuICAgKiBAcGFyYW0ge0hhbmRsZX0gW2FuZF1cbiAgICogICBPcHRpb25hbCBmdW5jdGlvbiB0byBhbHNvIHJ1bi5cbiAgICogQHJldHVybnMge0hhbmRsZX1cbiAgICogICBIYW5kbGUuXG4gICAqL1xuICBmdW5jdGlvbiBvcGVuZXIoY3JlYXRlLCBhbmQpIHtcbiAgICByZXR1cm4gb3BlblxuXG4gICAgLyoqXG4gICAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb3Blbih0b2tlbikge1xuICAgICAgZW50ZXIuY2FsbCh0aGlzLCBjcmVhdGUodG9rZW4pLCB0b2tlbilcbiAgICAgIGlmIChhbmQpIGFuZC5jYWxsKHRoaXMsIHRva2VuKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gYnVmZmVyKCkge1xuICAgIHRoaXMuc3RhY2sucHVzaCh7dHlwZTogJ2ZyYWdtZW50JywgY2hpbGRyZW46IFtdfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUge05vZGV9IEtpbmRcbiAgICogICBOb2RlIHR5cGUuXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogICBDb250ZXh0LlxuICAgKiBAcGFyYW0ge0tpbmR9IG5vZGVcbiAgICogICBOb2RlIHRvIGVudGVyLlxuICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgKiAgIENvcnJlc3BvbmRpbmcgdG9rZW4uXG4gICAqIEBwYXJhbSB7T25FbnRlckVycm9yIHwgdW5kZWZpbmVkfSBbZXJyb3JIYW5kbGVyXVxuICAgKiAgIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGlzIHRva2VuIGlzIG9wZW4sIGJ1dCBpdCBpcyBjbG9zZWQgYnkgc29tZXRoaW5nIGVsc2UuXG4gICAqIEByZXR1cm5zIHtLaW5kfVxuICAgKiAgIFRoZSBnaXZlbiBub2RlLlxuICAgKi9cbiAgZnVuY3Rpb24gZW50ZXIobm9kZSwgdG9rZW4sIGVycm9ySGFuZGxlcikge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChwYXJlbnQsICdleHBlY3RlZCBgcGFyZW50YCcpXG4gICAgYXNzZXJ0KCdjaGlsZHJlbicgaW4gcGFyZW50LCAnZXhwZWN0ZWQgYHBhcmVudGAnKVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEFzc3VtZSBgTm9kZWAgY2FuIGV4aXN0IGFzIGEgY2hpbGQgb2YgYHBhcmVudGAuXG4gICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSlcbiAgICB0aGlzLnN0YWNrLnB1c2gobm9kZSlcbiAgICB0aGlzLnRva2VuU3RhY2sucHVzaChbdG9rZW4sIGVycm9ySGFuZGxlcl0pXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYGVuZGAgd2lsbCBiZSBwYXRjaGVkIGxhdGVyLlxuICAgIG5vZGUucG9zaXRpb24gPSB7c3RhcnQ6IHBvaW50KHRva2VuLnN0YXJ0KX1cbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNsb3NlciBoYW5kbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7SGFuZGxlfSBbYW5kXVxuICAgKiAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFsc28gcnVuLlxuICAgKiBAcmV0dXJucyB7SGFuZGxlfVxuICAgKiAgIEhhbmRsZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNsb3NlcihhbmQpIHtcbiAgICByZXR1cm4gY2xvc2VcblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb3NlKHRva2VuKSB7XG4gICAgICBpZiAoYW5kKSBhbmQuY2FsbCh0aGlzLCB0b2tlbilcbiAgICAgIGV4aXQuY2FsbCh0aGlzLCB0b2tlbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiAgIENvbnRleHQuXG4gICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAqICAgQ29ycmVzcG9uZGluZyB0b2tlbi5cbiAgICogQHBhcmFtIHtPbkV4aXRFcnJvciB8IHVuZGVmaW5lZH0gW29uRXhpdEVycm9yXVxuICAgKiAgIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhbm90aGVyIHRva2VuIGlzIG9wZW4uXG4gICAqIEByZXR1cm5zIHtOb2RlfVxuICAgKiAgIFRoZSBjbG9zZWQgbm9kZS5cbiAgICovXG4gIGZ1bmN0aW9uIGV4aXQodG9rZW4sIG9uRXhpdEVycm9yKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2sucG9wKClcbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIGBub2RlYCcpXG4gICAgY29uc3Qgb3BlbiA9IHRoaXMudG9rZW5TdGFjay5wb3AoKVxuXG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3QgY2xvc2UgYCcgK1xuICAgICAgICAgIHRva2VuLnR5cGUgK1xuICAgICAgICAgICdgICgnICtcbiAgICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbih7c3RhcnQ6IHRva2VuLnN0YXJ0LCBlbmQ6IHRva2VuLmVuZH0pICtcbiAgICAgICAgICAnKTogaXTigJlzIG5vdCBvcGVuJ1xuICAgICAgKVxuICAgIH0gZWxzZSBpZiAob3BlblswXS50eXBlICE9PSB0b2tlbi50eXBlKSB7XG4gICAgICBpZiAob25FeGl0RXJyb3IpIHtcbiAgICAgICAgb25FeGl0RXJyb3IuY2FsbCh0aGlzLCB0b2tlbiwgb3BlblswXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBvcGVuWzFdIHx8IGRlZmF1bHRPbkVycm9yXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCB0b2tlbiwgb3BlblswXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3NlcnQobm9kZS50eXBlICE9PSAnZnJhZ21lbnQnLCAndW5leHBlY3RlZCBmcmFnbWVudCBgZXhpdGBlZCcpXG4gICAgYXNzZXJ0KG5vZGUucG9zaXRpb24sICdleHBlY3RlZCBgcG9zaXRpb25gIHRvIGJlIGRlZmluZWQnKVxuICAgIG5vZGUucG9zaXRpb24uZW5kID0gcG9pbnQodG9rZW4uZW5kKVxuICAgIHJldHVybiBub2RlXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIHJldHVybiB0b1N0cmluZyh0aGlzLnN0YWNrLnBvcCgpKVxuICB9XG5cbiAgLy9cbiAgLy8gSGFuZGxlcnMuXG4gIC8vXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJsaXN0b3JkZXJlZCgpIHtcbiAgICBzZXREYXRhKCdleHBlY3RpbmdGaXJzdExpc3RJdGVtVmFsdWUnLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJsaXN0aXRlbXZhbHVlKHRva2VuKSB7XG4gICAgaWYgKGdldERhdGEoJ2V4cGVjdGluZ0ZpcnN0TGlzdEl0ZW1WYWx1ZScpKSB7XG4gICAgICBjb25zdCBhbmNlc3RvciA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXVxuICAgICAgYXNzZXJ0KGFuY2VzdG9yLCAnZXhwZWN0ZWQgbm9kZXMgb24gc3RhY2snKVxuICAgICAgYXNzZXJ0KGFuY2VzdG9yLnR5cGUgPT09ICdsaXN0JywgJ2V4cGVjdGVkIGxpc3Qgb24gc3RhY2snKVxuICAgICAgYW5jZXN0b3Iuc3RhcnQgPSBOdW1iZXIucGFyc2VJbnQoXG4gICAgICAgIHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pLFxuICAgICAgICBjb25zdGFudHMubnVtZXJpY0Jhc2VEZWNpbWFsXG4gICAgICApXG4gICAgICBzZXREYXRhKCdleHBlY3RpbmdGaXJzdExpc3RJdGVtVmFsdWUnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjb2RlZmVuY2VkZmVuY2VpbmZvKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2NvZGUnLCAnZXhwZWN0ZWQgY29kZSBvbiBzdGFjaycpXG4gICAgbm9kZS5sYW5nID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGNvZGVmZW5jZWRmZW5jZW1ldGEoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnY29kZScsICdleHBlY3RlZCBjb2RlIG9uIHN0YWNrJylcbiAgICBub2RlLm1ldGEgPSBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y29kZWZlbmNlZGZlbmNlKCkge1xuICAgIC8vIEV4aXQgaWYgdGhpcyBpcyB0aGUgY2xvc2luZyBmZW5jZS5cbiAgICBpZiAoZ2V0RGF0YSgnZmxvd0NvZGVJbnNpZGUnKSkgcmV0dXJuXG4gICAgdGhpcy5idWZmZXIoKVxuICAgIHNldERhdGEoJ2Zsb3dDb2RlSW5zaWRlJywgdHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjb2RlZmVuY2VkKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2NvZGUnLCAnZXhwZWN0ZWQgY29kZSBvbiBzdGFjaycpXG5cbiAgICBub2RlLnZhbHVlID0gZGF0YS5yZXBsYWNlKC9eKFxccj9cXG58XFxyKXwoXFxyP1xcbnxcXHIpJC9nLCAnJylcbiAgICBzZXREYXRhKCdmbG93Q29kZUluc2lkZScpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y29kZWluZGVudGVkKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2NvZGUnLCAnZXhwZWN0ZWQgY29kZSBvbiBzdGFjaycpXG5cbiAgICBub2RlLnZhbHVlID0gZGF0YS5yZXBsYWNlKC8oXFxyP1xcbnxcXHIpJC9nLCAnJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRkZWZpbml0aW9ubGFiZWxzdHJpbmcodG9rZW4pIHtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnZGVmaW5pdGlvbicsICdleHBlY3RlZCBkZWZpbml0aW9uIG9uIHN0YWNrJylcblxuICAgIG5vZGUubGFiZWwgPSBsYWJlbFxuICAgIG5vZGUuaWRlbnRpZmllciA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoXG4gICAgICB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgICkudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGRlZmluaXRpb250aXRsZXN0cmluZygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdkZWZpbml0aW9uJywgJ2V4cGVjdGVkIGRlZmluaXRpb24gb24gc3RhY2snKVxuXG4gICAgbm9kZS50aXRsZSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRkZWZpbml0aW9uZGVzdGluYXRpb25zdHJpbmcoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnZGVmaW5pdGlvbicsICdleHBlY3RlZCBkZWZpbml0aW9uIG9uIHN0YWNrJylcblxuICAgIG5vZGUudXJsID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGF0eGhlYWRpbmdzZXF1ZW5jZSh0b2tlbikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdoZWFkaW5nJywgJ2V4cGVjdGVkIGhlYWRpbmcgb24gc3RhY2snKVxuXG4gICAgaWYgKCFub2RlLmRlcHRoKSB7XG4gICAgICBjb25zdCBkZXB0aCA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pLmxlbmd0aFxuXG4gICAgICBhc3NlcnQoXG4gICAgICAgIGRlcHRoID09PSAxIHx8XG4gICAgICAgICAgZGVwdGggPT09IDIgfHxcbiAgICAgICAgICBkZXB0aCA9PT0gMyB8fFxuICAgICAgICAgIGRlcHRoID09PSA0IHx8XG4gICAgICAgICAgZGVwdGggPT09IDUgfHxcbiAgICAgICAgICBkZXB0aCA9PT0gNixcbiAgICAgICAgJ2V4cGVjdGVkIGBkZXB0aGAgYmV0d2VlbiBgMWAgYW5kIGA2YCdcbiAgICAgIClcblxuICAgICAgbm9kZS5kZXB0aCA9IGRlcHRoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdHNldGV4dGhlYWRpbmd0ZXh0KCkge1xuICAgIHNldERhdGEoJ3NldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmcnLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdHNldGV4dGhlYWRpbmdsaW5lc2VxdWVuY2UodG9rZW4pIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnaGVhZGluZycsICdleHBlY3RlZCBoZWFkaW5nIG9uIHN0YWNrJylcblxuICAgIG5vZGUuZGVwdGggPVxuICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbikuY2hhckNvZGVBdCgwKSA9PT0gY29kZXMuZXF1YWxzVG8gPyAxIDogMlxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdHNldGV4dGhlYWRpbmcoKSB7XG4gICAgc2V0RGF0YSgnc2V0ZXh0SGVhZGluZ1NsdXJwTGluZUVuZGluZycpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmVudGVyZGF0YSh0b2tlbikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydCgnY2hpbGRyZW4nIGluIG5vZGUsICdleHBlY3RlZCBwYXJlbnQgb24gc3RhY2snKVxuXG4gICAgbGV0IHRhaWwgPSBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV1cblxuICAgIGlmICghdGFpbCB8fCB0YWlsLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgLy8gQWRkIGEgbmV3IHRleHQgbm9kZS5cbiAgICAgIHRhaWwgPSB0ZXh0KClcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdl4oCZbGwgYWRkIGBlbmRgIGxhdGVyLlxuICAgICAgdGFpbC5wb3NpdGlvbiA9IHtzdGFydDogcG9pbnQodG9rZW4uc3RhcnQpfVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogQXNzdW1lIGBwYXJlbnRgIGFjY2VwdHMgYHRleHRgLlxuICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHRhaWwpXG4gICAgfVxuXG4gICAgdGhpcy5zdGFjay5wdXNoKHRhaWwpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRkYXRhKHRva2VuKSB7XG4gICAgY29uc3QgdGFpbCA9IHRoaXMuc3RhY2sucG9wKClcbiAgICBhc3NlcnQodGFpbCwgJ2V4cGVjdGVkIGEgYG5vZGVgIHRvIGJlIG9uIHRoZSBzdGFjaycpXG4gICAgYXNzZXJ0KCd2YWx1ZScgaW4gdGFpbCwgJ2V4cGVjdGVkIGEgYGxpdGVyYWxgIHRvIGJlIG9uIHRoZSBzdGFjaycpXG4gICAgYXNzZXJ0KHRhaWwucG9zaXRpb24sICdleHBlY3RlZCBgbm9kZWAgdG8gaGF2ZSBhbiBvcGVuIHBvc2l0aW9uJylcbiAgICB0YWlsLnZhbHVlICs9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gICAgdGFpbC5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRsaW5lZW5kaW5nKHRva2VuKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChjb250ZXh0LCAnZXhwZWN0ZWQgYG5vZGVgJylcblxuICAgIC8vIElmIHdl4oCZcmUgYXQgYSBoYXJkIGJyZWFrLCBpbmNsdWRlIHRoZSBsaW5lIGVuZGluZyBpbiB0aGVyZS5cbiAgICBpZiAoZ2V0RGF0YSgnYXRIYXJkQnJlYWsnKSkge1xuICAgICAgYXNzZXJ0KCdjaGlsZHJlbicgaW4gY29udGV4dCwgJ2V4cGVjdGVkIGBwYXJlbnRgJylcbiAgICAgIGNvbnN0IHRhaWwgPSBjb250ZXh0LmNoaWxkcmVuW2NvbnRleHQuY2hpbGRyZW4ubGVuZ3RoIC0gMV1cbiAgICAgIGFzc2VydCh0YWlsLnBvc2l0aW9uLCAnZXhwZWN0ZWQgdGFpbCB0byBoYXZlIGEgc3RhcnRpbmcgcG9zaXRpb24nKVxuICAgICAgdGFpbC5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gICAgICBzZXREYXRhKCdhdEhhcmRCcmVhaycpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhZ2V0RGF0YSgnc2V0ZXh0SGVhZGluZ1NsdXJwTGluZUVuZGluZycpICYmXG4gICAgICBjb25maWcuY2FuQ29udGFpbkVvbHMuaW5jbHVkZXMoY29udGV4dC50eXBlKVxuICAgICkge1xuICAgICAgb25lbnRlcmRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICAgIG9uZXhpdGRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRoYXJkYnJlYWsoKSB7XG4gICAgc2V0RGF0YSgnYXRIYXJkQnJlYWsnLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0aHRtbGZsb3coKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnaHRtbCcsICdleHBlY3RlZCBodG1sIG9uIHN0YWNrJylcblxuICAgIG5vZGUudmFsdWUgPSBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRodG1sdGV4dCgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdodG1sJywgJ2V4cGVjdGVkIGh0bWwgb24gc3RhY2snKVxuXG4gICAgbm9kZS52YWx1ZSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGNvZGV0ZXh0KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2lubGluZUNvZGUnLCAnZXhwZWN0ZWQgaW5saW5lIGNvZGUgb24gc3RhY2snKVxuXG4gICAgbm9kZS52YWx1ZSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGxpbmsoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2xpbmsnLCAnZXhwZWN0ZWQgbGluayBvbiBzdGFjaycpXG5cbiAgICAvLyBOb3RlOiB0aGVyZSBhcmUgYWxzbyBgaWRlbnRpZmllcmAgYW5kIGBsYWJlbGAgZmllbGRzIG9uIHRoaXMgbGluayBub2RlIVxuICAgIC8vIFRoZXNlIGFyZSB1c2VkIC8gY2xlYW5lZCBoZXJlLlxuXG4gICAgLy8gVG8gZG86IGNsZWFuLlxuICAgIGlmIChnZXREYXRhKCdpblJlZmVyZW5jZScpKSB7XG4gICAgICAvKiogQHR5cGUge1JlZmVyZW5jZVR5cGV9ICovXG4gICAgICBjb25zdCByZWZlcmVuY2VUeXBlID0gZ2V0RGF0YSgncmVmZXJlbmNlVHlwZScpIHx8ICdzaG9ydGN1dCdcblxuICAgICAgbm9kZS50eXBlICs9ICdSZWZlcmVuY2UnXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBub2RlLnJlZmVyZW5jZVR5cGUgPSByZWZlcmVuY2VUeXBlXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS51cmxcbiAgICAgIGRlbGV0ZSBub2RlLnRpdGxlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cbiAgICAgIGRlbGV0ZSBub2RlLmlkZW50aWZpZXJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cbiAgICAgIGRlbGV0ZSBub2RlLmxhYmVsXG4gICAgfVxuXG4gICAgc2V0RGF0YSgncmVmZXJlbmNlVHlwZScpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRpbWFnZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnaW1hZ2UnLCAnZXhwZWN0ZWQgaW1hZ2Ugb24gc3RhY2snKVxuXG4gICAgLy8gTm90ZTogdGhlcmUgYXJlIGFsc28gYGlkZW50aWZpZXJgIGFuZCBgbGFiZWxgIGZpZWxkcyBvbiB0aGlzIGxpbmsgbm9kZSFcbiAgICAvLyBUaGVzZSBhcmUgdXNlZCAvIGNsZWFuZWQgaGVyZS5cblxuICAgIC8vIFRvIGRvOiBjbGVhbi5cbiAgICBpZiAoZ2V0RGF0YSgnaW5SZWZlcmVuY2UnKSkge1xuICAgICAgLyoqIEB0eXBlIHtSZWZlcmVuY2VUeXBlfSAqL1xuICAgICAgY29uc3QgcmVmZXJlbmNlVHlwZSA9IGdldERhdGEoJ3JlZmVyZW5jZVR5cGUnKSB8fCAnc2hvcnRjdXQnXG5cbiAgICAgIG5vZGUudHlwZSArPSAnUmVmZXJlbmNlJ1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgbm9kZS5yZWZlcmVuY2VUeXBlID0gcmVmZXJlbmNlVHlwZVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgZGVsZXRlIG5vZGUudXJsXG4gICAgICBkZWxldGUgbm9kZS50aXRsZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS5pZGVudGlmaWVyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS5sYWJlbFxuICAgIH1cblxuICAgIHNldERhdGEoJ3JlZmVyZW5jZVR5cGUnKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0bGFiZWx0ZXh0KHRva2VuKSB7XG4gICAgY29uc3Qgc3RyaW5nID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICBjb25zdCBhbmNlc3RvciA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXVxuICAgIGFzc2VydChhbmNlc3RvciwgJ2V4cGVjdGVkIGFuY2VzdG9yIG9uIHN0YWNrJylcbiAgICBhc3NlcnQoXG4gICAgICBhbmNlc3Rvci50eXBlID09PSAnaW1hZ2UnIHx8IGFuY2VzdG9yLnR5cGUgPT09ICdsaW5rJyxcbiAgICAgICdleHBlY3RlZCBpbWFnZSBvciBsaW5rIG9uIHN0YWNrJ1xuICAgIClcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHN0YXNoIHRoaXMgb24gdGhlIG5vZGUsIGFzIGl0IG1pZ2h0IGJlY29tZSBhIHJlZmVyZW5jZVxuICAgIC8vIGxhdGVyLlxuICAgIGFuY2VzdG9yLmxhYmVsID0gZGVjb2RlU3RyaW5nKHN0cmluZylcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBzYW1lIGFzIGFib3ZlLlxuICAgIGFuY2VzdG9yLmlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKHN0cmluZykudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0bGFiZWwoKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQoZnJhZ21lbnQsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQoZnJhZ21lbnQudHlwZSA9PT0gJ2ZyYWdtZW50JywgJ2V4cGVjdGVkIGZyYWdtZW50IG9uIHN0YWNrJylcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQoXG4gICAgICBub2RlLnR5cGUgPT09ICdpbWFnZScgfHwgbm9kZS50eXBlID09PSAnbGluaycsXG4gICAgICAnZXhwZWN0ZWQgaW1hZ2Ugb3IgbGluayBvbiBzdGFjaydcbiAgICApXG5cbiAgICAvLyBBc3N1bWUgYSByZWZlcmVuY2UuXG4gICAgc2V0RGF0YSgnaW5SZWZlcmVuY2UnLCB0cnVlKVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PFN0YXRpY1BocmFzaW5nQ29udGVudD59ICovXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBBc3N1bWUgc3RhdGljIHBocmFzaW5nIGNvbnRlbnQuXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGZyYWdtZW50LmNoaWxkcmVuXG5cbiAgICAgIG5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmFsdCA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0cmVzb3VyY2VkZXN0aW5hdGlvbnN0cmluZygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChcbiAgICAgIG5vZGUudHlwZSA9PT0gJ2ltYWdlJyB8fCBub2RlLnR5cGUgPT09ICdsaW5rJyxcbiAgICAgICdleHBlY3RlZCBpbWFnZSBvciBsaW5rIG9uIHN0YWNrJ1xuICAgIClcbiAgICBub2RlLnVybCA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdHJlc291cmNldGl0bGVzdHJpbmcoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQoXG4gICAgICBub2RlLnR5cGUgPT09ICdpbWFnZScgfHwgbm9kZS50eXBlID09PSAnbGluaycsXG4gICAgICAnZXhwZWN0ZWQgaW1hZ2Ugb3IgbGluayBvbiBzdGFjaydcbiAgICApXG4gICAgbm9kZS50aXRsZSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdHJlc291cmNlKCkge1xuICAgIHNldERhdGEoJ2luUmVmZXJlbmNlJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZW50ZXJyZWZlcmVuY2UoKSB7XG4gICAgc2V0RGF0YSgncmVmZXJlbmNlVHlwZScsICdjb2xsYXBzZWQnKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0cmVmZXJlbmNlc3RyaW5nKHRva2VuKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KFxuICAgICAgbm9kZS50eXBlID09PSAnaW1hZ2UnIHx8IG5vZGUudHlwZSA9PT0gJ2xpbmsnLFxuICAgICAgJ2V4cGVjdGVkIGltYWdlIHJlZmVyZW5jZSBvciBsaW5rIHJlZmVyZW5jZSBvbiBzdGFjaydcbiAgICApXG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBzdGFzaCB0aGlzIG9uIHRoZSBub2RlLCBhcyBpdCBtaWdodCBiZWNvbWUgYSByZWZlcmVuY2VcbiAgICAvLyBsYXRlci5cbiAgICBub2RlLmxhYmVsID0gbGFiZWxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBzYW1lIGFzIGFib3ZlLlxuICAgIG5vZGUuaWRlbnRpZmllciA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoXG4gICAgICB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgICkudG9Mb3dlckNhc2UoKVxuICAgIHNldERhdGEoJ3JlZmVyZW5jZVR5cGUnLCAnZnVsbCcpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2VtYXJrZXIodG9rZW4pIHtcbiAgICBhc3NlcnQoXG4gICAgICB0b2tlbi50eXBlID09PSAnY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyTnVtZXJpYycgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ2NoYXJhY3RlclJlZmVyZW5jZU1hcmtlckhleGFkZWNpbWFsJ1xuICAgIClcbiAgICBzZXREYXRhKCdjaGFyYWN0ZXJSZWZlcmVuY2VUeXBlJywgdG9rZW4udHlwZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2V2YWx1ZSh0b2tlbikge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgIGNvbnN0IHR5cGUgPSBnZXREYXRhKCdjaGFyYWN0ZXJSZWZlcmVuY2VUeXBlJylcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBsZXQgdmFsdWVcblxuICAgIGlmICh0eXBlKSB7XG4gICAgICB2YWx1ZSA9IGRlY29kZU51bWVyaWNDaGFyYWN0ZXJSZWZlcmVuY2UoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHR5cGUgPT09IHR5cGVzLmNoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWNcbiAgICAgICAgICA/IGNvbnN0YW50cy5udW1lcmljQmFzZURlY2ltYWxcbiAgICAgICAgICA6IGNvbnN0YW50cy5udW1lcmljQmFzZUhleGFkZWNpbWFsXG4gICAgICApXG4gICAgICBzZXREYXRhKCdjaGFyYWN0ZXJSZWZlcmVuY2VUeXBlJylcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2UoZGF0YSlcbiAgICAgIGFzc2VydChyZXN1bHQgIT09IGZhbHNlLCAnZXhwZWN0ZWQgcmVmZXJlbmNlIHRvIGRlY29kZScpXG4gICAgICB2YWx1ZSA9IHJlc3VsdFxuICAgIH1cblxuICAgIGNvbnN0IHRhaWwgPSB0aGlzLnN0YWNrLnBvcCgpXG4gICAgYXNzZXJ0KHRhaWwsICdleHBlY3RlZCBgbm9kZWAnKVxuICAgIGFzc2VydCh0YWlsLnBvc2l0aW9uLCAnZXhwZWN0ZWQgYG5vZGUucG9zaXRpb25gJylcbiAgICBhc3NlcnQoJ3ZhbHVlJyBpbiB0YWlsLCAnZXhwZWN0ZWQgYG5vZGUudmFsdWVgJylcbiAgICB0YWlsLnZhbHVlICs9IHZhbHVlXG4gICAgdGFpbC5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0YXV0b2xpbmtwcm90b2NvbCh0b2tlbikge1xuICAgIG9uZXhpdGRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnbGluaycsICdleHBlY3RlZCBsaW5rIG9uIHN0YWNrJylcblxuICAgIG5vZGUudXJsID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRhdXRvbGlua2VtYWlsKHRva2VuKSB7XG4gICAgb25leGl0ZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdsaW5rJywgJ2V4cGVjdGVkIGxpbmsgb24gc3RhY2snKVxuXG4gICAgbm9kZS51cmwgPSAnbWFpbHRvOicgKyB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICB9XG5cbiAgLy9cbiAgLy8gQ3JlYXRlcnMuXG4gIC8vXG5cbiAgLyoqIEByZXR1cm5zIHtCbG9ja3F1b3RlfSAqL1xuICBmdW5jdGlvbiBibG9ja1F1b3RlKCkge1xuICAgIHJldHVybiB7dHlwZTogJ2Jsb2NrcXVvdGUnLCBjaGlsZHJlbjogW119XG4gIH1cblxuICAvKiogQHJldHVybnMge0NvZGV9ICovXG4gIGZ1bmN0aW9uIGNvZGVGbG93KCkge1xuICAgIHJldHVybiB7dHlwZTogJ2NvZGUnLCBsYW5nOiBudWxsLCBtZXRhOiBudWxsLCB2YWx1ZTogJyd9XG4gIH1cblxuICAvKiogQHJldHVybnMge0lubGluZUNvZGV9ICovXG4gIGZ1bmN0aW9uIGNvZGVUZXh0KCkge1xuICAgIHJldHVybiB7dHlwZTogJ2lubGluZUNvZGUnLCB2YWx1ZTogJyd9XG4gIH1cblxuICAvKiogQHJldHVybnMge0RlZmluaXRpb259ICovXG4gIGZ1bmN0aW9uIGRlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdkZWZpbml0aW9uJyxcbiAgICAgIGlkZW50aWZpZXI6ICcnLFxuICAgICAgbGFiZWw6IG51bGwsXG4gICAgICB0aXRsZTogbnVsbCxcbiAgICAgIHVybDogJydcbiAgICB9XG4gIH1cblxuICAvKiogQHJldHVybnMge0VtcGhhc2lzfSAqL1xuICBmdW5jdGlvbiBlbXBoYXNpcygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdlbXBoYXNpcycsIGNoaWxkcmVuOiBbXX1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7SGVhZGluZ30gKi9cbiAgZnVuY3Rpb24gaGVhZGluZygpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBkZXB0aGAgd2lsbCBiZSBzZXQgbGF0ZXIuXG4gICAgcmV0dXJuIHt0eXBlOiAnaGVhZGluZycsIGRlcHRoOiB1bmRlZmluZWQsIGNoaWxkcmVuOiBbXX1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7QnJlYWt9ICovXG4gIGZ1bmN0aW9uIGhhcmRCcmVhaygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdicmVhayd9XG4gIH1cblxuICAvKiogQHJldHVybnMge0hUTUx9ICovXG4gIGZ1bmN0aW9uIGh0bWwoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnaHRtbCcsIHZhbHVlOiAnJ31cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7SW1hZ2V9ICovXG4gIGZ1bmN0aW9uIGltYWdlKCkge1xuICAgIHJldHVybiB7dHlwZTogJ2ltYWdlJywgdGl0bGU6IG51bGwsIHVybDogJycsIGFsdDogbnVsbH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7TGlua30gKi9cbiAgZnVuY3Rpb24gbGluaygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdsaW5rJywgdGl0bGU6IG51bGwsIHVybDogJycsIGNoaWxkcmVuOiBbXX1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgKiBAcmV0dXJucyB7TGlzdH1cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3QodG9rZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgb3JkZXJlZDogdG9rZW4udHlwZSA9PT0gJ2xpc3RPcmRlcmVkJyxcbiAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgc3ByZWFkOiB0b2tlbi5fc3ByZWFkLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAqIEByZXR1cm5zIHtMaXN0SXRlbX1cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RJdGVtKHRva2VuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdsaXN0SXRlbScsXG4gICAgICBzcHJlYWQ6IHRva2VuLl9zcHJlYWQsXG4gICAgICBjaGVja2VkOiBudWxsLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtQYXJhZ3JhcGh9ICovXG4gIGZ1bmN0aW9uIHBhcmFncmFwaCgpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdwYXJhZ3JhcGgnLCBjaGlsZHJlbjogW119XG4gIH1cblxuICAvKiogQHJldHVybnMge1N0cm9uZ30gKi9cbiAgZnVuY3Rpb24gc3Ryb25nKCkge1xuICAgIHJldHVybiB7dHlwZTogJ3N0cm9uZycsIGNoaWxkcmVuOiBbXX1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7VGV4dH0gKi9cbiAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICByZXR1cm4ge3R5cGU6ICd0ZXh0JywgdmFsdWU6ICcnfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtUaGVtYXRpY0JyZWFrfSAqL1xuICBmdW5jdGlvbiB0aGVtYXRpY0JyZWFrKCkge1xuICAgIHJldHVybiB7dHlwZTogJ3RoZW1hdGljQnJlYWsnfVxuICB9XG59XG5cbi8qKlxuICogQ29weSBhIHBvaW50LWxpa2UgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtQb2ludH0gZFxuICogICBQb2ludC1saWtlIHZhbHVlLlxuICogQHJldHVybnMge1BvaW50fVxuICogICB1bmlzdCBwb2ludC5cbiAqL1xuZnVuY3Rpb24gcG9pbnQoZCkge1xuICByZXR1cm4ge2xpbmU6IGQubGluZSwgY29sdW1uOiBkLmNvbHVtbiwgb2Zmc2V0OiBkLm9mZnNldH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbmZpZ30gY29tYmluZWRcbiAqIEBwYXJhbSB7QXJyYXk8RXh0ZW5zaW9uIHwgQXJyYXk8RXh0ZW5zaW9uPj59IGV4dGVuc2lvbnNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoY29tYmluZWQsIGV4dGVuc2lvbnMpIHtcbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IGV4dGVuc2lvbnMubGVuZ3RoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb25zW2luZGV4XVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBjb25maWd1cmUoY29tYmluZWQsIHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBleHRlbnNpb24oY29tYmluZWQsIHZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29uZmlnfSBjb21iaW5lZFxuICogQHBhcmFtIHtFeHRlbnNpb259IGV4dGVuc2lvblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGV4dGVuc2lvbihjb21iaW5lZCwgZXh0ZW5zaW9uKSB7XG4gIC8qKiBAdHlwZSB7a2V5b2YgRXh0ZW5zaW9ufSAqL1xuICBsZXQga2V5XG5cbiAgZm9yIChrZXkgaW4gZXh0ZW5zaW9uKSB7XG4gICAgaWYgKG93bi5jYWxsKGV4dGVuc2lvbiwga2V5KSkge1xuICAgICAgaWYgKGtleSA9PT0gJ2NhbkNvbnRhaW5Fb2xzJykge1xuICAgICAgICBjb25zdCByaWdodCA9IGV4dGVuc2lvbltrZXldXG4gICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgIGNvbWJpbmVkW2tleV0ucHVzaCguLi5yaWdodClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICd0cmFuc2Zvcm1zJykge1xuICAgICAgICBjb25zdCByaWdodCA9IGV4dGVuc2lvbltrZXldXG4gICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgIGNvbWJpbmVkW2tleV0ucHVzaCguLi5yaWdodClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdlbnRlcicgfHwga2V5ID09PSAnZXhpdCcpIHtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBleHRlbnNpb25ba2V5XVxuICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGNvbWJpbmVkW2tleV0sIHJpZ2h0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKiBAdHlwZSB7T25FbnRlckVycm9yfSAqL1xuZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3IobGVmdCwgcmlnaHQpIHtcbiAgaWYgKGxlZnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQ2Fubm90IGNsb3NlIGAnICtcbiAgICAgICAgbGVmdC50eXBlICtcbiAgICAgICAgJ2AgKCcgK1xuICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbih7c3RhcnQ6IGxlZnQuc3RhcnQsIGVuZDogbGVmdC5lbmR9KSArXG4gICAgICAgICcpOiBhIGRpZmZlcmVudCB0b2tlbiAoYCcgK1xuICAgICAgICByaWdodC50eXBlICtcbiAgICAgICAgJ2AsICcgK1xuICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbih7c3RhcnQ6IHJpZ2h0LnN0YXJ0LCBlbmQ6IHJpZ2h0LmVuZH0pICtcbiAgICAgICAgJykgaXMgb3BlbidcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0Nhbm5vdCBjbG9zZSBkb2N1bWVudCwgYSB0b2tlbiAoYCcgK1xuICAgICAgICByaWdodC50eXBlICtcbiAgICAgICAgJ2AsICcgK1xuICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbih7c3RhcnQ6IHJpZ2h0LnN0YXJ0LCBlbmQ6IHJpZ2h0LmVuZH0pICtcbiAgICAgICAgJykgaXMgc3RpbGwgb3BlbidcbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJvayIsImFzc2VydCIsInRvU3RyaW5nIiwicGFyc2UiLCJwcmVwcm9jZXNzIiwicG9zdHByb2Nlc3MiLCJkZWNvZGVOdW1lcmljQ2hhcmFjdGVyUmVmZXJlbmNlIiwiZGVjb2RlU3RyaW5nIiwibm9ybWFsaXplSWRlbnRpZmllciIsImNvZGVzIiwiY29uc3RhbnRzIiwidHlwZXMiLCJkZWNvZGVOYW1lZENoYXJhY3RlclJlZmVyZW5jZSIsInN0cmluZ2lmeVBvc2l0aW9uIiwib3duIiwiaGFzT3duUHJvcGVydHkiLCJmcm9tTWFya2Rvd24iLCJ2YWx1ZSIsImVuY29kaW5nIiwib3B0aW9ucyIsInVuZGVmaW5lZCIsImNvbXBpbGVyIiwiZG9jdW1lbnQiLCJ3cml0ZSIsImNvbmZpZyIsInRyYW5zZm9ybXMiLCJjYW5Db250YWluRW9scyIsImVudGVyIiwiYXV0b2xpbmsiLCJvcGVuZXIiLCJsaW5rIiwiYXV0b2xpbmtQcm90b2NvbCIsIm9uZW50ZXJkYXRhIiwiYXV0b2xpbmtFbWFpbCIsImF0eEhlYWRpbmciLCJoZWFkaW5nIiwiYmxvY2tRdW90ZSIsImNoYXJhY3RlckVzY2FwZSIsImNoYXJhY3RlclJlZmVyZW5jZSIsImNvZGVGZW5jZWQiLCJjb2RlRmxvdyIsImNvZGVGZW5jZWRGZW5jZUluZm8iLCJidWZmZXIiLCJjb2RlRmVuY2VkRmVuY2VNZXRhIiwiY29kZUluZGVudGVkIiwiY29kZVRleHQiLCJjb2RlVGV4dERhdGEiLCJkYXRhIiwiY29kZUZsb3dWYWx1ZSIsImRlZmluaXRpb24iLCJkZWZpbml0aW9uRGVzdGluYXRpb25TdHJpbmciLCJkZWZpbml0aW9uTGFiZWxTdHJpbmciLCJkZWZpbml0aW9uVGl0bGVTdHJpbmciLCJlbXBoYXNpcyIsImhhcmRCcmVha0VzY2FwZSIsImhhcmRCcmVhayIsImhhcmRCcmVha1RyYWlsaW5nIiwiaHRtbEZsb3ciLCJodG1sIiwiaHRtbEZsb3dEYXRhIiwiaHRtbFRleHQiLCJodG1sVGV4dERhdGEiLCJpbWFnZSIsImxhYmVsIiwibGlzdEl0ZW0iLCJsaXN0SXRlbVZhbHVlIiwib25lbnRlcmxpc3RpdGVtdmFsdWUiLCJsaXN0T3JkZXJlZCIsImxpc3QiLCJvbmVudGVybGlzdG9yZGVyZWQiLCJsaXN0VW5vcmRlcmVkIiwicGFyYWdyYXBoIiwicmVmZXJlbmNlIiwib25lbnRlcnJlZmVyZW5jZSIsInJlZmVyZW5jZVN0cmluZyIsInJlc291cmNlRGVzdGluYXRpb25TdHJpbmciLCJyZXNvdXJjZVRpdGxlU3RyaW5nIiwic2V0ZXh0SGVhZGluZyIsInN0cm9uZyIsInRoZW1hdGljQnJlYWsiLCJleGl0IiwiY2xvc2VyIiwiYXR4SGVhZGluZ1NlcXVlbmNlIiwib25leGl0YXR4aGVhZGluZ3NlcXVlbmNlIiwib25leGl0YXV0b2xpbmtlbWFpbCIsIm9uZXhpdGF1dG9saW5rcHJvdG9jb2wiLCJjaGFyYWN0ZXJFc2NhcGVWYWx1ZSIsIm9uZXhpdGRhdGEiLCJjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJIZXhhZGVjaW1hbCIsIm9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZW1hcmtlciIsImNoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWMiLCJjaGFyYWN0ZXJSZWZlcmVuY2VWYWx1ZSIsIm9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZXZhbHVlIiwib25leGl0Y29kZWZlbmNlZCIsImNvZGVGZW5jZWRGZW5jZSIsIm9uZXhpdGNvZGVmZW5jZWRmZW5jZSIsIm9uZXhpdGNvZGVmZW5jZWRmZW5jZWluZm8iLCJvbmV4aXRjb2RlZmVuY2VkZmVuY2VtZXRhIiwib25leGl0Y29kZWluZGVudGVkIiwib25leGl0Y29kZXRleHQiLCJvbmV4aXRkZWZpbml0aW9uZGVzdGluYXRpb25zdHJpbmciLCJvbmV4aXRkZWZpbml0aW9ubGFiZWxzdHJpbmciLCJvbmV4aXRkZWZpbml0aW9udGl0bGVzdHJpbmciLCJvbmV4aXRoYXJkYnJlYWsiLCJvbmV4aXRodG1sZmxvdyIsIm9uZXhpdGh0bWx0ZXh0Iiwib25leGl0aW1hZ2UiLCJvbmV4aXRsYWJlbCIsImxhYmVsVGV4dCIsIm9uZXhpdGxhYmVsdGV4dCIsImxpbmVFbmRpbmciLCJvbmV4aXRsaW5lZW5kaW5nIiwib25leGl0bGluayIsIm9uZXhpdHJlZmVyZW5jZXN0cmluZyIsIm9uZXhpdHJlc291cmNlZGVzdGluYXRpb25zdHJpbmciLCJvbmV4aXRyZXNvdXJjZXRpdGxlc3RyaW5nIiwicmVzb3VyY2UiLCJvbmV4aXRyZXNvdXJjZSIsIm9uZXhpdHNldGV4dGhlYWRpbmciLCJzZXRleHRIZWFkaW5nTGluZVNlcXVlbmNlIiwib25leGl0c2V0ZXh0aGVhZGluZ2xpbmVzZXF1ZW5jZSIsInNldGV4dEhlYWRpbmdUZXh0Iiwib25leGl0c2V0ZXh0aGVhZGluZ3RleHQiLCJjb25maWd1cmUiLCJtZGFzdEV4dGVuc2lvbnMiLCJjb21waWxlIiwiZXZlbnRzIiwidHJlZSIsInR5cGUiLCJjaGlsZHJlbiIsImNvbnRleHQiLCJzdGFjayIsInRva2VuU3RhY2siLCJyZXN1bWUiLCJzZXREYXRhIiwiZ2V0RGF0YSIsImxpc3RTdGFjayIsImluZGV4IiwibGVuZ3RoIiwicHVzaCIsInRhaWwiLCJwb3AiLCJwcmVwYXJlTGlzdCIsImhhbmRsZXIiLCJjYWxsIiwiT2JqZWN0IiwiYXNzaWduIiwic2xpY2VTZXJpYWxpemUiLCJkZWZhdWx0T25FcnJvciIsInBvc2l0aW9uIiwic3RhcnQiLCJwb2ludCIsImxpbmUiLCJjb2x1bW4iLCJvZmZzZXQiLCJlbmQiLCJjb250YWluZXJCYWxhbmNlIiwibGlzdFNwcmVhZCIsImxpbmVJbmRleCIsImZpcnN0QmxhbmtMaW5lSW5kZXgiLCJhdE1hcmtlciIsImV2ZW50IiwibGluZUVuZGluZ0JsYW5rIiwibGluZVByZWZpeCIsImxpc3RJdGVtTWFya2VyIiwibGlzdEl0ZW1QcmVmaXgiLCJsaXN0SXRlbVByZWZpeFdoaXRlc3BhY2UiLCJ0YWlsSW5kZXgiLCJ0YWlsRXZlbnQiLCJibG9ja1F1b3RlUHJlZml4IiwiYmxvY2tRdW90ZVByZWZpeFdoaXRlc3BhY2UiLCJibG9ja1F1b3RlTWFya2VyIiwibGlzdEl0ZW1JbmRlbnQiLCJfc3ByZWFkIiwic3BsaWNlIiwia2V5IiwiY3JlYXRlIiwiYW5kIiwib3BlbiIsInRva2VuIiwibm9kZSIsImVycm9ySGFuZGxlciIsInBhcmVudCIsImNsb3NlIiwib25FeGl0RXJyb3IiLCJFcnJvciIsImFuY2VzdG9yIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJudW1lcmljQmFzZURlY2ltYWwiLCJsYW5nIiwibWV0YSIsInJlcGxhY2UiLCJpZGVudGlmaWVyIiwidG9Mb3dlckNhc2UiLCJ0aXRsZSIsInVybCIsImRlcHRoIiwiY2hhckNvZGVBdCIsImVxdWFsc1RvIiwidGV4dCIsImluY2x1ZGVzIiwicmVmZXJlbmNlVHlwZSIsInN0cmluZyIsImZyYWdtZW50IiwiYWx0IiwibnVtZXJpY0Jhc2VIZXhhZGVjaW1hbCIsInJlc3VsdCIsIm9yZGVyZWQiLCJzcHJlYWQiLCJjaGVja2VkIiwiZCIsImNvbWJpbmVkIiwiZXh0ZW5zaW9ucyIsIkFycmF5IiwiaXNBcnJheSIsImV4dGVuc2lvbiIsInJpZ2h0IiwibGVmdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mdast-util-from-markdown/dev/lib/index.js\n");

/***/ })

};
;