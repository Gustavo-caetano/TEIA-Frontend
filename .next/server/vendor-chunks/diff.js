"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/diff";
exports.ids = ["vendor-chunks/diff"];
exports.modules = {

/***/ "(ssr)/./node_modules/diff/lib/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/diff/lib/index.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Diff: () => (/* binding */ Diff),\n/* harmony export */   applyPatch: () => (/* binding */ applyPatch),\n/* harmony export */   applyPatches: () => (/* binding */ applyPatches),\n/* harmony export */   canonicalize: () => (/* binding */ canonicalize),\n/* harmony export */   convertChangesToDMP: () => (/* binding */ convertChangesToDMP),\n/* harmony export */   convertChangesToXML: () => (/* binding */ convertChangesToXML),\n/* harmony export */   createPatch: () => (/* binding */ createPatch),\n/* harmony export */   createTwoFilesPatch: () => (/* binding */ createTwoFilesPatch),\n/* harmony export */   diffArrays: () => (/* binding */ diffArrays),\n/* harmony export */   diffChars: () => (/* binding */ diffChars),\n/* harmony export */   diffCss: () => (/* binding */ diffCss),\n/* harmony export */   diffJson: () => (/* binding */ diffJson),\n/* harmony export */   diffLines: () => (/* binding */ diffLines),\n/* harmony export */   diffSentences: () => (/* binding */ diffSentences),\n/* harmony export */   diffTrimmedLines: () => (/* binding */ diffTrimmedLines),\n/* harmony export */   diffWords: () => (/* binding */ diffWords),\n/* harmony export */   diffWordsWithSpace: () => (/* binding */ diffWordsWithSpace),\n/* harmony export */   formatPatch: () => (/* binding */ formatPatch),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   parsePatch: () => (/* binding */ parsePatch),\n/* harmony export */   reversePatch: () => (/* binding */ reversePatch),\n/* harmony export */   structuredPatch: () => (/* binding */ structuredPatch)\n/* harmony export */ });\nfunction Diff() {}\nDiff.prototype = {\n    diff: function diff(oldString, newString) {\n        var _options$timeout;\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var callback = options.callback;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        this.options = options;\n        var self = this;\n        function done(value) {\n            if (callback) {\n                setTimeout(function() {\n                    callback(undefined, value);\n                }, 0);\n                return true;\n            } else {\n                return value;\n            }\n        } // Allow subclasses to massage the input prior to running\n        oldString = this.castInput(oldString);\n        newString = this.castInput(newString);\n        oldString = this.removeEmpty(this.tokenize(oldString));\n        newString = this.removeEmpty(this.tokenize(newString));\n        var newLen = newString.length, oldLen = oldString.length;\n        var editLength = 1;\n        var maxEditLength = newLen + oldLen;\n        if (options.maxEditLength) {\n            maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n        }\n        var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;\n        var abortAfterTimestamp = Date.now() + maxExecutionTime;\n        var bestPath = [\n            {\n                oldPos: -1,\n                lastComponent: undefined\n            }\n        ]; // Seed editLength = 0, i.e. the content starts with the same values\n        var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n        if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n            // Identity per the equality and tokenizer\n            return done([\n                {\n                    value: this.join(newString),\n                    count: newString.length\n                }\n            ]);\n        } // Once we hit the right edge of the edit graph on some diagonal k, we can\n        // definitely reach the end of the edit graph in no more than k edits, so\n        // there's no point in considering any moves to diagonal k+1 any more (from\n        // which we're guaranteed to need at least k+1 more edits).\n        // Similarly, once we've reached the bottom of the edit graph, there's no\n        // point considering moves to lower diagonals.\n        // We record this fact by setting minDiagonalToConsider and\n        // maxDiagonalToConsider to some finite value once we've hit the edge of\n        // the edit graph.\n        // This optimization is not faithful to the original algorithm presented in\n        // Myers's paper, which instead pointlessly extends D-paths off the end of\n        // the edit graph - see page 7 of Myers's paper which notes this point\n        // explicitly and illustrates it with a diagram. This has major performance\n        // implications for some common scenarios. For instance, to compute a diff\n        // where the new text simply appends d characters on the end of the\n        // original text of length n, the true Myers algorithm will take O(n+d^2)\n        // time while this optimization needs only O(n+d) time.\n        var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity; // Main worker method. checks all permutations of a given edit length for acceptance.\n        function execEditLength() {\n            for(var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2){\n                var basePath = void 0;\n                var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];\n                if (removePath) {\n                    // No one else is going to attempt to use this value, clear it\n                    bestPath[diagonalPath - 1] = undefined;\n                }\n                var canAdd = false;\n                if (addPath) {\n                    // what newPos will be after we do an insertion:\n                    var addPathNewPos = addPath.oldPos - diagonalPath;\n                    canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n                }\n                var canRemove = removePath && removePath.oldPos + 1 < oldLen;\n                if (!canAdd && !canRemove) {\n                    // If this path is a terminal then prune\n                    bestPath[diagonalPath] = undefined;\n                    continue;\n                } // Select the diagonal that we want to branch from. We select the prior\n                // path whose position in the old string is the farthest from the origin\n                // and does not pass the bounds of the diff graph\n                // TODO: Remove the `+ 1` here to make behavior match Myers algorithm\n                //       and prefer to order removals before insertions.\n                if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {\n                    basePath = self.addToPath(addPath, true, undefined, 0);\n                } else {\n                    basePath = self.addToPath(removePath, undefined, true, 1);\n                }\n                newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n                if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n                    // If we have hit the end of both strings, then we are done\n                    return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));\n                } else {\n                    bestPath[diagonalPath] = basePath;\n                    if (basePath.oldPos + 1 >= oldLen) {\n                        maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n                    }\n                    if (newPos + 1 >= newLen) {\n                        minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n                    }\n                }\n            }\n            editLength++;\n        } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n        // sync and async mode which is never fun. Loops over execEditLength until a value\n        // is produced, or until the edit length exceeds options.maxEditLength (if given),\n        // in which case it will return undefined.\n        if (callback) {\n            (function exec() {\n                setTimeout(function() {\n                    if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n                        return callback();\n                    }\n                    if (!execEditLength()) {\n                        exec();\n                    }\n                }, 0);\n            })();\n        } else {\n            while(editLength <= maxEditLength && Date.now() <= abortAfterTimestamp){\n                var ret = execEditLength();\n                if (ret) {\n                    return ret;\n                }\n            }\n        }\n    },\n    addToPath: function addToPath(path, added, removed, oldPosInc) {\n        var last = path.lastComponent;\n        if (last && last.added === added && last.removed === removed) {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: {\n                    count: last.count + 1,\n                    added: added,\n                    removed: removed,\n                    previousComponent: last.previousComponent\n                }\n            };\n        } else {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: {\n                    count: 1,\n                    added: added,\n                    removed: removed,\n                    previousComponent: last\n                }\n            };\n        }\n    },\n    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n        var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;\n        while(newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])){\n            newPos++;\n            oldPos++;\n            commonCount++;\n        }\n        if (commonCount) {\n            basePath.lastComponent = {\n                count: commonCount,\n                previousComponent: basePath.lastComponent\n            };\n        }\n        basePath.oldPos = oldPos;\n        return newPos;\n    },\n    equals: function equals(left, right) {\n        if (this.options.comparator) {\n            return this.options.comparator(left, right);\n        } else {\n            return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n        }\n    },\n    removeEmpty: function removeEmpty(array) {\n        var ret = [];\n        for(var i = 0; i < array.length; i++){\n            if (array[i]) {\n                ret.push(array[i]);\n            }\n        }\n        return ret;\n    },\n    castInput: function castInput(value) {\n        return value;\n    },\n    tokenize: function tokenize(value) {\n        return value.split(\"\");\n    },\n    join: function join(chars) {\n        return chars.join(\"\");\n    }\n};\nfunction buildValues(diff, lastComponent, newString, oldString, useLongestToken) {\n    // First we convert our linked list of components in reverse order to an\n    // array in the right order:\n    var components = [];\n    var nextComponent;\n    while(lastComponent){\n        components.push(lastComponent);\n        nextComponent = lastComponent.previousComponent;\n        delete lastComponent.previousComponent;\n        lastComponent = nextComponent;\n    }\n    components.reverse();\n    var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;\n    for(; componentPos < componentLen; componentPos++){\n        var component = components[componentPos];\n        if (!component.removed) {\n            if (!component.added && useLongestToken) {\n                var value = newString.slice(newPos, newPos + component.count);\n                value = value.map(function(value, i) {\n                    var oldValue = oldString[oldPos + i];\n                    return oldValue.length > value.length ? oldValue : value;\n                });\n                component.value = diff.join(value);\n            } else {\n                component.value = diff.join(newString.slice(newPos, newPos + component.count));\n            }\n            newPos += component.count; // Common case\n            if (!component.added) {\n                oldPos += component.count;\n            }\n        } else {\n            component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n            oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n            // The diffing algorithm is tied to add then remove output and this is the simplest\n            // route to get the desired output with minimal overhead.\n            if (componentPos && components[componentPos - 1].added) {\n                var tmp = components[componentPos - 1];\n                components[componentPos - 1] = components[componentPos];\n                components[componentPos] = tmp;\n            }\n        }\n    } // Special case handle for when one terminal is ignored (i.e. whitespace).\n    // For this case we merge the terminal into the prior string and drop the change.\n    // This is only available for string mode.\n    var finalComponent = components[componentLen - 1];\n    if (componentLen > 1 && typeof finalComponent.value === \"string\" && (finalComponent.added || finalComponent.removed) && diff.equals(\"\", finalComponent.value)) {\n        components[componentLen - 2].value += finalComponent.value;\n        components.pop();\n    }\n    return components;\n}\nvar characterDiff = new Diff();\nfunction diffChars(oldStr, newStr, options) {\n    return characterDiff.diff(oldStr, newStr, options);\n}\nfunction generateOptions(options, defaults) {\n    if (typeof options === \"function\") {\n        defaults.callback = options;\n    } else if (options) {\n        for(var name in options){\n            /* istanbul ignore else */ if (options.hasOwnProperty(name)) {\n                defaults[name] = options[name];\n            }\n        }\n    }\n    return defaults;\n}\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\nvar reWhitespace = /\\S/;\nvar wordDiff = new Diff();\nwordDiff.equals = function(left, right) {\n    if (this.options.ignoreCase) {\n        left = left.toLowerCase();\n        right = right.toLowerCase();\n    }\n    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\nwordDiff.tokenize = function(value) {\n    // All whitespace symbols except newline group into one token, each newline - in separate token\n    var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n    for(var i = 0; i < tokens.length - 1; i++){\n        // If we have an empty string in the next field and we have only word chars before and after, merge\n        if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n            tokens[i] += tokens[i + 2];\n            tokens.splice(i + 1, 2);\n            i--;\n        }\n    }\n    return tokens;\n};\nfunction diffWords(oldStr, newStr, options) {\n    options = generateOptions(options, {\n        ignoreWhitespace: true\n    });\n    return wordDiff.diff(oldStr, newStr, options);\n}\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n    return wordDiff.diff(oldStr, newStr, options);\n}\nvar lineDiff = new Diff();\nlineDiff.tokenize = function(value) {\n    if (this.options.stripTrailingCr) {\n        // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n        value = value.replace(/\\r\\n/g, \"\\n\");\n    }\n    var retLines = [], linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n        linesAndNewlines.pop();\n    } // Merge the content and line separators into single tokens\n    for(var i = 0; i < linesAndNewlines.length; i++){\n        var line = linesAndNewlines[i];\n        if (i % 2 && !this.options.newlineIsToken) {\n            retLines[retLines.length - 1] += line;\n        } else {\n            if (this.options.ignoreWhitespace) {\n                line = line.trim();\n            }\n            retLines.push(line);\n        }\n    }\n    return retLines;\n};\nfunction diffLines(oldStr, newStr, callback) {\n    return lineDiff.diff(oldStr, newStr, callback);\n}\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n    var options = generateOptions(callback, {\n        ignoreWhitespace: true\n    });\n    return lineDiff.diff(oldStr, newStr, options);\n}\nvar sentenceDiff = new Diff();\nsentenceDiff.tokenize = function(value) {\n    return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\nfunction diffSentences(oldStr, newStr, callback) {\n    return sentenceDiff.diff(oldStr, newStr, callback);\n}\nvar cssDiff = new Diff();\ncssDiff.tokenize = function(value) {\n    return value.split(/([{}:;,]|\\s+)/);\n};\nfunction diffCss(oldStr, newStr, callback) {\n    return cssDiff.diff(oldStr, newStr, callback);\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\njsonDiff.castInput = function(value) {\n    var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {\n        return typeof v === \"undefined\" ? undefinedReplacement : v;\n    } : _this$options$stringi;\n    return typeof value === \"string\" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, \"  \");\n};\njsonDiff.equals = function(left, right) {\n    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, \"$1\"), right.replace(/,([\\r\\n])/g, \"$1\"));\n};\nfunction diffJson(oldObj, newObj, options) {\n    return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n    if (replacer) {\n        obj = replacer(key, obj);\n    }\n    var i;\n    for(i = 0; i < stack.length; i += 1){\n        if (stack[i] === obj) {\n            return replacementStack[i];\n        }\n    }\n    var canonicalizedObj;\n    if (\"[object Array]\" === objectPrototypeToString.call(obj)) {\n        stack.push(obj);\n        canonicalizedObj = new Array(obj.length);\n        replacementStack.push(canonicalizedObj);\n        for(i = 0; i < obj.length; i += 1){\n            canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n        }\n        stack.pop();\n        replacementStack.pop();\n        return canonicalizedObj;\n    }\n    if (obj && obj.toJSON) {\n        obj = obj.toJSON();\n    }\n    if (_typeof(obj) === \"object\" && obj !== null) {\n        stack.push(obj);\n        canonicalizedObj = {};\n        replacementStack.push(canonicalizedObj);\n        var sortedKeys = [], _key;\n        for(_key in obj){\n            /* istanbul ignore else */ if (obj.hasOwnProperty(_key)) {\n                sortedKeys.push(_key);\n            }\n        }\n        sortedKeys.sort();\n        for(i = 0; i < sortedKeys.length; i += 1){\n            _key = sortedKeys[i];\n            canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n        }\n        stack.pop();\n        replacementStack.pop();\n    } else {\n        canonicalizedObj = obj;\n    }\n    return canonicalizedObj;\n}\nvar arrayDiff = new Diff();\narrayDiff.tokenize = function(value) {\n    return value.slice();\n};\narrayDiff.join = arrayDiff.removeEmpty = function(value) {\n    return value;\n};\nfunction diffArrays(oldArr, newArr, callback) {\n    return arrayDiff.diff(oldArr, newArr, callback);\n}\nfunction parsePatch(uniDiff) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/), delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [], list = [], i = 0;\n    function parseIndex() {\n        var index = {};\n        list.push(index); // Parse diff metadata\n        while(i < diffstr.length){\n            var line = diffstr[i]; // File header found, end parsing diff metadata\n            if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n                break;\n            } // Diff index\n            var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n            if (header) {\n                index.index = header[1];\n            }\n            i++;\n        } // Parse file headers if they are defined. Unified diff requires them, but\n        // there's no technical issues to have an isolated hunk without file header\n        parseFileHeader(index);\n        parseFileHeader(index); // Parse hunks\n        index.hunks = [];\n        while(i < diffstr.length){\n            var _line = diffstr[i];\n            if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n                break;\n            } else if (/^@@/.test(_line)) {\n                index.hunks.push(parseHunk());\n            } else if (_line && options.strict) {\n                // Ignore unexpected content unless in strict mode\n                throw new Error(\"Unknown line \" + (i + 1) + \" \" + JSON.stringify(_line));\n            } else {\n                i++;\n            }\n        }\n    } // Parses the --- and +++ headers, if none are found, no lines\n    // are consumed.\n    function parseFileHeader(index) {\n        var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n        if (fileHeader) {\n            var keyPrefix = fileHeader[1] === \"---\" ? \"old\" : \"new\";\n            var data = fileHeader[2].split(\"\t\", 2);\n            var fileName = data[0].replace(/\\\\\\\\/g, \"\\\\\");\n            if (/^\".*\"$/.test(fileName)) {\n                fileName = fileName.substr(1, fileName.length - 2);\n            }\n            index[keyPrefix + \"FileName\"] = fileName;\n            index[keyPrefix + \"Header\"] = (data[1] || \"\").trim();\n            i++;\n        }\n    } // Parses a hunk\n    // This assumes that we are at the start of a hunk.\n    function parseHunk() {\n        var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n        var hunk = {\n            oldStart: +chunkHeader[1],\n            oldLines: typeof chunkHeader[2] === \"undefined\" ? 1 : +chunkHeader[2],\n            newStart: +chunkHeader[3],\n            newLines: typeof chunkHeader[4] === \"undefined\" ? 1 : +chunkHeader[4],\n            lines: [],\n            linedelimiters: []\n        }; // Unified Diff Format quirk: If the chunk size is 0,\n        // the first number is one lower than one would expect.\n        // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n        if (hunk.oldLines === 0) {\n            hunk.oldStart += 1;\n        }\n        if (hunk.newLines === 0) {\n            hunk.newStart += 1;\n        }\n        var addCount = 0, removeCount = 0;\n        for(; i < diffstr.length; i++){\n            // Lines starting with '---' could be mistaken for the \"remove line\" operation\n            // But they could be the header for the next file. Therefore prune such cases out.\n            if (diffstr[i].indexOf(\"--- \") === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf(\"+++ \") === 0 && diffstr[i + 2].indexOf(\"@@\") === 0) {\n                break;\n            }\n            var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? \" \" : diffstr[i][0];\n            if (operation === \"+\" || operation === \"-\" || operation === \" \" || operation === \"\\\\\") {\n                hunk.lines.push(diffstr[i]);\n                hunk.linedelimiters.push(delimiters[i] || \"\\n\");\n                if (operation === \"+\") {\n                    addCount++;\n                } else if (operation === \"-\") {\n                    removeCount++;\n                } else if (operation === \" \") {\n                    addCount++;\n                    removeCount++;\n                }\n            } else {\n                break;\n            }\n        } // Handle the empty block count case\n        if (!addCount && hunk.newLines === 1) {\n            hunk.newLines = 0;\n        }\n        if (!removeCount && hunk.oldLines === 1) {\n            hunk.oldLines = 0;\n        } // Perform optional sanity checking\n        if (options.strict) {\n            if (addCount !== hunk.newLines) {\n                throw new Error(\"Added line count did not match for hunk at line \" + (chunkHeaderIndex + 1));\n            }\n            if (removeCount !== hunk.oldLines) {\n                throw new Error(\"Removed line count did not match for hunk at line \" + (chunkHeaderIndex + 1));\n            }\n        }\n        return hunk;\n    }\n    while(i < diffstr.length){\n        parseIndex();\n    }\n    return list;\n}\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction distanceIterator(start, minLine, maxLine) {\n    var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;\n    return function iterator() {\n        if (wantForward && !forwardExhausted) {\n            if (backwardExhausted) {\n                localOffset++;\n            } else {\n                wantForward = false;\n            } // Check if trying to fit beyond text length, and if not, check it fits\n            // after offset location (or desired location on first iteration)\n            if (start + localOffset <= maxLine) {\n                return localOffset;\n            }\n            forwardExhausted = true;\n        }\n        if (!backwardExhausted) {\n            if (!forwardExhausted) {\n                wantForward = true;\n            } // Check if trying to fit before text beginning, and if not, check it fits\n            // before offset location\n            if (minLine <= start - localOffset) {\n                return -localOffset++;\n            }\n            backwardExhausted = true;\n            return iterator();\n        } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n    };\n}\nfunction applyPatch(source, uniDiff) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (typeof uniDiff === \"string\") {\n        uniDiff = parsePatch(uniDiff);\n    }\n    if (Array.isArray(uniDiff)) {\n        if (uniDiff.length > 1) {\n            throw new Error(\"applyPatch only works with a single input.\");\n        }\n        uniDiff = uniDiff[0];\n    } // Apply the diff to the input\n    var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/), delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [], hunks = uniDiff.hunks, compareLine = options.compareLine || function(lineNumber, line, operation, patchContent) {\n        return line === patchContent;\n    }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL, addEOFNL;\n    /**\n   * Checks if the hunk exactly fits on the provided location\n   */ function hunkFits(hunk, toPos) {\n        for(var j = 0; j < hunk.lines.length; j++){\n            var line = hunk.lines[j], operation = line.length > 0 ? line[0] : \" \", content = line.length > 0 ? line.substr(1) : line;\n            if (operation === \" \" || operation === \"-\") {\n                // Context sanity check\n                if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n                    errorCount++;\n                    if (errorCount > fuzzFactor) {\n                        return false;\n                    }\n                }\n                toPos++;\n            }\n        }\n        return true;\n    } // Search best fit offsets for each hunk based on the previous ones\n    for(var i = 0; i < hunks.length; i++){\n        var hunk = hunks[i], maxLine = lines.length - hunk.oldLines, localOffset = 0, toPos = offset + hunk.oldStart - 1;\n        var iterator = distanceIterator(toPos, minLine, maxLine);\n        for(; localOffset !== undefined; localOffset = iterator()){\n            if (hunkFits(hunk, toPos + localOffset)) {\n                hunk.offset = offset += localOffset;\n                break;\n            }\n        }\n        if (localOffset === undefined) {\n            return false;\n        } // Set lower text limit to end of the current hunk, so next ones don't try\n        // to fit over already patched text\n        minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n    } // Apply patch hunks\n    var diffOffset = 0;\n    for(var _i = 0; _i < hunks.length; _i++){\n        var _hunk = hunks[_i], _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n        diffOffset += _hunk.newLines - _hunk.oldLines;\n        for(var j = 0; j < _hunk.lines.length; j++){\n            var line = _hunk.lines[j], operation = line.length > 0 ? line[0] : \" \", content = line.length > 0 ? line.substr(1) : line, delimiter = _hunk.linedelimiters && _hunk.linedelimiters[j] || \"\\n\";\n            if (operation === \" \") {\n                _toPos++;\n            } else if (operation === \"-\") {\n                lines.splice(_toPos, 1);\n                delimiters.splice(_toPos, 1);\n            /* istanbul ignore else */ } else if (operation === \"+\") {\n                lines.splice(_toPos, 0, content);\n                delimiters.splice(_toPos, 0, delimiter);\n                _toPos++;\n            } else if (operation === \"\\\\\") {\n                var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n                if (previousOperation === \"+\") {\n                    removeEOFNL = true;\n                } else if (previousOperation === \"-\") {\n                    addEOFNL = true;\n                }\n            }\n        }\n    } // Handle EOFNL insertion/removal\n    if (removeEOFNL) {\n        while(!lines[lines.length - 1]){\n            lines.pop();\n            delimiters.pop();\n        }\n    } else if (addEOFNL) {\n        lines.push(\"\");\n        delimiters.push(\"\\n\");\n    }\n    for(var _k = 0; _k < lines.length - 1; _k++){\n        lines[_k] = lines[_k] + delimiters[_k];\n    }\n    return lines.join(\"\");\n} // Wrapper that supports multiple file patches via callbacks.\nfunction applyPatches(uniDiff, options) {\n    if (typeof uniDiff === \"string\") {\n        uniDiff = parsePatch(uniDiff);\n    }\n    var currentIndex = 0;\n    function processIndex() {\n        var index = uniDiff[currentIndex++];\n        if (!index) {\n            return options.complete();\n        }\n        options.loadFile(index, function(err, data) {\n            if (err) {\n                return options.complete(err);\n            }\n            var updatedContent = applyPatch(data, index, options);\n            options.patched(index, updatedContent, function(err) {\n                if (err) {\n                    return options.complete(err);\n                }\n                processIndex();\n            });\n        });\n    }\n    processIndex();\n}\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof options.context === \"undefined\") {\n        options.context = 4;\n    }\n    var diff = diffLines(oldStr, newStr, options);\n    if (!diff) {\n        return;\n    }\n    diff.push({\n        value: \"\",\n        lines: []\n    }); // Append an empty value to make cleanup easier\n    function contextLines(lines) {\n        return lines.map(function(entry) {\n            return \" \" + entry;\n        });\n    }\n    var hunks = [];\n    var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;\n    var _loop = function _loop(i) {\n        var current = diff[i], lines = current.lines || current.value.replace(/\\n$/, \"\").split(\"\\n\");\n        current.lines = lines;\n        if (current.added || current.removed) {\n            var _curRange;\n            // If we have previous context, start with that\n            if (!oldRangeStart) {\n                var prev = diff[i - 1];\n                oldRangeStart = oldLine;\n                newRangeStart = newLine;\n                if (prev) {\n                    curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n                    oldRangeStart -= curRange.length;\n                    newRangeStart -= curRange.length;\n                }\n            } // Output our changes\n            (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {\n                return (current.added ? \"+\" : \"-\") + entry;\n            }))); // Track the updated file position\n            if (current.added) {\n                newLine += lines.length;\n            } else {\n                oldLine += lines.length;\n            }\n        } else {\n            // Identical context lines. Track line changes\n            if (oldRangeStart) {\n                // Close out any changes that have been output (or join overlapping)\n                if (lines.length <= options.context * 2 && i < diff.length - 2) {\n                    var _curRange2;\n                    // Overlapping\n                    (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n                } else {\n                    var _curRange3;\n                    // end the range and output\n                    var contextSize = Math.min(lines.length, options.context);\n                    (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n                    var hunk = {\n                        oldStart: oldRangeStart,\n                        oldLines: oldLine - oldRangeStart + contextSize,\n                        newStart: newRangeStart,\n                        newLines: newLine - newRangeStart + contextSize,\n                        lines: curRange\n                    };\n                    if (i >= diff.length - 2 && lines.length <= options.context) {\n                        // EOF is inside this hunk\n                        var oldEOFNewline = /\\n$/.test(oldStr);\n                        var newEOFNewline = /\\n$/.test(newStr);\n                        var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n                        if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n                            // special case: old has no eol and no trailing context; no-nl can end up before adds\n                            // however, if the old file is empty, do not output the no-nl line\n                            curRange.splice(hunk.oldLines, 0, \"\\\\ No newline at end of file\");\n                        }\n                        if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n                            curRange.push(\"\\\\ No newline at end of file\");\n                        }\n                    }\n                    hunks.push(hunk);\n                    oldRangeStart = 0;\n                    newRangeStart = 0;\n                    curRange = [];\n                }\n            }\n            oldLine += lines.length;\n            newLine += lines.length;\n        }\n    };\n    for(var i = 0; i < diff.length; i++){\n        _loop(i);\n    }\n    return {\n        oldFileName: oldFileName,\n        newFileName: newFileName,\n        oldHeader: oldHeader,\n        newHeader: newHeader,\n        hunks: hunks\n    };\n}\nfunction formatPatch(diff) {\n    if (Array.isArray(diff)) {\n        return diff.map(formatPatch).join(\"\\n\");\n    }\n    var ret = [];\n    if (diff.oldFileName == diff.newFileName) {\n        ret.push(\"Index: \" + diff.oldFileName);\n    }\n    ret.push(\"===================================================================\");\n    ret.push(\"--- \" + diff.oldFileName + (typeof diff.oldHeader === \"undefined\" ? \"\" : \"\t\" + diff.oldHeader));\n    ret.push(\"+++ \" + diff.newFileName + (typeof diff.newHeader === \"undefined\" ? \"\" : \"\t\" + diff.newHeader));\n    for(var i = 0; i < diff.hunks.length; i++){\n        var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n        // the first number is one lower than one would expect.\n        // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n        if (hunk.oldLines === 0) {\n            hunk.oldStart -= 1;\n        }\n        if (hunk.newLines === 0) {\n            hunk.newStart -= 1;\n        }\n        ret.push(\"@@ -\" + hunk.oldStart + \",\" + hunk.oldLines + \" +\" + hunk.newStart + \",\" + hunk.newLines + \" @@\");\n        ret.push.apply(ret, hunk.lines);\n    }\n    return ret.join(\"\\n\") + \"\\n\";\n}\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\nfunction arrayEqual(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    return arrayStartsWith(a, b);\n}\nfunction arrayStartsWith(array, start) {\n    if (start.length > array.length) {\n        return false;\n    }\n    for(var i = 0; i < start.length; i++){\n        if (start[i] !== array[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction calcLineCount(hunk) {\n    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;\n    if (oldLines !== undefined) {\n        hunk.oldLines = oldLines;\n    } else {\n        delete hunk.oldLines;\n    }\n    if (newLines !== undefined) {\n        hunk.newLines = newLines;\n    } else {\n        delete hunk.newLines;\n    }\n}\nfunction merge(mine, theirs, base) {\n    mine = loadPatch(mine, base);\n    theirs = loadPatch(theirs, base);\n    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n    // Leaving sanity checks on this to the API consumer that may know more about the\n    // meaning in their own context.\n    if (mine.index || theirs.index) {\n        ret.index = mine.index || theirs.index;\n    }\n    if (mine.newFileName || theirs.newFileName) {\n        if (!fileNameChanged(mine)) {\n            // No header or no change in ours, use theirs (and ours if theirs does not exist)\n            ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n            ret.newFileName = theirs.newFileName || mine.newFileName;\n            ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n            ret.newHeader = theirs.newHeader || mine.newHeader;\n        } else if (!fileNameChanged(theirs)) {\n            // No header or no change in theirs, use ours\n            ret.oldFileName = mine.oldFileName;\n            ret.newFileName = mine.newFileName;\n            ret.oldHeader = mine.oldHeader;\n            ret.newHeader = mine.newHeader;\n        } else {\n            // Both changed... figure it out\n            ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n            ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n            ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n            ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n        }\n    }\n    ret.hunks = [];\n    var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;\n    while(mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length){\n        var mineCurrent = mine.hunks[mineIndex] || {\n            oldStart: Infinity\n        }, theirsCurrent = theirs.hunks[theirsIndex] || {\n            oldStart: Infinity\n        };\n        if (hunkBefore(mineCurrent, theirsCurrent)) {\n            // This patch does not overlap with any of the others, yay.\n            ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n            mineIndex++;\n            theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n        } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n            // This patch does not overlap with any of the others, yay.\n            ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n            theirsIndex++;\n            mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n        } else {\n            // Overlap, merge as best we can\n            var mergedHunk = {\n                oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n                oldLines: 0,\n                newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n                newLines: 0,\n                lines: []\n            };\n            mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n            theirsIndex++;\n            mineIndex++;\n            ret.hunks.push(mergedHunk);\n        }\n    }\n    return ret;\n}\nfunction loadPatch(param, base) {\n    if (typeof param === \"string\") {\n        if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n            return parsePatch(param)[0];\n        }\n        if (!base) {\n            throw new Error(\"Must provide a base reference or pass in a patch\");\n        }\n        return structuredPatch(undefined, undefined, base, param);\n    }\n    return param;\n}\nfunction fileNameChanged(patch) {\n    return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\nfunction selectField(index, mine, theirs) {\n    if (mine === theirs) {\n        return mine;\n    } else {\n        index.conflict = true;\n        return {\n            mine: mine,\n            theirs: theirs\n        };\n    }\n}\nfunction hunkBefore(test, check) {\n    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\nfunction cloneHunk(hunk, offset) {\n    return {\n        oldStart: hunk.oldStart,\n        oldLines: hunk.oldLines,\n        newStart: hunk.newStart + offset,\n        newLines: hunk.newLines,\n        lines: hunk.lines\n    };\n}\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n    // This will generally result in a conflicted hunk, but there are cases where the context\n    // is the only overlap where we can successfully merge the content here.\n    var mine = {\n        offset: mineOffset,\n        lines: mineLines,\n        index: 0\n    }, their = {\n        offset: theirOffset,\n        lines: theirLines,\n        index: 0\n    }; // Handle any leading content\n    insertLeading(hunk, mine, their);\n    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n    while(mine.index < mine.lines.length && their.index < their.lines.length){\n        var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];\n        if ((mineCurrent[0] === \"-\" || mineCurrent[0] === \"+\") && (theirCurrent[0] === \"-\" || theirCurrent[0] === \"+\")) {\n            // Both modified ...\n            mutualChange(hunk, mine, their);\n        } else if (mineCurrent[0] === \"+\" && theirCurrent[0] === \" \") {\n            var _hunk$lines;\n            // Mine inserted\n            (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n        } else if (theirCurrent[0] === \"+\" && mineCurrent[0] === \" \") {\n            var _hunk$lines2;\n            // Theirs inserted\n            (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n        } else if (mineCurrent[0] === \"-\" && theirCurrent[0] === \" \") {\n            // Mine removed or edited\n            removal(hunk, mine, their);\n        } else if (theirCurrent[0] === \"-\" && mineCurrent[0] === \" \") {\n            // Their removed or edited\n            removal(hunk, their, mine, true);\n        } else if (mineCurrent === theirCurrent) {\n            // Context identity\n            hunk.lines.push(mineCurrent);\n            mine.index++;\n            their.index++;\n        } else {\n            // Context mismatch\n            conflict(hunk, collectChange(mine), collectChange(their));\n        }\n    } // Now push anything that may be remaining\n    insertTrailing(hunk, mine);\n    insertTrailing(hunk, their);\n    calcLineCount(hunk);\n}\nfunction mutualChange(hunk, mine, their) {\n    var myChanges = collectChange(mine), theirChanges = collectChange(their);\n    if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n        // Special case for remove changes that are supersets of one another\n        if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n            var _hunk$lines3;\n            (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n            return;\n        } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n            var _hunk$lines4;\n            (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n            return;\n        }\n    } else if (arrayEqual(myChanges, theirChanges)) {\n        var _hunk$lines5;\n        (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n        return;\n    }\n    conflict(hunk, myChanges, theirChanges);\n}\nfunction removal(hunk, mine, their, swap) {\n    var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);\n    if (theirChanges.merged) {\n        var _hunk$lines6;\n        (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n    } else {\n        conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n    }\n}\nfunction conflict(hunk, mine, their) {\n    hunk.conflict = true;\n    hunk.lines.push({\n        conflict: true,\n        mine: mine,\n        theirs: their\n    });\n}\nfunction insertLeading(hunk, insert, their) {\n    while(insert.offset < their.offset && insert.index < insert.lines.length){\n        var line = insert.lines[insert.index++];\n        hunk.lines.push(line);\n        insert.offset++;\n    }\n}\nfunction insertTrailing(hunk, insert) {\n    while(insert.index < insert.lines.length){\n        var line = insert.lines[insert.index++];\n        hunk.lines.push(line);\n    }\n}\nfunction collectChange(state) {\n    var ret = [], operation = state.lines[state.index][0];\n    while(state.index < state.lines.length){\n        var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n        if (operation === \"-\" && line[0] === \"+\") {\n            operation = \"+\";\n        }\n        if (operation === line[0]) {\n            ret.push(line);\n            state.index++;\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\nfunction collectContext(state, matchChanges) {\n    var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;\n    while(matchIndex < matchChanges.length && state.index < state.lines.length){\n        var change = state.lines[state.index], match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n        if (match[0] === \"+\") {\n            break;\n        }\n        contextChanges = contextChanges || change[0] !== \" \";\n        merged.push(match);\n        matchIndex++; // Consume any additions in the other block as a conflict to attempt\n        // to pull in the remaining context after this\n        if (change[0] === \"+\") {\n            conflicted = true;\n            while(change[0] === \"+\"){\n                changes.push(change);\n                change = state.lines[++state.index];\n            }\n        }\n        if (match.substr(1) === change.substr(1)) {\n            changes.push(change);\n            state.index++;\n        } else {\n            conflicted = true;\n        }\n    }\n    if ((matchChanges[matchIndex] || \"\")[0] === \"+\" && contextChanges) {\n        conflicted = true;\n    }\n    if (conflicted) {\n        return changes;\n    }\n    while(matchIndex < matchChanges.length){\n        merged.push(matchChanges[matchIndex++]);\n    }\n    return {\n        merged: merged,\n        changes: changes\n    };\n}\nfunction allRemoves(changes) {\n    return changes.reduce(function(prev, change) {\n        return prev && change[0] === \"-\";\n    }, true);\n}\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n    for(var i = 0; i < delta; i++){\n        var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n        if (state.lines[state.index + i] !== \" \" + changeContent) {\n            return false;\n        }\n    }\n    state.index += delta;\n    return true;\n}\nfunction calcOldNewLineCount(lines) {\n    var oldLines = 0;\n    var newLines = 0;\n    lines.forEach(function(line) {\n        if (typeof line !== \"string\") {\n            var myCount = calcOldNewLineCount(line.mine);\n            var theirCount = calcOldNewLineCount(line.theirs);\n            if (oldLines !== undefined) {\n                if (myCount.oldLines === theirCount.oldLines) {\n                    oldLines += myCount.oldLines;\n                } else {\n                    oldLines = undefined;\n                }\n            }\n            if (newLines !== undefined) {\n                if (myCount.newLines === theirCount.newLines) {\n                    newLines += myCount.newLines;\n                } else {\n                    newLines = undefined;\n                }\n            }\n        } else {\n            if (newLines !== undefined && (line[0] === \"+\" || line[0] === \" \")) {\n                newLines++;\n            }\n            if (oldLines !== undefined && (line[0] === \"-\" || line[0] === \" \")) {\n                oldLines++;\n            }\n        }\n    });\n    return {\n        oldLines: oldLines,\n        newLines: newLines\n    };\n}\nfunction reversePatch(structuredPatch) {\n    if (Array.isArray(structuredPatch)) {\n        return structuredPatch.map(reversePatch).reverse();\n    }\n    return _objectSpread2(_objectSpread2({}, structuredPatch), {}, {\n        oldFileName: structuredPatch.newFileName,\n        oldHeader: structuredPatch.newHeader,\n        newFileName: structuredPatch.oldFileName,\n        newHeader: structuredPatch.oldHeader,\n        hunks: structuredPatch.hunks.map(function(hunk) {\n            return {\n                oldLines: hunk.newLines,\n                oldStart: hunk.newStart,\n                newLines: hunk.oldLines,\n                newStart: hunk.oldStart,\n                linedelimiters: hunk.linedelimiters,\n                lines: hunk.lines.map(function(l) {\n                    if (l.startsWith(\"-\")) {\n                        return \"+\".concat(l.slice(1));\n                    }\n                    if (l.startsWith(\"+\")) {\n                        return \"-\".concat(l.slice(1));\n                    }\n                    return l;\n                })\n            };\n        })\n    });\n}\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n    var ret = [], change, operation;\n    for(var i = 0; i < changes.length; i++){\n        change = changes[i];\n        if (change.added) {\n            operation = 1;\n        } else if (change.removed) {\n            operation = -1;\n        } else {\n            operation = 0;\n        }\n        ret.push([\n            operation,\n            change.value\n        ]);\n    }\n    return ret;\n}\nfunction convertChangesToXML(changes) {\n    var ret = [];\n    for(var i = 0; i < changes.length; i++){\n        var change = changes[i];\n        if (change.added) {\n            ret.push(\"<ins>\");\n        } else if (change.removed) {\n            ret.push(\"<del>\");\n        }\n        ret.push(escapeHTML(change.value));\n        if (change.added) {\n            ret.push(\"</ins>\");\n        } else if (change.removed) {\n            ret.push(\"</del>\");\n        }\n    }\n    return ret.join(\"\");\n}\nfunction escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, \"&amp;\");\n    n = n.replace(/</g, \"&lt;\");\n    n = n.replace(/>/g, \"&gt;\");\n    n = n.replace(/\"/g, \"&quot;\");\n    return n;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUM7UUFDWCxPQUFPLElBQUlpUixPQUFPOVIsT0FBTyxFQUFFO1lBQ3pCSCxJQUFJZ0IsSUFBSSxDQUFDO1FBQ1g7UUFFQWhCLElBQUlnQixJQUFJLENBQUM4UixXQUFXYixPQUFPeFUsS0FBSztRQUVoQyxJQUFJd1UsT0FBTy9SLEtBQUssRUFBRTtZQUNoQkYsSUFBSWdCLElBQUksQ0FBQztRQUNYLE9BQU8sSUFBSWlSLE9BQU85UixPQUFPLEVBQUU7WUFDekJILElBQUlnQixJQUFJLENBQUM7UUFDWDtJQUNGO0lBRUEsT0FBT2hCLElBQUlqQixJQUFJLENBQUM7QUFDbEI7QUFFQSxTQUFTK1QsV0FBV0MsQ0FBQztJQUNuQixJQUFJeE0sSUFBSXdNO0lBQ1J4TSxJQUFJQSxFQUFFckQsT0FBTyxDQUFDLE1BQU07SUFDcEJxRCxJQUFJQSxFQUFFckQsT0FBTyxDQUFDLE1BQU07SUFDcEJxRCxJQUFJQSxFQUFFckQsT0FBTyxDQUFDLE1BQU07SUFDcEJxRCxJQUFJQSxFQUFFckQsT0FBTyxDQUFDLE1BQU07SUFDcEIsT0FBT3FEO0FBQ1Q7QUFFd1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLWFpLXRlbXBsYXRlLXByby8uL25vZGVfbW9kdWxlcy9kaWZmL2xpYi9pbmRleC5tanM/YjIzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBEaWZmKCkge31cbkRpZmYucHJvdG90eXBlID0ge1xuICBkaWZmOiBmdW5jdGlvbiBkaWZmKG9sZFN0cmluZywgbmV3U3RyaW5nKSB7XG4gICAgdmFyIF9vcHRpb25zJHRpbWVvdXQ7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZG9uZSh2YWx1ZSkge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgdmFsdWUpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfSAvLyBBbGxvdyBzdWJjbGFzc2VzIHRvIG1hc3NhZ2UgdGhlIGlucHV0IHByaW9yIHRvIHJ1bm5pbmdcblxuXG4gICAgb2xkU3RyaW5nID0gdGhpcy5jYXN0SW5wdXQob2xkU3RyaW5nKTtcbiAgICBuZXdTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChuZXdTdHJpbmcpO1xuICAgIG9sZFN0cmluZyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShvbGRTdHJpbmcpKTtcbiAgICBuZXdTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUobmV3U3RyaW5nKSk7XG4gICAgdmFyIG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsXG4gICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGg7XG4gICAgdmFyIGVkaXRMZW5ndGggPSAxO1xuICAgIHZhciBtYXhFZGl0TGVuZ3RoID0gbmV3TGVuICsgb2xkTGVuO1xuXG4gICAgaWYgKG9wdGlvbnMubWF4RWRpdExlbmd0aCkge1xuICAgICAgbWF4RWRpdExlbmd0aCA9IE1hdGgubWluKG1heEVkaXRMZW5ndGgsIG9wdGlvbnMubWF4RWRpdExlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIG1heEV4ZWN1dGlvblRpbWUgPSAoX29wdGlvbnMkdGltZW91dCA9IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX29wdGlvbnMkdGltZW91dCAhPT0gdm9pZCAwID8gX29wdGlvbnMkdGltZW91dCA6IEluZmluaXR5O1xuICAgIHZhciBhYm9ydEFmdGVyVGltZXN0YW1wID0gRGF0ZS5ub3coKSArIG1heEV4ZWN1dGlvblRpbWU7XG4gICAgdmFyIGJlc3RQYXRoID0gW3tcbiAgICAgIG9sZFBvczogLTEsXG4gICAgICBsYXN0Q29tcG9uZW50OiB1bmRlZmluZWRcbiAgICB9XTsgLy8gU2VlZCBlZGl0TGVuZ3RoID0gMCwgaS5lLiB0aGUgY29udGVudCBzdGFydHMgd2l0aCB0aGUgc2FtZSB2YWx1ZXNcblxuICAgIHZhciBuZXdQb3MgPSB0aGlzLmV4dHJhY3RDb21tb24oYmVzdFBhdGhbMF0sIG5ld1N0cmluZywgb2xkU3RyaW5nLCAwKTtcblxuICAgIGlmIChiZXN0UGF0aFswXS5vbGRQb3MgKyAxID49IG9sZExlbiAmJiBuZXdQb3MgKyAxID49IG5ld0xlbikge1xuICAgICAgLy8gSWRlbnRpdHkgcGVyIHRoZSBlcXVhbGl0eSBhbmQgdG9rZW5pemVyXG4gICAgICByZXR1cm4gZG9uZShbe1xuICAgICAgICB2YWx1ZTogdGhpcy5qb2luKG5ld1N0cmluZyksXG4gICAgICAgIGNvdW50OiBuZXdTdHJpbmcubGVuZ3RoXG4gICAgICB9XSk7XG4gICAgfSAvLyBPbmNlIHdlIGhpdCB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgZWRpdCBncmFwaCBvbiBzb21lIGRpYWdvbmFsIGssIHdlIGNhblxuICAgIC8vIGRlZmluaXRlbHkgcmVhY2ggdGhlIGVuZCBvZiB0aGUgZWRpdCBncmFwaCBpbiBubyBtb3JlIHRoYW4gayBlZGl0cywgc29cbiAgICAvLyB0aGVyZSdzIG5vIHBvaW50IGluIGNvbnNpZGVyaW5nIGFueSBtb3ZlcyB0byBkaWFnb25hbCBrKzEgYW55IG1vcmUgKGZyb21cbiAgICAvLyB3aGljaCB3ZSdyZSBndWFyYW50ZWVkIHRvIG5lZWQgYXQgbGVhc3QgaysxIG1vcmUgZWRpdHMpLlxuICAgIC8vIFNpbWlsYXJseSwgb25jZSB3ZSd2ZSByZWFjaGVkIHRoZSBib3R0b20gb2YgdGhlIGVkaXQgZ3JhcGgsIHRoZXJlJ3Mgbm9cbiAgICAvLyBwb2ludCBjb25zaWRlcmluZyBtb3ZlcyB0byBsb3dlciBkaWFnb25hbHMuXG4gICAgLy8gV2UgcmVjb3JkIHRoaXMgZmFjdCBieSBzZXR0aW5nIG1pbkRpYWdvbmFsVG9Db25zaWRlciBhbmRcbiAgICAvLyBtYXhEaWFnb25hbFRvQ29uc2lkZXIgdG8gc29tZSBmaW5pdGUgdmFsdWUgb25jZSB3ZSd2ZSBoaXQgdGhlIGVkZ2Ugb2ZcbiAgICAvLyB0aGUgZWRpdCBncmFwaC5cbiAgICAvLyBUaGlzIG9wdGltaXphdGlvbiBpcyBub3QgZmFpdGhmdWwgdG8gdGhlIG9yaWdpbmFsIGFsZ29yaXRobSBwcmVzZW50ZWQgaW5cbiAgICAvLyBNeWVycydzIHBhcGVyLCB3aGljaCBpbnN0ZWFkIHBvaW50bGVzc2x5IGV4dGVuZHMgRC1wYXRocyBvZmYgdGhlIGVuZCBvZlxuICAgIC8vIHRoZSBlZGl0IGdyYXBoIC0gc2VlIHBhZ2UgNyBvZiBNeWVycydzIHBhcGVyIHdoaWNoIG5vdGVzIHRoaXMgcG9pbnRcbiAgICAvLyBleHBsaWNpdGx5IGFuZCBpbGx1c3RyYXRlcyBpdCB3aXRoIGEgZGlhZ3JhbS4gVGhpcyBoYXMgbWFqb3IgcGVyZm9ybWFuY2VcbiAgICAvLyBpbXBsaWNhdGlvbnMgZm9yIHNvbWUgY29tbW9uIHNjZW5hcmlvcy4gRm9yIGluc3RhbmNlLCB0byBjb21wdXRlIGEgZGlmZlxuICAgIC8vIHdoZXJlIHRoZSBuZXcgdGV4dCBzaW1wbHkgYXBwZW5kcyBkIGNoYXJhY3RlcnMgb24gdGhlIGVuZCBvZiB0aGVcbiAgICAvLyBvcmlnaW5hbCB0ZXh0IG9mIGxlbmd0aCBuLCB0aGUgdHJ1ZSBNeWVycyBhbGdvcml0aG0gd2lsbCB0YWtlIE8obitkXjIpXG4gICAgLy8gdGltZSB3aGlsZSB0aGlzIG9wdGltaXphdGlvbiBuZWVkcyBvbmx5IE8obitkKSB0aW1lLlxuXG5cbiAgICB2YXIgbWluRGlhZ29uYWxUb0NvbnNpZGVyID0gLUluZmluaXR5LFxuICAgICAgICBtYXhEaWFnb25hbFRvQ29uc2lkZXIgPSBJbmZpbml0eTsgLy8gTWFpbiB3b3JrZXIgbWV0aG9kLiBjaGVja3MgYWxsIHBlcm11dGF0aW9ucyBvZiBhIGdpdmVuIGVkaXQgbGVuZ3RoIGZvciBhY2NlcHRhbmNlLlxuXG4gICAgZnVuY3Rpb24gZXhlY0VkaXRMZW5ndGgoKSB7XG4gICAgICBmb3IgKHZhciBkaWFnb25hbFBhdGggPSBNYXRoLm1heChtaW5EaWFnb25hbFRvQ29uc2lkZXIsIC1lZGl0TGVuZ3RoKTsgZGlhZ29uYWxQYXRoIDw9IE1hdGgubWluKG1heERpYWdvbmFsVG9Db25zaWRlciwgZWRpdExlbmd0aCk7IGRpYWdvbmFsUGF0aCArPSAyKSB7XG4gICAgICAgIHZhciBiYXNlUGF0aCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHJlbW92ZVBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSxcbiAgICAgICAgICAgIGFkZFBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggKyAxXTtcblxuICAgICAgICBpZiAocmVtb3ZlUGF0aCkge1xuICAgICAgICAgIC8vIE5vIG9uZSBlbHNlIGlzIGdvaW5nIHRvIGF0dGVtcHQgdG8gdXNlIHRoaXMgdmFsdWUsIGNsZWFyIGl0XG4gICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FuQWRkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGFkZFBhdGgpIHtcbiAgICAgICAgICAvLyB3aGF0IG5ld1BvcyB3aWxsIGJlIGFmdGVyIHdlIGRvIGFuIGluc2VydGlvbjpcbiAgICAgICAgICB2YXIgYWRkUGF0aE5ld1BvcyA9IGFkZFBhdGgub2xkUG9zIC0gZGlhZ29uYWxQYXRoO1xuICAgICAgICAgIGNhbkFkZCA9IGFkZFBhdGggJiYgMCA8PSBhZGRQYXRoTmV3UG9zICYmIGFkZFBhdGhOZXdQb3MgPCBuZXdMZW47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FuUmVtb3ZlID0gcmVtb3ZlUGF0aCAmJiByZW1vdmVQYXRoLm9sZFBvcyArIDEgPCBvbGRMZW47XG5cbiAgICAgICAgaWYgKCFjYW5BZGQgJiYgIWNhblJlbW92ZSkge1xuICAgICAgICAgIC8vIElmIHRoaXMgcGF0aCBpcyBhIHRlcm1pbmFsIHRoZW4gcHJ1bmVcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIFNlbGVjdCB0aGUgZGlhZ29uYWwgdGhhdCB3ZSB3YW50IHRvIGJyYW5jaCBmcm9tLiBXZSBzZWxlY3QgdGhlIHByaW9yXG4gICAgICAgIC8vIHBhdGggd2hvc2UgcG9zaXRpb24gaW4gdGhlIG9sZCBzdHJpbmcgaXMgdGhlIGZhcnRoZXN0IGZyb20gdGhlIG9yaWdpblxuICAgICAgICAvLyBhbmQgZG9lcyBub3QgcGFzcyB0aGUgYm91bmRzIG9mIHRoZSBkaWZmIGdyYXBoXG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGUgYCsgMWAgaGVyZSB0byBtYWtlIGJlaGF2aW9yIG1hdGNoIE15ZXJzIGFsZ29yaXRobVxuICAgICAgICAvLyAgICAgICBhbmQgcHJlZmVyIHRvIG9yZGVyIHJlbW92YWxzIGJlZm9yZSBpbnNlcnRpb25zLlxuXG5cbiAgICAgICAgaWYgKCFjYW5SZW1vdmUgfHwgY2FuQWRkICYmIHJlbW92ZVBhdGgub2xkUG9zICsgMSA8IGFkZFBhdGgub2xkUG9zKSB7XG4gICAgICAgICAgYmFzZVBhdGggPSBzZWxmLmFkZFRvUGF0aChhZGRQYXRoLCB0cnVlLCB1bmRlZmluZWQsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VQYXRoID0gc2VsZi5hZGRUb1BhdGgocmVtb3ZlUGF0aCwgdW5kZWZpbmVkLCB0cnVlLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld1BvcyA9IHNlbGYuZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCk7XG5cbiAgICAgICAgaWYgKGJhc2VQYXRoLm9sZFBvcyArIDEgPj0gb2xkTGVuICYmIG5ld1BvcyArIDEgPj0gbmV3TGVuKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBoaXQgdGhlIGVuZCBvZiBib3RoIHN0cmluZ3MsIHRoZW4gd2UgYXJlIGRvbmVcbiAgICAgICAgICByZXR1cm4gZG9uZShidWlsZFZhbHVlcyhzZWxmLCBiYXNlUGF0aC5sYXN0Q29tcG9uZW50LCBuZXdTdHJpbmcsIG9sZFN0cmluZywgc2VsZi51c2VMb25nZXN0VG9rZW4pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gYmFzZVBhdGg7XG5cbiAgICAgICAgICBpZiAoYmFzZVBhdGgub2xkUG9zICsgMSA+PSBvbGRMZW4pIHtcbiAgICAgICAgICAgIG1heERpYWdvbmFsVG9Db25zaWRlciA9IE1hdGgubWluKG1heERpYWdvbmFsVG9Db25zaWRlciwgZGlhZ29uYWxQYXRoIC0gMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5ld1BvcyArIDEgPj0gbmV3TGVuKSB7XG4gICAgICAgICAgICBtaW5EaWFnb25hbFRvQ29uc2lkZXIgPSBNYXRoLm1heChtaW5EaWFnb25hbFRvQ29uc2lkZXIsIGRpYWdvbmFsUGF0aCArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlZGl0TGVuZ3RoKys7XG4gICAgfSAvLyBQZXJmb3JtcyB0aGUgbGVuZ3RoIG9mIGVkaXQgaXRlcmF0aW9uLiBJcyBhIGJpdCBmdWdseSBhcyB0aGlzIGhhcyB0byBzdXBwb3J0IHRoZVxuICAgIC8vIHN5bmMgYW5kIGFzeW5jIG1vZGUgd2hpY2ggaXMgbmV2ZXIgZnVuLiBMb29wcyBvdmVyIGV4ZWNFZGl0TGVuZ3RoIHVudGlsIGEgdmFsdWVcbiAgICAvLyBpcyBwcm9kdWNlZCwgb3IgdW50aWwgdGhlIGVkaXQgbGVuZ3RoIGV4Y2VlZHMgb3B0aW9ucy5tYXhFZGl0TGVuZ3RoIChpZiBnaXZlbiksXG4gICAgLy8gaW4gd2hpY2ggY2FzZSBpdCB3aWxsIHJldHVybiB1bmRlZmluZWQuXG5cblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgKGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChlZGl0TGVuZ3RoID4gbWF4RWRpdExlbmd0aCB8fCBEYXRlLm5vdygpID4gYWJvcnRBZnRlclRpbWVzdGFtcCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFleGVjRWRpdExlbmd0aCgpKSB7XG4gICAgICAgICAgICBleGVjKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0pKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChlZGl0TGVuZ3RoIDw9IG1heEVkaXRMZW5ndGggJiYgRGF0ZS5ub3coKSA8PSBhYm9ydEFmdGVyVGltZXN0YW1wKSB7XG4gICAgICAgIHZhciByZXQgPSBleGVjRWRpdExlbmd0aCgpO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBhZGRUb1BhdGg6IGZ1bmN0aW9uIGFkZFRvUGF0aChwYXRoLCBhZGRlZCwgcmVtb3ZlZCwgb2xkUG9zSW5jKSB7XG4gICAgdmFyIGxhc3QgPSBwYXRoLmxhc3RDb21wb25lbnQ7XG5cbiAgICBpZiAobGFzdCAmJiBsYXN0LmFkZGVkID09PSBhZGRlZCAmJiBsYXN0LnJlbW92ZWQgPT09IHJlbW92ZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9sZFBvczogcGF0aC5vbGRQb3MgKyBvbGRQb3NJbmMsXG4gICAgICAgIGxhc3RDb21wb25lbnQ6IHtcbiAgICAgICAgICBjb3VudDogbGFzdC5jb3VudCArIDEsXG4gICAgICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgICAgICAgcHJldmlvdXNDb21wb25lbnQ6IGxhc3QucHJldmlvdXNDb21wb25lbnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2xkUG9zOiBwYXRoLm9sZFBvcyArIG9sZFBvc0luYyxcbiAgICAgICAgbGFzdENvbXBvbmVudDoge1xuICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgIGFkZGVkOiBhZGRlZCxcbiAgICAgICAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgICAgICAgIHByZXZpb3VzQ29tcG9uZW50OiBsYXN0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBleHRyYWN0Q29tbW9uOiBmdW5jdGlvbiBleHRyYWN0Q29tbW9uKGJhc2VQYXRoLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgZGlhZ29uYWxQYXRoKSB7XG4gICAgdmFyIG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsXG4gICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGgsXG4gICAgICAgIG9sZFBvcyA9IGJhc2VQYXRoLm9sZFBvcyxcbiAgICAgICAgbmV3UG9zID0gb2xkUG9zIC0gZGlhZ29uYWxQYXRoLFxuICAgICAgICBjb21tb25Db3VudCA9IDA7XG5cbiAgICB3aGlsZSAobmV3UG9zICsgMSA8IG5ld0xlbiAmJiBvbGRQb3MgKyAxIDwgb2xkTGVuICYmIHRoaXMuZXF1YWxzKG5ld1N0cmluZ1tuZXdQb3MgKyAxXSwgb2xkU3RyaW5nW29sZFBvcyArIDFdKSkge1xuICAgICAgbmV3UG9zKys7XG4gICAgICBvbGRQb3MrKztcbiAgICAgIGNvbW1vbkNvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKGNvbW1vbkNvdW50KSB7XG4gICAgICBiYXNlUGF0aC5sYXN0Q29tcG9uZW50ID0ge1xuICAgICAgICBjb3VudDogY29tbW9uQ291bnQsXG4gICAgICAgIHByZXZpb3VzQ29tcG9uZW50OiBiYXNlUGF0aC5sYXN0Q29tcG9uZW50XG4gICAgICB9O1xuICAgIH1cblxuICAgIGJhc2VQYXRoLm9sZFBvcyA9IG9sZFBvcztcbiAgICByZXR1cm4gbmV3UG9zO1xuICB9LFxuICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jb21wYXJhdG9yKGxlZnQsIHJpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IHRoaXMub3B0aW9ucy5pZ25vcmVDYXNlICYmIGxlZnQudG9Mb3dlckNhc2UoKSA9PT0gcmlnaHQudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZUVtcHR5OiBmdW5jdGlvbiByZW1vdmVFbXB0eShhcnJheSkge1xuICAgIHZhciByZXQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJheVtpXSkge1xuICAgICAgICByZXQucHVzaChhcnJheVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgY2FzdElucHV0OiBmdW5jdGlvbiBjYXN0SW5wdXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIHRva2VuaXplOiBmdW5jdGlvbiB0b2tlbml6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnJyk7XG4gIH0sXG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oY2hhcnMpIHtcbiAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJ1aWxkVmFsdWVzKGRpZmYsIGxhc3RDb21wb25lbnQsIG5ld1N0cmluZywgb2xkU3RyaW5nLCB1c2VMb25nZXN0VG9rZW4pIHtcbiAgLy8gRmlyc3Qgd2UgY29udmVydCBvdXIgbGlua2VkIGxpc3Qgb2YgY29tcG9uZW50cyBpbiByZXZlcnNlIG9yZGVyIHRvIGFuXG4gIC8vIGFycmF5IGluIHRoZSByaWdodCBvcmRlcjpcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgdmFyIG5leHRDb21wb25lbnQ7XG5cbiAgd2hpbGUgKGxhc3RDb21wb25lbnQpIHtcbiAgICBjb21wb25lbnRzLnB1c2gobGFzdENvbXBvbmVudCk7XG4gICAgbmV4dENvbXBvbmVudCA9IGxhc3RDb21wb25lbnQucHJldmlvdXNDb21wb25lbnQ7XG4gICAgZGVsZXRlIGxhc3RDb21wb25lbnQucHJldmlvdXNDb21wb25lbnQ7XG4gICAgbGFzdENvbXBvbmVudCA9IG5leHRDb21wb25lbnQ7XG4gIH1cblxuICBjb21wb25lbnRzLnJldmVyc2UoKTtcbiAgdmFyIGNvbXBvbmVudFBvcyA9IDAsXG4gICAgICBjb21wb25lbnRMZW4gPSBjb21wb25lbnRzLmxlbmd0aCxcbiAgICAgIG5ld1BvcyA9IDAsXG4gICAgICBvbGRQb3MgPSAwO1xuXG4gIGZvciAoOyBjb21wb25lbnRQb3MgPCBjb21wb25lbnRMZW47IGNvbXBvbmVudFBvcysrKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcblxuICAgIGlmICghY29tcG9uZW50LnJlbW92ZWQpIHtcbiAgICAgIGlmICghY29tcG9uZW50LmFkZGVkICYmIHVzZUxvbmdlc3RUb2tlbikge1xuICAgICAgICB2YXIgdmFsdWUgPSBuZXdTdHJpbmcuc2xpY2UobmV3UG9zLCBuZXdQb3MgKyBjb21wb25lbnQuY291bnQpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBvbGRTdHJpbmdbb2xkUG9zICsgaV07XG4gICAgICAgICAgcmV0dXJuIG9sZFZhbHVlLmxlbmd0aCA+IHZhbHVlLmxlbmd0aCA/IG9sZFZhbHVlIDogdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4odmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCkpO1xuICAgICAgfVxuXG4gICAgICBuZXdQb3MgKz0gY29tcG9uZW50LmNvdW50OyAvLyBDb21tb24gY2FzZVxuXG4gICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCkge1xuICAgICAgICBvbGRQb3MgKz0gY29tcG9uZW50LmNvdW50O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4ob2xkU3RyaW5nLnNsaWNlKG9sZFBvcywgb2xkUG9zICsgY29tcG9uZW50LmNvdW50KSk7XG4gICAgICBvbGRQb3MgKz0gY29tcG9uZW50LmNvdW50OyAvLyBSZXZlcnNlIGFkZCBhbmQgcmVtb3ZlIHNvIHJlbW92ZXMgYXJlIG91dHB1dCBmaXJzdCB0byBtYXRjaCBjb21tb24gY29udmVudGlvblxuICAgICAgLy8gVGhlIGRpZmZpbmcgYWxnb3JpdGhtIGlzIHRpZWQgdG8gYWRkIHRoZW4gcmVtb3ZlIG91dHB1dCBhbmQgdGhpcyBpcyB0aGUgc2ltcGxlc3RcbiAgICAgIC8vIHJvdXRlIHRvIGdldCB0aGUgZGVzaXJlZCBvdXRwdXQgd2l0aCBtaW5pbWFsIG92ZXJoZWFkLlxuXG4gICAgICBpZiAoY29tcG9uZW50UG9zICYmIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0uYWRkZWQpIHtcbiAgICAgICAgdmFyIHRtcCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV07XG4gICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0gPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XG4gICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zXSA9IHRtcDtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gU3BlY2lhbCBjYXNlIGhhbmRsZSBmb3Igd2hlbiBvbmUgdGVybWluYWwgaXMgaWdub3JlZCAoaS5lLiB3aGl0ZXNwYWNlKS5cbiAgLy8gRm9yIHRoaXMgY2FzZSB3ZSBtZXJnZSB0aGUgdGVybWluYWwgaW50byB0aGUgcHJpb3Igc3RyaW5nIGFuZCBkcm9wIHRoZSBjaGFuZ2UuXG4gIC8vIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIHN0cmluZyBtb2RlLlxuXG5cbiAgdmFyIGZpbmFsQ29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAxXTtcblxuICBpZiAoY29tcG9uZW50TGVuID4gMSAmJiB0eXBlb2YgZmluYWxDb21wb25lbnQudmFsdWUgPT09ICdzdHJpbmcnICYmIChmaW5hbENvbXBvbmVudC5hZGRlZCB8fCBmaW5hbENvbXBvbmVudC5yZW1vdmVkKSAmJiBkaWZmLmVxdWFscygnJywgZmluYWxDb21wb25lbnQudmFsdWUpKSB7XG4gICAgY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAyXS52YWx1ZSArPSBmaW5hbENvbXBvbmVudC52YWx1ZTtcbiAgICBjb21wb25lbnRzLnBvcCgpO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBvbmVudHM7XG59XG5cbnZhciBjaGFyYWN0ZXJEaWZmID0gbmV3IERpZmYoKTtcbmZ1bmN0aW9uIGRpZmZDaGFycyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICByZXR1cm4gY2hhcmFjdGVyRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRlZmF1bHRzLmNhbGxiYWNrID0gb3B0aW9ucztcbiAgfSBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgZGVmYXVsdHNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0cztcbn1cblxuLy9cbi8vIFJhbmdlcyBhbmQgZXhjZXB0aW9uczpcbi8vIExhdGluLTEgU3VwcGxlbWVudCwgMDA4MOKAkzAwRkZcbi8vICAtIFUrMDBENyAgw5cgTXVsdGlwbGljYXRpb24gc2lnblxuLy8gIC0gVSswMEY3ICDDtyBEaXZpc2lvbiBzaWduXG4vLyBMYXRpbiBFeHRlbmRlZC1BLCAwMTAw4oCTMDE3RlxuLy8gTGF0aW4gRXh0ZW5kZWQtQiwgMDE4MOKAkzAyNEZcbi8vIElQQSBFeHRlbnNpb25zLCAwMjUw4oCTMDJBRlxuLy8gU3BhY2luZyBNb2RpZmllciBMZXR0ZXJzLCAwMkIw4oCTMDJGRlxuLy8gIC0gVSswMkM3ICDLhyAmIzcxMTsgIENhcm9uXG4vLyAgLSBVKzAyRDggIMuYICYjNzI4OyAgQnJldmVcbi8vICAtIFUrMDJEOSAgy5kgJiM3Mjk7ICBEb3QgQWJvdmVcbi8vICAtIFUrMDJEQSAgy5ogJiM3MzA7ICBSaW5nIEFib3ZlXG4vLyAgLSBVKzAyREIgIMubICYjNzMxOyAgT2dvbmVrXG4vLyAgLSBVKzAyREMgIMucICYjNzMyOyAgU21hbGwgVGlsZGVcbi8vICAtIFUrMDJERCAgy50gJiM3MzM7ICBEb3VibGUgQWN1dGUgQWNjZW50XG4vLyBMYXRpbiBFeHRlbmRlZCBBZGRpdGlvbmFsLCAxRTAw4oCTMUVGRlxuXG52YXIgZXh0ZW5kZWRXb3JkQ2hhcnMgPSAvXltBLVphLXpcXHhDMC1cXHUwMkM2XFx1MDJDOC1cXHUwMkQ3XFx1MDJERS1cXHUwMkZGXFx1MUUwMC1cXHUxRUZGXSskLztcbnZhciByZVdoaXRlc3BhY2UgPSAvXFxTLztcbnZhciB3b3JkRGlmZiA9IG5ldyBEaWZmKCk7XG5cbndvcmREaWZmLmVxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUNhc2UpIHtcbiAgICBsZWZ0ID0gbGVmdC50b0xvd2VyQ2FzZSgpO1xuICAgIHJpZ2h0ID0gcmlnaHQudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCB0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSAmJiAhcmVXaGl0ZXNwYWNlLnRlc3QobGVmdCkgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KHJpZ2h0KTtcbn07XG5cbndvcmREaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIC8vIEFsbCB3aGl0ZXNwYWNlIHN5bWJvbHMgZXhjZXB0IG5ld2xpbmUgZ3JvdXAgaW50byBvbmUgdG9rZW4sIGVhY2ggbmV3bGluZSAtIGluIHNlcGFyYXRlIHRva2VuXG4gIHZhciB0b2tlbnMgPSB2YWx1ZS5zcGxpdCgvKFteXFxTXFxyXFxuXSt8WygpW1xcXXt9J1wiXFxyXFxuXXxcXGIpLyk7IC8vIEpvaW4gdGhlIGJvdW5kYXJ5IHNwbGl0cyB0aGF0IHdlIGRvIG5vdCBjb25zaWRlciB0byBiZSBib3VuZGFyaWVzLiBUaGlzIGlzIHByaW1hcmlseSB0aGUgZXh0ZW5kZWQgTGF0aW4gY2hhcmFjdGVyIHNldC5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGVtcHR5IHN0cmluZyBpbiB0aGUgbmV4dCBmaWVsZCBhbmQgd2UgaGF2ZSBvbmx5IHdvcmQgY2hhcnMgYmVmb3JlIGFuZCBhZnRlciwgbWVyZ2VcbiAgICBpZiAoIXRva2Vuc1tpICsgMV0gJiYgdG9rZW5zW2kgKyAyXSAmJiBleHRlbmRlZFdvcmRDaGFycy50ZXN0KHRva2Vuc1tpXSkgJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaSArIDJdKSkge1xuICAgICAgdG9rZW5zW2ldICs9IHRva2Vuc1tpICsgMl07XG4gICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAyKTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufTtcblxuZnVuY3Rpb24gZGlmZldvcmRzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnMob3B0aW9ucywge1xuICAgIGlnbm9yZVdoaXRlc3BhY2U6IHRydWVcbiAgfSk7XG4gIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRpZmZXb3Jkc1dpdGhTcGFjZShvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICByZXR1cm4gd29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG5cbnZhciBsaW5lRGlmZiA9IG5ldyBEaWZmKCk7XG5cbmxpbmVEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuc3RyaXBUcmFpbGluZ0NyKSB7XG4gICAgLy8gcmVtb3ZlIG9uZSBcXHIgYmVmb3JlIFxcbiB0byBtYXRjaCBHTlUgZGlmZidzIC0tc3RyaXAtdHJhaWxpbmctY3IgYmVoYXZpb3JcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG4gIH1cblxuICB2YXIgcmV0TGluZXMgPSBbXSxcbiAgICAgIGxpbmVzQW5kTmV3bGluZXMgPSB2YWx1ZS5zcGxpdCgvKFxcbnxcXHJcXG4pLyk7IC8vIElnbm9yZSB0aGUgZmluYWwgZW1wdHkgdG9rZW4gdGhhdCBvY2N1cnMgaWYgdGhlIHN0cmluZyBlbmRzIHdpdGggYSBuZXcgbGluZVxuXG4gIGlmICghbGluZXNBbmROZXdsaW5lc1tsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aCAtIDFdKSB7XG4gICAgbGluZXNBbmROZXdsaW5lcy5wb3AoKTtcbiAgfSAvLyBNZXJnZSB0aGUgY29udGVudCBhbmQgbGluZSBzZXBhcmF0b3JzIGludG8gc2luZ2xlIHRva2Vuc1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc0FuZE5ld2xpbmVzW2ldO1xuXG4gICAgaWYgKGkgJSAyICYmICF0aGlzLm9wdGlvbnMubmV3bGluZUlzVG9rZW4pIHtcbiAgICAgIHJldExpbmVzW3JldExpbmVzLmxlbmd0aCAtIDFdICs9IGxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSkge1xuICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIHJldExpbmVzLnB1c2gobGluZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldExpbmVzO1xufTtcblxuZnVuY3Rpb24gZGlmZkxpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICByZXR1cm4gbGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZGlmZlRyaW1tZWRMaW5lcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcbiAgdmFyIG9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnMoY2FsbGJhY2ssIHtcbiAgICBpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gbGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG5cbnZhciBzZW50ZW5jZURpZmYgPSBuZXcgRGlmZigpO1xuXG5zZW50ZW5jZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oXFxTLis/Wy4hP10pKD89XFxzK3wkKS8pO1xufTtcblxuZnVuY3Rpb24gZGlmZlNlbnRlbmNlcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHNlbnRlbmNlRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XG59XG5cbnZhciBjc3NEaWZmID0gbmV3IERpZmYoKTtcblxuY3NzRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoLyhbe306OyxdfFxccyspLyk7XG59O1xuXG5mdW5jdGlvbiBkaWZmQ3NzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICByZXR1cm4gY3NzRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbnZhciBvYmplY3RQcm90b3R5cGVUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIganNvbkRpZmYgPSBuZXcgRGlmZigpOyAvLyBEaXNjcmltaW5hdGUgYmV0d2VlbiB0d28gbGluZXMgb2YgcHJldHR5LXByaW50ZWQsIHNlcmlhbGl6ZWQgSlNPTiB3aGVyZSBvbmUgb2YgdGhlbSBoYXMgYVxuLy8gZGFuZ2xpbmcgY29tbWEgYW5kIHRoZSBvdGhlciBkb2Vzbid0LiBUdXJucyBvdXQgaW5jbHVkaW5nIHRoZSBkYW5nbGluZyBjb21tYSB5aWVsZHMgdGhlIG5pY2VzdCBvdXRwdXQ6XG5cbmpzb25EaWZmLnVzZUxvbmdlc3RUb2tlbiA9IHRydWU7XG5qc29uRGlmZi50b2tlbml6ZSA9IGxpbmVEaWZmLnRva2VuaXplO1xuXG5qc29uRGlmZi5jYXN0SW5wdXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICB1bmRlZmluZWRSZXBsYWNlbWVudCA9IF90aGlzJG9wdGlvbnMudW5kZWZpbmVkUmVwbGFjZW1lbnQsXG4gICAgICBfdGhpcyRvcHRpb25zJHN0cmluZ2kgPSBfdGhpcyRvcHRpb25zLnN0cmluZ2lmeVJlcGxhY2VyLFxuICAgICAgc3RyaW5naWZ5UmVwbGFjZXIgPSBfdGhpcyRvcHRpb25zJHN0cmluZ2kgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZFJlcGxhY2VtZW50IDogdjtcbiAgfSA6IF90aGlzJG9wdGlvbnMkc3RyaW5naTtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KGNhbm9uaWNhbGl6ZSh2YWx1ZSwgbnVsbCwgbnVsbCwgc3RyaW5naWZ5UmVwbGFjZXIpLCBzdHJpbmdpZnlSZXBsYWNlciwgJyAgJyk7XG59O1xuXG5qc29uRGlmZi5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIERpZmYucHJvdG90eXBlLmVxdWFscy5jYWxsKGpzb25EaWZmLCBsZWZ0LnJlcGxhY2UoLywoW1xcclxcbl0pL2csICckMScpLCByaWdodC5yZXBsYWNlKC8sKFtcXHJcXG5dKS9nLCAnJDEnKSk7XG59O1xuXG5mdW5jdGlvbiBkaWZmSnNvbihvbGRPYmosIG5ld09iaiwgb3B0aW9ucykge1xuICByZXR1cm4ganNvbkRpZmYuZGlmZihvbGRPYmosIG5ld09iaiwgb3B0aW9ucyk7XG59IC8vIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyB0aGUgcHJlc2VuY2Ugb2YgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSBiYWlsaW5nIG91dCB3aGVuIGVuY291bnRlcmluZyBhblxuLy8gb2JqZWN0IHRoYXQgaXMgYWxyZWFkeSBvbiB0aGUgXCJzdGFja1wiIG9mIGl0ZW1zIGJlaW5nIHByb2Nlc3NlZC4gQWNjZXB0cyBhbiBvcHRpb25hbCByZXBsYWNlclxuXG5mdW5jdGlvbiBjYW5vbmljYWxpemUob2JqLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaywgcmVwbGFjZXIsIGtleSkge1xuICBzdGFjayA9IHN0YWNrIHx8IFtdO1xuICByZXBsYWNlbWVudFN0YWNrID0gcmVwbGFjZW1lbnRTdGFjayB8fCBbXTtcblxuICBpZiAocmVwbGFjZXIpIHtcbiAgICBvYmogPSByZXBsYWNlcihrZXksIG9iaik7XG4gIH1cblxuICB2YXIgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoc3RhY2tbaV0gPT09IG9iaikge1xuICAgICAgcmV0dXJuIHJlcGxhY2VtZW50U3RhY2tbaV07XG4gICAgfVxuICB9XG5cbiAgdmFyIGNhbm9uaWNhbGl6ZWRPYmo7XG5cbiAgaWYgKCdbb2JqZWN0IEFycmF5XScgPT09IG9iamVjdFByb3RvdHlwZVRvU3RyaW5nLmNhbGwob2JqKSkge1xuICAgIHN0YWNrLnB1c2gob2JqKTtcbiAgICBjYW5vbmljYWxpemVkT2JqID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xuICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmpbaV0gPSBjYW5vbmljYWxpemUob2JqW2ldLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaywgcmVwbGFjZXIsIGtleSk7XG4gICAgfVxuXG4gICAgc3RhY2sucG9wKCk7XG4gICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbiAgfVxuXG4gIGlmIChvYmogJiYgb2JqLnRvSlNPTikge1xuICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgfVxuXG4gIGlmIChfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgIHN0YWNrLnB1c2gob2JqKTtcbiAgICBjYW5vbmljYWxpemVkT2JqID0ge307XG4gICAgcmVwbGFjZW1lbnRTdGFjay5wdXNoKGNhbm9uaWNhbGl6ZWRPYmopO1xuXG4gICAgdmFyIHNvcnRlZEtleXMgPSBbXSxcbiAgICAgICAgX2tleTtcblxuICAgIGZvciAoX2tleSBpbiBvYmopIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KF9rZXkpKSB7XG4gICAgICAgIHNvcnRlZEtleXMucHVzaChfa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzb3J0ZWRLZXlzLnNvcnQoKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3J0ZWRLZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBfa2V5ID0gc29ydGVkS2V5c1tpXTtcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmpbX2tleV0gPSBjYW5vbmljYWxpemUob2JqW19rZXldLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaywgcmVwbGFjZXIsIF9rZXkpO1xuICAgIH1cblxuICAgIHN0YWNrLnBvcCgpO1xuICAgIHJlcGxhY2VtZW50U3RhY2sucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IG9iajtcbiAgfVxuXG4gIHJldHVybiBjYW5vbmljYWxpemVkT2JqO1xufVxuXG52YXIgYXJyYXlEaWZmID0gbmV3IERpZmYoKTtcblxuYXJyYXlEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5zbGljZSgpO1xufTtcblxuYXJyYXlEaWZmLmpvaW4gPSBhcnJheURpZmYucmVtb3ZlRW1wdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuZnVuY3Rpb24gZGlmZkFycmF5cyhvbGRBcnIsIG5ld0FyciwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGFycmF5RGlmZi5kaWZmKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGF0Y2godW5pRGlmZikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBkaWZmc3RyID0gdW5pRGlmZi5zcGxpdCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vKSxcbiAgICAgIGRlbGltaXRlcnMgPSB1bmlEaWZmLm1hdGNoKC9cXHJcXG58W1xcblxcdlxcZlxcclxceDg1XS9nKSB8fCBbXSxcbiAgICAgIGxpc3QgPSBbXSxcbiAgICAgIGkgPSAwO1xuXG4gIGZ1bmN0aW9uIHBhcnNlSW5kZXgoKSB7XG4gICAgdmFyIGluZGV4ID0ge307XG4gICAgbGlzdC5wdXNoKGluZGV4KTsgLy8gUGFyc2UgZGlmZiBtZXRhZGF0YVxuXG4gICAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xuICAgICAgdmFyIGxpbmUgPSBkaWZmc3RyW2ldOyAvLyBGaWxlIGhlYWRlciBmb3VuZCwgZW5kIHBhcnNpbmcgZGlmZiBtZXRhZGF0YVxuXG4gICAgICBpZiAoL14oXFwtXFwtXFwtfFxcK1xcK1xcK3xAQClcXHMvLnRlc3QobGluZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIERpZmYgaW5kZXhcblxuXG4gICAgICB2YXIgaGVhZGVyID0gL14oPzpJbmRleDp8ZGlmZig/OiAtciBcXHcrKSspXFxzKyguKz8pXFxzKiQvLmV4ZWMobGluZSk7XG5cbiAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgaW5kZXguaW5kZXggPSBoZWFkZXJbMV07XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9IC8vIFBhcnNlIGZpbGUgaGVhZGVycyBpZiB0aGV5IGFyZSBkZWZpbmVkLiBVbmlmaWVkIGRpZmYgcmVxdWlyZXMgdGhlbSwgYnV0XG4gICAgLy8gdGhlcmUncyBubyB0ZWNobmljYWwgaXNzdWVzIHRvIGhhdmUgYW4gaXNvbGF0ZWQgaHVuayB3aXRob3V0IGZpbGUgaGVhZGVyXG5cblxuICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7XG4gICAgcGFyc2VGaWxlSGVhZGVyKGluZGV4KTsgLy8gUGFyc2UgaHVua3NcblxuICAgIGluZGV4Lmh1bmtzID0gW107XG5cbiAgICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XG4gICAgICB2YXIgX2xpbmUgPSBkaWZmc3RyW2ldO1xuXG4gICAgICBpZiAoL14oSW5kZXg6fGRpZmZ8XFwtXFwtXFwtfFxcK1xcK1xcKylcXHMvLnRlc3QoX2xpbmUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICgvXkBALy50ZXN0KF9saW5lKSkge1xuICAgICAgICBpbmRleC5odW5rcy5wdXNoKHBhcnNlSHVuaygpKTtcbiAgICAgIH0gZWxzZSBpZiAoX2xpbmUgJiYgb3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgLy8gSWdub3JlIHVuZXhwZWN0ZWQgY29udGVudCB1bmxlc3MgaW4gc3RyaWN0IG1vZGVcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxpbmUgJyArIChpICsgMSkgKyAnICcgKyBKU09OLnN0cmluZ2lmeShfbGluZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBQYXJzZXMgdGhlIC0tLSBhbmQgKysrIGhlYWRlcnMsIGlmIG5vbmUgYXJlIGZvdW5kLCBubyBsaW5lc1xuICAvLyBhcmUgY29uc3VtZWQuXG5cblxuICBmdW5jdGlvbiBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpIHtcbiAgICB2YXIgZmlsZUhlYWRlciA9IC9eKC0tLXxcXCtcXCtcXCspXFxzKyguKikkLy5leGVjKGRpZmZzdHJbaV0pO1xuXG4gICAgaWYgKGZpbGVIZWFkZXIpIHtcbiAgICAgIHZhciBrZXlQcmVmaXggPSBmaWxlSGVhZGVyWzFdID09PSAnLS0tJyA/ICdvbGQnIDogJ25ldyc7XG4gICAgICB2YXIgZGF0YSA9IGZpbGVIZWFkZXJbMl0uc3BsaXQoJ1xcdCcsIDIpO1xuICAgICAgdmFyIGZpbGVOYW1lID0gZGF0YVswXS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuXG4gICAgICBpZiAoL15cIi4qXCIkLy50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgICBmaWxlTmFtZSA9IGZpbGVOYW1lLnN1YnN0cigxLCBmaWxlTmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIH1cblxuICAgICAgaW5kZXhba2V5UHJlZml4ICsgJ0ZpbGVOYW1lJ10gPSBmaWxlTmFtZTtcbiAgICAgIGluZGV4W2tleVByZWZpeCArICdIZWFkZXInXSA9IChkYXRhWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICBpKys7XG4gICAgfVxuICB9IC8vIFBhcnNlcyBhIGh1bmtcbiAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgd2UgYXJlIGF0IHRoZSBzdGFydCBvZiBhIGh1bmsuXG5cblxuICBmdW5jdGlvbiBwYXJzZUh1bmsoKSB7XG4gICAgdmFyIGNodW5rSGVhZGVySW5kZXggPSBpLFxuICAgICAgICBjaHVua0hlYWRlckxpbmUgPSBkaWZmc3RyW2krK10sXG4gICAgICAgIGNodW5rSGVhZGVyID0gY2h1bmtIZWFkZXJMaW5lLnNwbGl0KC9AQCAtKFxcZCspKD86LChcXGQrKSk/IFxcKyhcXGQrKSg/OiwoXFxkKykpPyBAQC8pO1xuICAgIHZhciBodW5rID0ge1xuICAgICAgb2xkU3RhcnQ6ICtjaHVua0hlYWRlclsxXSxcbiAgICAgIG9sZExpbmVzOiB0eXBlb2YgY2h1bmtIZWFkZXJbMl0gPT09ICd1bmRlZmluZWQnID8gMSA6ICtjaHVua0hlYWRlclsyXSxcbiAgICAgIG5ld1N0YXJ0OiArY2h1bmtIZWFkZXJbM10sXG4gICAgICBuZXdMaW5lczogdHlwZW9mIGNodW5rSGVhZGVyWzRdID09PSAndW5kZWZpbmVkJyA/IDEgOiArY2h1bmtIZWFkZXJbNF0sXG4gICAgICBsaW5lczogW10sXG4gICAgICBsaW5lZGVsaW1pdGVyczogW11cbiAgICB9OyAvLyBVbmlmaWVkIERpZmYgRm9ybWF0IHF1aXJrOiBJZiB0aGUgY2h1bmsgc2l6ZSBpcyAwLFxuICAgIC8vIHRoZSBmaXJzdCBudW1iZXIgaXMgb25lIGxvd2VyIHRoYW4gb25lIHdvdWxkIGV4cGVjdC5cbiAgICAvLyBodHRwczovL3d3dy5hcnRpbWEuY29tL3dlYmxvZ3Mvdmlld3Bvc3QuanNwP3RocmVhZD0xNjQyOTNcblxuICAgIGlmIChodW5rLm9sZExpbmVzID09PSAwKSB7XG4gICAgICBodW5rLm9sZFN0YXJ0ICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKGh1bmsubmV3TGluZXMgPT09IDApIHtcbiAgICAgIGh1bmsubmV3U3RhcnQgKz0gMTtcbiAgICB9XG5cbiAgICB2YXIgYWRkQ291bnQgPSAwLFxuICAgICAgICByZW1vdmVDb3VudCA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGRpZmZzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggJy0tLScgY291bGQgYmUgbWlzdGFrZW4gZm9yIHRoZSBcInJlbW92ZSBsaW5lXCIgb3BlcmF0aW9uXG4gICAgICAvLyBCdXQgdGhleSBjb3VsZCBiZSB0aGUgaGVhZGVyIGZvciB0aGUgbmV4dCBmaWxlLiBUaGVyZWZvcmUgcHJ1bmUgc3VjaCBjYXNlcyBvdXQuXG4gICAgICBpZiAoZGlmZnN0cltpXS5pbmRleE9mKCctLS0gJykgPT09IDAgJiYgaSArIDIgPCBkaWZmc3RyLmxlbmd0aCAmJiBkaWZmc3RyW2kgKyAxXS5pbmRleE9mKCcrKysgJykgPT09IDAgJiYgZGlmZnN0cltpICsgMl0uaW5kZXhPZignQEAnKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIG9wZXJhdGlvbiA9IGRpZmZzdHJbaV0ubGVuZ3RoID09IDAgJiYgaSAhPSBkaWZmc3RyLmxlbmd0aCAtIDEgPyAnICcgOiBkaWZmc3RyW2ldWzBdO1xuXG4gICAgICBpZiAob3BlcmF0aW9uID09PSAnKycgfHwgb3BlcmF0aW9uID09PSAnLScgfHwgb3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnXFxcXCcpIHtcbiAgICAgICAgaHVuay5saW5lcy5wdXNoKGRpZmZzdHJbaV0pO1xuICAgICAgICBodW5rLmxpbmVkZWxpbWl0ZXJzLnB1c2goZGVsaW1pdGVyc1tpXSB8fCAnXFxuJyk7XG5cbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgICAgYWRkQ291bnQrKztcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnICcpIHtcbiAgICAgICAgICBhZGRDb3VudCsrO1xuICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gSGFuZGxlIHRoZSBlbXB0eSBibG9jayBjb3VudCBjYXNlXG5cblxuICAgIGlmICghYWRkQ291bnQgJiYgaHVuay5uZXdMaW5lcyA9PT0gMSkge1xuICAgICAgaHVuay5uZXdMaW5lcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCFyZW1vdmVDb3VudCAmJiBodW5rLm9sZExpbmVzID09PSAxKSB7XG4gICAgICBodW5rLm9sZExpbmVzID0gMDtcbiAgICB9IC8vIFBlcmZvcm0gb3B0aW9uYWwgc2FuaXR5IGNoZWNraW5nXG5cblxuICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xuICAgICAgaWYgKGFkZENvdW50ICE9PSBodW5rLm5ld0xpbmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWRkZWQgbGluZSBjb3VudCBkaWQgbm90IG1hdGNoIGZvciBodW5rIGF0IGxpbmUgJyArIChjaHVua0hlYWRlckluZGV4ICsgMSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtb3ZlQ291bnQgIT09IGh1bmsub2xkTGluZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdmVkIGxpbmUgY291bnQgZGlkIG5vdCBtYXRjaCBmb3IgaHVuayBhdCBsaW5lICcgKyAoY2h1bmtIZWFkZXJJbmRleCArIDEpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaHVuaztcbiAgfVxuXG4gIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICBwYXJzZUluZGV4KCk7XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn1cblxuLy8gSXRlcmF0b3IgdGhhdCB0cmF2ZXJzZXMgaW4gdGhlIHJhbmdlIG9mIFttaW4sIG1heF0sIHN0ZXBwaW5nXG4vLyBieSBkaXN0YW5jZSBmcm9tIGEgZ2l2ZW4gc3RhcnQgcG9zaXRpb24uIEkuZS4gZm9yIFswLCA0XSwgd2l0aFxuLy8gc3RhcnQgb2YgMiwgdGhpcyB3aWxsIGl0ZXJhdGUgMiwgMywgMSwgNCwgMC5cbmZ1bmN0aW9uIGRpc3RhbmNlSXRlcmF0b3IgKHN0YXJ0LCBtaW5MaW5lLCBtYXhMaW5lKSB7XG4gIHZhciB3YW50Rm9yd2FyZCA9IHRydWUsXG4gICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxuICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxuICAgICAgbG9jYWxPZmZzZXQgPSAxO1xuICByZXR1cm4gZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgaWYgKHdhbnRGb3J3YXJkICYmICFmb3J3YXJkRXhoYXVzdGVkKSB7XG4gICAgICBpZiAoYmFja3dhcmRFeGhhdXN0ZWQpIHtcbiAgICAgICAgbG9jYWxPZmZzZXQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhbnRGb3J3YXJkID0gZmFsc2U7XG4gICAgICB9IC8vIENoZWNrIGlmIHRyeWluZyB0byBmaXQgYmV5b25kIHRleHQgbGVuZ3RoLCBhbmQgaWYgbm90LCBjaGVjayBpdCBmaXRzXG4gICAgICAvLyBhZnRlciBvZmZzZXQgbG9jYXRpb24gKG9yIGRlc2lyZWQgbG9jYXRpb24gb24gZmlyc3QgaXRlcmF0aW9uKVxuXG5cbiAgICAgIGlmIChzdGFydCArIGxvY2FsT2Zmc2V0IDw9IG1heExpbmUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBmb3J3YXJkRXhoYXVzdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWJhY2t3YXJkRXhoYXVzdGVkKSB7XG4gICAgICBpZiAoIWZvcndhcmRFeGhhdXN0ZWQpIHtcbiAgICAgICAgd2FudEZvcndhcmQgPSB0cnVlO1xuICAgICAgfSAvLyBDaGVjayBpZiB0cnlpbmcgdG8gZml0IGJlZm9yZSB0ZXh0IGJlZ2lubmluZywgYW5kIGlmIG5vdCwgY2hlY2sgaXQgZml0c1xuICAgICAgLy8gYmVmb3JlIG9mZnNldCBsb2NhdGlvblxuXG5cbiAgICAgIGlmIChtaW5MaW5lIDw9IHN0YXJ0IC0gbG9jYWxPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIC1sb2NhbE9mZnNldCsrO1xuICAgICAgfVxuXG4gICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IHRydWU7XG4gICAgICByZXR1cm4gaXRlcmF0b3IoKTtcbiAgICB9IC8vIFdlIHRyaWVkIHRvIGZpdCBodW5rIGJlZm9yZSB0ZXh0IGJlZ2lubmluZyBhbmQgYmV5b25kIHRleHQgbGVuZ3RoLCB0aGVuXG4gICAgLy8gaHVuayBjYW4ndCBmaXQgb24gdGhlIHRleHQuIFJldHVybiB1bmRlZmluZWRcblxuICB9O1xufVxuXG5mdW5jdGlvbiBhcHBseVBhdGNoKHNvdXJjZSwgdW5pRGlmZikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgaWYgKHR5cGVvZiB1bmlEaWZmID09PSAnc3RyaW5nJykge1xuICAgIHVuaURpZmYgPSBwYXJzZVBhdGNoKHVuaURpZmYpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodW5pRGlmZikpIHtcbiAgICBpZiAodW5pRGlmZi5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FwcGx5UGF0Y2ggb25seSB3b3JrcyB3aXRoIGEgc2luZ2xlIGlucHV0LicpO1xuICAgIH1cblxuICAgIHVuaURpZmYgPSB1bmlEaWZmWzBdO1xuICB9IC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBpbnB1dFxuXG5cbiAgdmFyIGxpbmVzID0gc291cmNlLnNwbGl0KC9cXHJcXG58W1xcblxcdlxcZlxcclxceDg1XS8pLFxuICAgICAgZGVsaW1pdGVycyA9IHNvdXJjZS5tYXRjaCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vZykgfHwgW10sXG4gICAgICBodW5rcyA9IHVuaURpZmYuaHVua3MsXG4gICAgICBjb21wYXJlTGluZSA9IG9wdGlvbnMuY29tcGFyZUxpbmUgfHwgZnVuY3Rpb24gKGxpbmVOdW1iZXIsIGxpbmUsIG9wZXJhdGlvbiwgcGF0Y2hDb250ZW50KSB7XG4gICAgcmV0dXJuIGxpbmUgPT09IHBhdGNoQ29udGVudDtcbiAgfSxcbiAgICAgIGVycm9yQ291bnQgPSAwLFxuICAgICAgZnV6ekZhY3RvciA9IG9wdGlvbnMuZnV6ekZhY3RvciB8fCAwLFxuICAgICAgbWluTGluZSA9IDAsXG4gICAgICBvZmZzZXQgPSAwLFxuICAgICAgcmVtb3ZlRU9GTkwsXG4gICAgICBhZGRFT0ZOTDtcbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgaHVuayBleGFjdGx5IGZpdHMgb24gdGhlIHByb3ZpZGVkIGxvY2F0aW9uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaHVua0ZpdHMoaHVuaywgdG9Qb3MpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGh1bmsubGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBsaW5lID0gaHVuay5saW5lc1tqXSxcbiAgICAgICAgICBvcGVyYXRpb24gPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lWzBdIDogJyAnLFxuICAgICAgICAgIGNvbnRlbnQgPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lLnN1YnN0cigxKSA6IGxpbmU7XG5cbiAgICAgIGlmIChvcGVyYXRpb24gPT09ICcgJyB8fCBvcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAvLyBDb250ZXh0IHNhbml0eSBjaGVja1xuICAgICAgICBpZiAoIWNvbXBhcmVMaW5lKHRvUG9zICsgMSwgbGluZXNbdG9Qb3NdLCBvcGVyYXRpb24sIGNvbnRlbnQpKSB7XG4gICAgICAgICAgZXJyb3JDb3VudCsrO1xuXG4gICAgICAgICAgaWYgKGVycm9yQ291bnQgPiBmdXp6RmFjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdG9Qb3MrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBTZWFyY2ggYmVzdCBmaXQgb2Zmc2V0cyBmb3IgZWFjaCBodW5rIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBvbmVzXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGh1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGh1bmsgPSBodW5rc1tpXSxcbiAgICAgICAgbWF4TGluZSA9IGxpbmVzLmxlbmd0aCAtIGh1bmsub2xkTGluZXMsXG4gICAgICAgIGxvY2FsT2Zmc2V0ID0gMCxcbiAgICAgICAgdG9Qb3MgPSBvZmZzZXQgKyBodW5rLm9sZFN0YXJ0IC0gMTtcbiAgICB2YXIgaXRlcmF0b3IgPSBkaXN0YW5jZUl0ZXJhdG9yKHRvUG9zLCBtaW5MaW5lLCBtYXhMaW5lKTtcblxuICAgIGZvciAoOyBsb2NhbE9mZnNldCAhPT0gdW5kZWZpbmVkOyBsb2NhbE9mZnNldCA9IGl0ZXJhdG9yKCkpIHtcbiAgICAgIGlmIChodW5rRml0cyhodW5rLCB0b1BvcyArIGxvY2FsT2Zmc2V0KSkge1xuICAgICAgICBodW5rLm9mZnNldCA9IG9mZnNldCArPSBsb2NhbE9mZnNldDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxvY2FsT2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFNldCBsb3dlciB0ZXh0IGxpbWl0IHRvIGVuZCBvZiB0aGUgY3VycmVudCBodW5rLCBzbyBuZXh0IG9uZXMgZG9uJ3QgdHJ5XG4gICAgLy8gdG8gZml0IG92ZXIgYWxyZWFkeSBwYXRjaGVkIHRleHRcblxuXG4gICAgbWluTGluZSA9IGh1bmsub2Zmc2V0ICsgaHVuay5vbGRTdGFydCArIGh1bmsub2xkTGluZXM7XG4gIH0gLy8gQXBwbHkgcGF0Y2ggaHVua3NcblxuXG4gIHZhciBkaWZmT2Zmc2V0ID0gMDtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaHVua3MubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIF9odW5rID0gaHVua3NbX2ldLFxuICAgICAgICBfdG9Qb3MgPSBfaHVuay5vbGRTdGFydCArIF9odW5rLm9mZnNldCArIGRpZmZPZmZzZXQgLSAxO1xuXG4gICAgZGlmZk9mZnNldCArPSBfaHVuay5uZXdMaW5lcyAtIF9odW5rLm9sZExpbmVzO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBfaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGxpbmUgPSBfaHVuay5saW5lc1tqXSxcbiAgICAgICAgICBvcGVyYXRpb24gPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lWzBdIDogJyAnLFxuICAgICAgICAgIGNvbnRlbnQgPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lLnN1YnN0cigxKSA6IGxpbmUsXG4gICAgICAgICAgZGVsaW1pdGVyID0gX2h1bmsubGluZWRlbGltaXRlcnMgJiYgX2h1bmsubGluZWRlbGltaXRlcnNbal0gfHwgJ1xcbic7XG5cbiAgICAgIGlmIChvcGVyYXRpb24gPT09ICcgJykge1xuICAgICAgICBfdG9Qb3MrKztcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgbGluZXMuc3BsaWNlKF90b1BvcywgMSk7XG4gICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKF90b1BvcywgMSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgIGxpbmVzLnNwbGljZShfdG9Qb3MsIDAsIGNvbnRlbnQpO1xuICAgICAgICBkZWxpbWl0ZXJzLnNwbGljZShfdG9Qb3MsIDAsIGRlbGltaXRlcik7XG4gICAgICAgIF90b1BvcysrO1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICdcXFxcJykge1xuICAgICAgICB2YXIgcHJldmlvdXNPcGVyYXRpb24gPSBfaHVuay5saW5lc1tqIC0gMV0gPyBfaHVuay5saW5lc1tqIC0gMV1bMF0gOiBudWxsO1xuXG4gICAgICAgIGlmIChwcmV2aW91c09wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgICAgcmVtb3ZlRU9GTkwgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzT3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgICBhZGRFT0ZOTCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gSGFuZGxlIEVPRk5MIGluc2VydGlvbi9yZW1vdmFsXG5cblxuICBpZiAocmVtb3ZlRU9GTkwpIHtcbiAgICB3aGlsZSAoIWxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICBsaW5lcy5wb3AoKTtcbiAgICAgIGRlbGltaXRlcnMucG9wKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFkZEVPRk5MKSB7XG4gICAgbGluZXMucHVzaCgnJyk7XG4gICAgZGVsaW1pdGVycy5wdXNoKCdcXG4nKTtcbiAgfVxuXG4gIGZvciAodmFyIF9rID0gMDsgX2sgPCBsaW5lcy5sZW5ndGggLSAxOyBfaysrKSB7XG4gICAgbGluZXNbX2tdID0gbGluZXNbX2tdICsgZGVsaW1pdGVyc1tfa107XG4gIH1cblxuICByZXR1cm4gbGluZXMuam9pbignJyk7XG59IC8vIFdyYXBwZXIgdGhhdCBzdXBwb3J0cyBtdWx0aXBsZSBmaWxlIHBhdGNoZXMgdmlhIGNhbGxiYWNrcy5cblxuZnVuY3Rpb24gYXBwbHlQYXRjaGVzKHVuaURpZmYsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB1bmlEaWZmID09PSAnc3RyaW5nJykge1xuICAgIHVuaURpZmYgPSBwYXJzZVBhdGNoKHVuaURpZmYpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRJbmRleCA9IDA7XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0luZGV4KCkge1xuICAgIHZhciBpbmRleCA9IHVuaURpZmZbY3VycmVudEluZGV4KytdO1xuXG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmxvYWRGaWxlKGluZGV4LCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVkQ29udGVudCA9IGFwcGx5UGF0Y2goZGF0YSwgaW5kZXgsIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5wYXRjaGVkKGluZGV4LCB1cGRhdGVkQ29udGVudCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3NJbmRleCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwcm9jZXNzSW5kZXgoKTtcbn1cblxuZnVuY3Rpb24gc3RydWN0dXJlZFBhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5jb250ZXh0ID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMuY29udGV4dCA9IDQ7XG4gIH1cblxuICB2YXIgZGlmZiA9IGRpZmZMaW5lcyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG5cbiAgaWYgKCFkaWZmKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGlmZi5wdXNoKHtcbiAgICB2YWx1ZTogJycsXG4gICAgbGluZXM6IFtdXG4gIH0pOyAvLyBBcHBlbmQgYW4gZW1wdHkgdmFsdWUgdG8gbWFrZSBjbGVhbnVwIGVhc2llclxuXG4gIGZ1bmN0aW9uIGNvbnRleHRMaW5lcyhsaW5lcykge1xuICAgIHJldHVybiBsaW5lcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICByZXR1cm4gJyAnICsgZW50cnk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaHVua3MgPSBbXTtcbiAgdmFyIG9sZFJhbmdlU3RhcnQgPSAwLFxuICAgICAgbmV3UmFuZ2VTdGFydCA9IDAsXG4gICAgICBjdXJSYW5nZSA9IFtdLFxuICAgICAgb2xkTGluZSA9IDEsXG4gICAgICBuZXdMaW5lID0gMTtcblxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBkaWZmW2ldLFxuICAgICAgICBsaW5lcyA9IGN1cnJlbnQubGluZXMgfHwgY3VycmVudC52YWx1ZS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKTtcbiAgICBjdXJyZW50LmxpbmVzID0gbGluZXM7XG5cbiAgICBpZiAoY3VycmVudC5hZGRlZCB8fCBjdXJyZW50LnJlbW92ZWQpIHtcbiAgICAgIHZhciBfY3VyUmFuZ2U7XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgcHJldmlvdXMgY29udGV4dCwgc3RhcnQgd2l0aCB0aGF0XG4gICAgICBpZiAoIW9sZFJhbmdlU3RhcnQpIHtcbiAgICAgICAgdmFyIHByZXYgPSBkaWZmW2kgLSAxXTtcbiAgICAgICAgb2xkUmFuZ2VTdGFydCA9IG9sZExpbmU7XG4gICAgICAgIG5ld1JhbmdlU3RhcnQgPSBuZXdMaW5lO1xuXG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgY3VyUmFuZ2UgPSBvcHRpb25zLmNvbnRleHQgPiAwID8gY29udGV4dExpbmVzKHByZXYubGluZXMuc2xpY2UoLW9wdGlvbnMuY29udGV4dCkpIDogW107XG4gICAgICAgICAgb2xkUmFuZ2VTdGFydCAtPSBjdXJSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgbmV3UmFuZ2VTdGFydCAtPSBjdXJSYW5nZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gT3V0cHV0IG91ciBjaGFuZ2VzXG5cblxuICAgICAgKF9jdXJSYW5nZSA9IGN1clJhbmdlKS5wdXNoLmFwcGx5KF9jdXJSYW5nZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxpbmVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyZW50LmFkZGVkID8gJysnIDogJy0nKSArIGVudHJ5O1xuICAgICAgfSkpKTsgLy8gVHJhY2sgdGhlIHVwZGF0ZWQgZmlsZSBwb3NpdGlvblxuXG5cbiAgICAgIGlmIChjdXJyZW50LmFkZGVkKSB7XG4gICAgICAgIG5ld0xpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElkZW50aWNhbCBjb250ZXh0IGxpbmVzLiBUcmFjayBsaW5lIGNoYW5nZXNcbiAgICAgIGlmIChvbGRSYW5nZVN0YXJ0KSB7XG4gICAgICAgIC8vIENsb3NlIG91dCBhbnkgY2hhbmdlcyB0aGF0IGhhdmUgYmVlbiBvdXRwdXQgKG9yIGpvaW4gb3ZlcmxhcHBpbmcpXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gb3B0aW9ucy5jb250ZXh0ICogMiAmJiBpIDwgZGlmZi5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgdmFyIF9jdXJSYW5nZTI7XG5cbiAgICAgICAgICAvLyBPdmVybGFwcGluZ1xuICAgICAgICAgIChfY3VyUmFuZ2UyID0gY3VyUmFuZ2UpLnB1c2guYXBwbHkoX2N1clJhbmdlMiwgX3RvQ29uc3VtYWJsZUFycmF5KGNvbnRleHRMaW5lcyhsaW5lcykpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2N1clJhbmdlMztcblxuICAgICAgICAgIC8vIGVuZCB0aGUgcmFuZ2UgYW5kIG91dHB1dFxuICAgICAgICAgIHZhciBjb250ZXh0U2l6ZSA9IE1hdGgubWluKGxpbmVzLmxlbmd0aCwgb3B0aW9ucy5jb250ZXh0KTtcblxuICAgICAgICAgIChfY3VyUmFuZ2UzID0gY3VyUmFuZ2UpLnB1c2guYXBwbHkoX2N1clJhbmdlMywgX3RvQ29uc3VtYWJsZUFycmF5KGNvbnRleHRMaW5lcyhsaW5lcy5zbGljZSgwLCBjb250ZXh0U2l6ZSkpKSk7XG5cbiAgICAgICAgICB2YXIgaHVuayA9IHtcbiAgICAgICAgICAgIG9sZFN0YXJ0OiBvbGRSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgb2xkTGluZXM6IG9sZExpbmUgLSBvbGRSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUsXG4gICAgICAgICAgICBuZXdTdGFydDogbmV3UmFuZ2VTdGFydCxcbiAgICAgICAgICAgIG5ld0xpbmVzOiBuZXdMaW5lIC0gbmV3UmFuZ2VTdGFydCArIGNvbnRleHRTaXplLFxuICAgICAgICAgICAgbGluZXM6IGN1clJhbmdlXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChpID49IGRpZmYubGVuZ3RoIC0gMiAmJiBsaW5lcy5sZW5ndGggPD0gb3B0aW9ucy5jb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBFT0YgaXMgaW5zaWRlIHRoaXMgaHVua1xuICAgICAgICAgICAgdmFyIG9sZEVPRk5ld2xpbmUgPSAvXFxuJC8udGVzdChvbGRTdHIpO1xuICAgICAgICAgICAgdmFyIG5ld0VPRk5ld2xpbmUgPSAvXFxuJC8udGVzdChuZXdTdHIpO1xuICAgICAgICAgICAgdmFyIG5vTmxCZWZvcmVBZGRzID0gbGluZXMubGVuZ3RoID09IDAgJiYgY3VyUmFuZ2UubGVuZ3RoID4gaHVuay5vbGRMaW5lcztcblxuICAgICAgICAgICAgaWYgKCFvbGRFT0ZOZXdsaW5lICYmIG5vTmxCZWZvcmVBZGRzICYmIG9sZFN0ci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogb2xkIGhhcyBubyBlb2wgYW5kIG5vIHRyYWlsaW5nIGNvbnRleHQ7IG5vLW5sIGNhbiBlbmQgdXAgYmVmb3JlIGFkZHNcbiAgICAgICAgICAgICAgLy8gaG93ZXZlciwgaWYgdGhlIG9sZCBmaWxlIGlzIGVtcHR5LCBkbyBub3Qgb3V0cHV0IHRoZSBuby1ubCBsaW5lXG4gICAgICAgICAgICAgIGN1clJhbmdlLnNwbGljZShodW5rLm9sZExpbmVzLCAwLCAnXFxcXCBObyBuZXdsaW5lIGF0IGVuZCBvZiBmaWxlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb2xkRU9GTmV3bGluZSAmJiAhbm9ObEJlZm9yZUFkZHMgfHwgIW5ld0VPRk5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgY3VyUmFuZ2UucHVzaCgnXFxcXCBObyBuZXdsaW5lIGF0IGVuZCBvZiBmaWxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaHVua3MucHVzaChodW5rKTtcbiAgICAgICAgICBvbGRSYW5nZVN0YXJ0ID0gMDtcbiAgICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gMDtcbiAgICAgICAgICBjdXJSYW5nZSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9sZExpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgbmV3TGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xuICAgIF9sb29wKGkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvbGRGaWxlTmFtZTogb2xkRmlsZU5hbWUsXG4gICAgbmV3RmlsZU5hbWU6IG5ld0ZpbGVOYW1lLFxuICAgIG9sZEhlYWRlcjogb2xkSGVhZGVyLFxuICAgIG5ld0hlYWRlcjogbmV3SGVhZGVyLFxuICAgIGh1bmtzOiBodW5rc1xuICB9O1xufVxuZnVuY3Rpb24gZm9ybWF0UGF0Y2goZGlmZikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkaWZmKSkge1xuICAgIHJldHVybiBkaWZmLm1hcChmb3JtYXRQYXRjaCkuam9pbignXFxuJyk7XG4gIH1cblxuICB2YXIgcmV0ID0gW107XG5cbiAgaWYgKGRpZmYub2xkRmlsZU5hbWUgPT0gZGlmZi5uZXdGaWxlTmFtZSkge1xuICAgIHJldC5wdXNoKCdJbmRleDogJyArIGRpZmYub2xkRmlsZU5hbWUpO1xuICB9XG5cbiAgcmV0LnB1c2goJz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0nKTtcbiAgcmV0LnB1c2goJy0tLSAnICsgZGlmZi5vbGRGaWxlTmFtZSArICh0eXBlb2YgZGlmZi5vbGRIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFx0JyArIGRpZmYub2xkSGVhZGVyKSk7XG4gIHJldC5wdXNoKCcrKysgJyArIGRpZmYubmV3RmlsZU5hbWUgKyAodHlwZW9mIGRpZmYubmV3SGVhZGVyID09PSAndW5kZWZpbmVkJyA/ICcnIDogJ1xcdCcgKyBkaWZmLm5ld0hlYWRlcikpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5odW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBodW5rID0gZGlmZi5odW5rc1tpXTsgLy8gVW5pZmllZCBEaWZmIEZvcm1hdCBxdWlyazogSWYgdGhlIGNodW5rIHNpemUgaXMgMCxcbiAgICAvLyB0aGUgZmlyc3QgbnVtYmVyIGlzIG9uZSBsb3dlciB0aGFuIG9uZSB3b3VsZCBleHBlY3QuXG4gICAgLy8gaHR0cHM6Ly93d3cuYXJ0aW1hLmNvbS93ZWJsb2dzL3ZpZXdwb3N0LmpzcD90aHJlYWQ9MTY0MjkzXG5cbiAgICBpZiAoaHVuay5vbGRMaW5lcyA9PT0gMCkge1xuICAgICAgaHVuay5vbGRTdGFydCAtPSAxO1xuICAgIH1cblxuICAgIGlmIChodW5rLm5ld0xpbmVzID09PSAwKSB7XG4gICAgICBodW5rLm5ld1N0YXJ0IC09IDE7XG4gICAgfVxuXG4gICAgcmV0LnB1c2goJ0BAIC0nICsgaHVuay5vbGRTdGFydCArICcsJyArIGh1bmsub2xkTGluZXMgKyAnICsnICsgaHVuay5uZXdTdGFydCArICcsJyArIGh1bmsubmV3TGluZXMgKyAnIEBAJyk7XG4gICAgcmV0LnB1c2guYXBwbHkocmV0LCBodW5rLmxpbmVzKTtcbiAgfVxuXG4gIHJldHVybiByZXQuam9pbignXFxuJykgKyAnXFxuJztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR3b0ZpbGVzUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZvcm1hdFBhdGNoKHN0cnVjdHVyZWRQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0Y2goZmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xuICByZXR1cm4gY3JlYXRlVHdvRmlsZXNQYXRjaChmaWxlTmFtZSwgZmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGFycmF5RXF1YWwoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5U3RhcnRzV2l0aChhLCBiKTtcbn1cbmZ1bmN0aW9uIGFycmF5U3RhcnRzV2l0aChhcnJheSwgc3RhcnQpIHtcbiAgaWYgKHN0YXJ0Lmxlbmd0aCA+IGFycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhcnQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RhcnRbaV0gIT09IGFycmF5W2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNhbGNMaW5lQ291bnQoaHVuaykge1xuICB2YXIgX2NhbGNPbGROZXdMaW5lQ291bnQgPSBjYWxjT2xkTmV3TGluZUNvdW50KGh1bmsubGluZXMpLFxuICAgICAgb2xkTGluZXMgPSBfY2FsY09sZE5ld0xpbmVDb3VudC5vbGRMaW5lcyxcbiAgICAgIG5ld0xpbmVzID0gX2NhbGNPbGROZXdMaW5lQ291bnQubmV3TGluZXM7XG5cbiAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBodW5rLm9sZExpbmVzID0gb2xkTGluZXM7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIGh1bmsub2xkTGluZXM7XG4gIH1cblxuICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGh1bmsubmV3TGluZXMgPSBuZXdMaW5lcztcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgaHVuay5uZXdMaW5lcztcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2UobWluZSwgdGhlaXJzLCBiYXNlKSB7XG4gIG1pbmUgPSBsb2FkUGF0Y2gobWluZSwgYmFzZSk7XG4gIHRoZWlycyA9IGxvYWRQYXRjaCh0aGVpcnMsIGJhc2UpO1xuICB2YXIgcmV0ID0ge307IC8vIEZvciBpbmRleCB3ZSBqdXN0IGxldCBpdCBwYXNzIHRocm91Z2ggYXMgaXQgZG9lc24ndCBoYXZlIGFueSBuZWNlc3NhcnkgbWVhbmluZy5cbiAgLy8gTGVhdmluZyBzYW5pdHkgY2hlY2tzIG9uIHRoaXMgdG8gdGhlIEFQSSBjb25zdW1lciB0aGF0IG1heSBrbm93IG1vcmUgYWJvdXQgdGhlXG4gIC8vIG1lYW5pbmcgaW4gdGhlaXIgb3duIGNvbnRleHQuXG5cbiAgaWYgKG1pbmUuaW5kZXggfHwgdGhlaXJzLmluZGV4KSB7XG4gICAgcmV0LmluZGV4ID0gbWluZS5pbmRleCB8fCB0aGVpcnMuaW5kZXg7XG4gIH1cblxuICBpZiAobWluZS5uZXdGaWxlTmFtZSB8fCB0aGVpcnMubmV3RmlsZU5hbWUpIHtcbiAgICBpZiAoIWZpbGVOYW1lQ2hhbmdlZChtaW5lKSkge1xuICAgICAgLy8gTm8gaGVhZGVyIG9yIG5vIGNoYW5nZSBpbiBvdXJzLCB1c2UgdGhlaXJzIChhbmQgb3VycyBpZiB0aGVpcnMgZG9lcyBub3QgZXhpc3QpXG4gICAgICByZXQub2xkRmlsZU5hbWUgPSB0aGVpcnMub2xkRmlsZU5hbWUgfHwgbWluZS5vbGRGaWxlTmFtZTtcbiAgICAgIHJldC5uZXdGaWxlTmFtZSA9IHRoZWlycy5uZXdGaWxlTmFtZSB8fCBtaW5lLm5ld0ZpbGVOYW1lO1xuICAgICAgcmV0Lm9sZEhlYWRlciA9IHRoZWlycy5vbGRIZWFkZXIgfHwgbWluZS5vbGRIZWFkZXI7XG4gICAgICByZXQubmV3SGVhZGVyID0gdGhlaXJzLm5ld0hlYWRlciB8fCBtaW5lLm5ld0hlYWRlcjtcbiAgICB9IGVsc2UgaWYgKCFmaWxlTmFtZUNoYW5nZWQodGhlaXJzKSkge1xuICAgICAgLy8gTm8gaGVhZGVyIG9yIG5vIGNoYW5nZSBpbiB0aGVpcnMsIHVzZSBvdXJzXG4gICAgICByZXQub2xkRmlsZU5hbWUgPSBtaW5lLm9sZEZpbGVOYW1lO1xuICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gbWluZS5uZXdGaWxlTmFtZTtcbiAgICAgIHJldC5vbGRIZWFkZXIgPSBtaW5lLm9sZEhlYWRlcjtcbiAgICAgIHJldC5uZXdIZWFkZXIgPSBtaW5lLm5ld0hlYWRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQm90aCBjaGFuZ2VkLi4uIGZpZ3VyZSBpdCBvdXRcbiAgICAgIHJldC5vbGRGaWxlTmFtZSA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5vbGRGaWxlTmFtZSwgdGhlaXJzLm9sZEZpbGVOYW1lKTtcbiAgICAgIHJldC5uZXdGaWxlTmFtZSA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5uZXdGaWxlTmFtZSwgdGhlaXJzLm5ld0ZpbGVOYW1lKTtcbiAgICAgIHJldC5vbGRIZWFkZXIgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUub2xkSGVhZGVyLCB0aGVpcnMub2xkSGVhZGVyKTtcbiAgICAgIHJldC5uZXdIZWFkZXIgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUubmV3SGVhZGVyLCB0aGVpcnMubmV3SGVhZGVyKTtcbiAgICB9XG4gIH1cblxuICByZXQuaHVua3MgPSBbXTtcbiAgdmFyIG1pbmVJbmRleCA9IDAsXG4gICAgICB0aGVpcnNJbmRleCA9IDAsXG4gICAgICBtaW5lT2Zmc2V0ID0gMCxcbiAgICAgIHRoZWlyc09mZnNldCA9IDA7XG5cbiAgd2hpbGUgKG1pbmVJbmRleCA8IG1pbmUuaHVua3MubGVuZ3RoIHx8IHRoZWlyc0luZGV4IDwgdGhlaXJzLmh1bmtzLmxlbmd0aCkge1xuICAgIHZhciBtaW5lQ3VycmVudCA9IG1pbmUuaHVua3NbbWluZUluZGV4XSB8fCB7XG4gICAgICBvbGRTdGFydDogSW5maW5pdHlcbiAgICB9LFxuICAgICAgICB0aGVpcnNDdXJyZW50ID0gdGhlaXJzLmh1bmtzW3RoZWlyc0luZGV4XSB8fCB7XG4gICAgICBvbGRTdGFydDogSW5maW5pdHlcbiAgICB9O1xuXG4gICAgaWYgKGh1bmtCZWZvcmUobWluZUN1cnJlbnQsIHRoZWlyc0N1cnJlbnQpKSB7XG4gICAgICAvLyBUaGlzIHBhdGNoIGRvZXMgbm90IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIG90aGVycywgeWF5LlxuICAgICAgcmV0Lmh1bmtzLnB1c2goY2xvbmVIdW5rKG1pbmVDdXJyZW50LCBtaW5lT2Zmc2V0KSk7XG4gICAgICBtaW5lSW5kZXgrKztcbiAgICAgIHRoZWlyc09mZnNldCArPSBtaW5lQ3VycmVudC5uZXdMaW5lcyAtIG1pbmVDdXJyZW50Lm9sZExpbmVzO1xuICAgIH0gZWxzZSBpZiAoaHVua0JlZm9yZSh0aGVpcnNDdXJyZW50LCBtaW5lQ3VycmVudCkpIHtcbiAgICAgIC8vIFRoaXMgcGF0Y2ggZG9lcyBub3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgb3RoZXJzLCB5YXkuXG4gICAgICByZXQuaHVua3MucHVzaChjbG9uZUh1bmsodGhlaXJzQ3VycmVudCwgdGhlaXJzT2Zmc2V0KSk7XG4gICAgICB0aGVpcnNJbmRleCsrO1xuICAgICAgbWluZU9mZnNldCArPSB0aGVpcnNDdXJyZW50Lm5ld0xpbmVzIC0gdGhlaXJzQ3VycmVudC5vbGRMaW5lcztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3ZlcmxhcCwgbWVyZ2UgYXMgYmVzdCB3ZSBjYW5cbiAgICAgIHZhciBtZXJnZWRIdW5rID0ge1xuICAgICAgICBvbGRTdGFydDogTWF0aC5taW4obWluZUN1cnJlbnQub2xkU3RhcnQsIHRoZWlyc0N1cnJlbnQub2xkU3RhcnQpLFxuICAgICAgICBvbGRMaW5lczogMCxcbiAgICAgICAgbmV3U3RhcnQ6IE1hdGgubWluKG1pbmVDdXJyZW50Lm5ld1N0YXJ0ICsgbWluZU9mZnNldCwgdGhlaXJzQ3VycmVudC5vbGRTdGFydCArIHRoZWlyc09mZnNldCksXG4gICAgICAgIG5ld0xpbmVzOiAwLFxuICAgICAgICBsaW5lczogW11cbiAgICAgIH07XG4gICAgICBtZXJnZUxpbmVzKG1lcmdlZEh1bmssIG1pbmVDdXJyZW50Lm9sZFN0YXJ0LCBtaW5lQ3VycmVudC5saW5lcywgdGhlaXJzQ3VycmVudC5vbGRTdGFydCwgdGhlaXJzQ3VycmVudC5saW5lcyk7XG4gICAgICB0aGVpcnNJbmRleCsrO1xuICAgICAgbWluZUluZGV4Kys7XG4gICAgICByZXQuaHVua3MucHVzaChtZXJnZWRIdW5rKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBsb2FkUGF0Y2gocGFyYW0sIGJhc2UpIHtcbiAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoL15AQC9tLnRlc3QocGFyYW0pIHx8IC9eSW5kZXg6L20udGVzdChwYXJhbSkpIHtcbiAgICAgIHJldHVybiBwYXJzZVBhdGNoKHBhcmFtKVswXTtcbiAgICB9XG5cbiAgICBpZiAoIWJhc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGEgYmFzZSByZWZlcmVuY2Ugb3IgcGFzcyBpbiBhIHBhdGNoJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cnVjdHVyZWRQYXRjaCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgYmFzZSwgcGFyYW0pO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtO1xufVxuXG5mdW5jdGlvbiBmaWxlTmFtZUNoYW5nZWQocGF0Y2gpIHtcbiAgcmV0dXJuIHBhdGNoLm5ld0ZpbGVOYW1lICYmIHBhdGNoLm5ld0ZpbGVOYW1lICE9PSBwYXRjaC5vbGRGaWxlTmFtZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0RmllbGQoaW5kZXgsIG1pbmUsIHRoZWlycykge1xuICBpZiAobWluZSA9PT0gdGhlaXJzKSB7XG4gICAgcmV0dXJuIG1pbmU7XG4gIH0gZWxzZSB7XG4gICAgaW5kZXguY29uZmxpY3QgPSB0cnVlO1xuICAgIHJldHVybiB7XG4gICAgICBtaW5lOiBtaW5lLFxuICAgICAgdGhlaXJzOiB0aGVpcnNcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGh1bmtCZWZvcmUodGVzdCwgY2hlY2spIHtcbiAgcmV0dXJuIHRlc3Qub2xkU3RhcnQgPCBjaGVjay5vbGRTdGFydCAmJiB0ZXN0Lm9sZFN0YXJ0ICsgdGVzdC5vbGRMaW5lcyA8IGNoZWNrLm9sZFN0YXJ0O1xufVxuXG5mdW5jdGlvbiBjbG9uZUh1bmsoaHVuaywgb2Zmc2V0KSB7XG4gIHJldHVybiB7XG4gICAgb2xkU3RhcnQ6IGh1bmsub2xkU3RhcnQsXG4gICAgb2xkTGluZXM6IGh1bmsub2xkTGluZXMsXG4gICAgbmV3U3RhcnQ6IGh1bmsubmV3U3RhcnQgKyBvZmZzZXQsXG4gICAgbmV3TGluZXM6IGh1bmsubmV3TGluZXMsXG4gICAgbGluZXM6IGh1bmsubGluZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VMaW5lcyhodW5rLCBtaW5lT2Zmc2V0LCBtaW5lTGluZXMsIHRoZWlyT2Zmc2V0LCB0aGVpckxpbmVzKSB7XG4gIC8vIFRoaXMgd2lsbCBnZW5lcmFsbHkgcmVzdWx0IGluIGEgY29uZmxpY3RlZCBodW5rLCBidXQgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHRoZSBjb250ZXh0XG4gIC8vIGlzIHRoZSBvbmx5IG92ZXJsYXAgd2hlcmUgd2UgY2FuIHN1Y2Nlc3NmdWxseSBtZXJnZSB0aGUgY29udGVudCBoZXJlLlxuICB2YXIgbWluZSA9IHtcbiAgICBvZmZzZXQ6IG1pbmVPZmZzZXQsXG4gICAgbGluZXM6IG1pbmVMaW5lcyxcbiAgICBpbmRleDogMFxuICB9LFxuICAgICAgdGhlaXIgPSB7XG4gICAgb2Zmc2V0OiB0aGVpck9mZnNldCxcbiAgICBsaW5lczogdGhlaXJMaW5lcyxcbiAgICBpbmRleDogMFxuICB9OyAvLyBIYW5kbGUgYW55IGxlYWRpbmcgY29udGVudFxuXG4gIGluc2VydExlYWRpbmcoaHVuaywgbWluZSwgdGhlaXIpO1xuICBpbnNlcnRMZWFkaW5nKGh1bmssIHRoZWlyLCBtaW5lKTsgLy8gTm93IGluIHRoZSBvdmVybGFwIGNvbnRlbnQuIFNjYW4gdGhyb3VnaCBhbmQgc2VsZWN0IHRoZSBiZXN0IGNoYW5nZXMgZnJvbSBlYWNoLlxuXG4gIHdoaWxlIChtaW5lLmluZGV4IDwgbWluZS5saW5lcy5sZW5ndGggJiYgdGhlaXIuaW5kZXggPCB0aGVpci5saW5lcy5sZW5ndGgpIHtcbiAgICB2YXIgbWluZUN1cnJlbnQgPSBtaW5lLmxpbmVzW21pbmUuaW5kZXhdLFxuICAgICAgICB0aGVpckN1cnJlbnQgPSB0aGVpci5saW5lc1t0aGVpci5pbmRleF07XG5cbiAgICBpZiAoKG1pbmVDdXJyZW50WzBdID09PSAnLScgfHwgbWluZUN1cnJlbnRbMF0gPT09ICcrJykgJiYgKHRoZWlyQ3VycmVudFswXSA9PT0gJy0nIHx8IHRoZWlyQ3VycmVudFswXSA9PT0gJysnKSkge1xuICAgICAgLy8gQm90aCBtb2RpZmllZCAuLi5cbiAgICAgIG11dHVhbENoYW5nZShodW5rLCBtaW5lLCB0aGVpcik7XG4gICAgfSBlbHNlIGlmIChtaW5lQ3VycmVudFswXSA9PT0gJysnICYmIHRoZWlyQ3VycmVudFswXSA9PT0gJyAnKSB7XG4gICAgICB2YXIgX2h1bmskbGluZXM7XG5cbiAgICAgIC8vIE1pbmUgaW5zZXJ0ZWRcbiAgICAgIChfaHVuayRsaW5lcyA9IGh1bmsubGluZXMpLnB1c2guYXBwbHkoX2h1bmskbGluZXMsIF90b0NvbnN1bWFibGVBcnJheShjb2xsZWN0Q2hhbmdlKG1pbmUpKSk7XG4gICAgfSBlbHNlIGlmICh0aGVpckN1cnJlbnRbMF0gPT09ICcrJyAmJiBtaW5lQ3VycmVudFswXSA9PT0gJyAnKSB7XG4gICAgICB2YXIgX2h1bmskbGluZXMyO1xuXG4gICAgICAvLyBUaGVpcnMgaW5zZXJ0ZWRcbiAgICAgIChfaHVuayRsaW5lczIgPSBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KF9odW5rJGxpbmVzMiwgX3RvQ29uc3VtYWJsZUFycmF5KGNvbGxlY3RDaGFuZ2UodGhlaXIpKSk7XG4gICAgfSBlbHNlIGlmIChtaW5lQ3VycmVudFswXSA9PT0gJy0nICYmIHRoZWlyQ3VycmVudFswXSA9PT0gJyAnKSB7XG4gICAgICAvLyBNaW5lIHJlbW92ZWQgb3IgZWRpdGVkXG4gICAgICByZW1vdmFsKGh1bmssIG1pbmUsIHRoZWlyKTtcbiAgICB9IGVsc2UgaWYgKHRoZWlyQ3VycmVudFswXSA9PT0gJy0nICYmIG1pbmVDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgIC8vIFRoZWlyIHJlbW92ZWQgb3IgZWRpdGVkXG4gICAgICByZW1vdmFsKGh1bmssIHRoZWlyLCBtaW5lLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50ID09PSB0aGVpckN1cnJlbnQpIHtcbiAgICAgIC8vIENvbnRleHQgaWRlbnRpdHlcbiAgICAgIGh1bmsubGluZXMucHVzaChtaW5lQ3VycmVudCk7XG4gICAgICBtaW5lLmluZGV4Kys7XG4gICAgICB0aGVpci5pbmRleCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb250ZXh0IG1pc21hdGNoXG4gICAgICBjb25mbGljdChodW5rLCBjb2xsZWN0Q2hhbmdlKG1pbmUpLCBjb2xsZWN0Q2hhbmdlKHRoZWlyKSk7XG4gICAgfVxuICB9IC8vIE5vdyBwdXNoIGFueXRoaW5nIHRoYXQgbWF5IGJlIHJlbWFpbmluZ1xuXG5cbiAgaW5zZXJ0VHJhaWxpbmcoaHVuaywgbWluZSk7XG4gIGluc2VydFRyYWlsaW5nKGh1bmssIHRoZWlyKTtcbiAgY2FsY0xpbmVDb3VudChodW5rKTtcbn1cblxuZnVuY3Rpb24gbXV0dWFsQ2hhbmdlKGh1bmssIG1pbmUsIHRoZWlyKSB7XG4gIHZhciBteUNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKG1pbmUpLFxuICAgICAgdGhlaXJDaGFuZ2VzID0gY29sbGVjdENoYW5nZSh0aGVpcik7XG5cbiAgaWYgKGFsbFJlbW92ZXMobXlDaGFuZ2VzKSAmJiBhbGxSZW1vdmVzKHRoZWlyQ2hhbmdlcykpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHJlbW92ZSBjaGFuZ2VzIHRoYXQgYXJlIHN1cGVyc2V0cyBvZiBvbmUgYW5vdGhlclxuICAgIGlmIChhcnJheVN0YXJ0c1dpdGgobXlDaGFuZ2VzLCB0aGVpckNoYW5nZXMpICYmIHNraXBSZW1vdmVTdXBlcnNldCh0aGVpciwgbXlDaGFuZ2VzLCBteUNoYW5nZXMubGVuZ3RoIC0gdGhlaXJDaGFuZ2VzLmxlbmd0aCkpIHtcbiAgICAgIHZhciBfaHVuayRsaW5lczM7XG5cbiAgICAgIChfaHVuayRsaW5lczMgPSBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KF9odW5rJGxpbmVzMywgX3RvQ29uc3VtYWJsZUFycmF5KG15Q2hhbmdlcykpO1xuXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChhcnJheVN0YXJ0c1dpdGgodGhlaXJDaGFuZ2VzLCBteUNoYW5nZXMpICYmIHNraXBSZW1vdmVTdXBlcnNldChtaW5lLCB0aGVpckNoYW5nZXMsIHRoZWlyQ2hhbmdlcy5sZW5ndGggLSBteUNoYW5nZXMubGVuZ3RoKSkge1xuICAgICAgdmFyIF9odW5rJGxpbmVzNDtcblxuICAgICAgKF9odW5rJGxpbmVzNCA9IGh1bmsubGluZXMpLnB1c2guYXBwbHkoX2h1bmskbGluZXM0LCBfdG9Db25zdW1hYmxlQXJyYXkodGhlaXJDaGFuZ2VzKSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJyYXlFcXVhbChteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcykpIHtcbiAgICB2YXIgX2h1bmskbGluZXM1O1xuXG4gICAgKF9odW5rJGxpbmVzNSA9IGh1bmsubGluZXMpLnB1c2guYXBwbHkoX2h1bmskbGluZXM1LCBfdG9Db25zdW1hYmxlQXJyYXkobXlDaGFuZ2VzKSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25mbGljdChodW5rLCBteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92YWwoaHVuaywgbWluZSwgdGhlaXIsIHN3YXApIHtcbiAgdmFyIG15Q2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UobWluZSksXG4gICAgICB0aGVpckNoYW5nZXMgPSBjb2xsZWN0Q29udGV4dCh0aGVpciwgbXlDaGFuZ2VzKTtcblxuICBpZiAodGhlaXJDaGFuZ2VzLm1lcmdlZCkge1xuICAgIHZhciBfaHVuayRsaW5lczY7XG5cbiAgICAoX2h1bmskbGluZXM2ID0gaHVuay5saW5lcykucHVzaC5hcHBseShfaHVuayRsaW5lczYsIF90b0NvbnN1bWFibGVBcnJheSh0aGVpckNoYW5nZXMubWVyZ2VkKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmxpY3QoaHVuaywgc3dhcCA/IHRoZWlyQ2hhbmdlcyA6IG15Q2hhbmdlcywgc3dhcCA/IG15Q2hhbmdlcyA6IHRoZWlyQ2hhbmdlcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uZmxpY3QoaHVuaywgbWluZSwgdGhlaXIpIHtcbiAgaHVuay5jb25mbGljdCA9IHRydWU7XG4gIGh1bmsubGluZXMucHVzaCh7XG4gICAgY29uZmxpY3Q6IHRydWUsXG4gICAgbWluZTogbWluZSxcbiAgICB0aGVpcnM6IHRoZWlyXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRMZWFkaW5nKGh1bmssIGluc2VydCwgdGhlaXIpIHtcbiAgd2hpbGUgKGluc2VydC5vZmZzZXQgPCB0aGVpci5vZmZzZXQgJiYgaW5zZXJ0LmluZGV4IDwgaW5zZXJ0LmxpbmVzLmxlbmd0aCkge1xuICAgIHZhciBsaW5lID0gaW5zZXJ0LmxpbmVzW2luc2VydC5pbmRleCsrXTtcbiAgICBodW5rLmxpbmVzLnB1c2gobGluZSk7XG4gICAgaW5zZXJ0Lm9mZnNldCsrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydFRyYWlsaW5nKGh1bmssIGluc2VydCkge1xuICB3aGlsZSAoaW5zZXJ0LmluZGV4IDwgaW5zZXJ0LmxpbmVzLmxlbmd0aCkge1xuICAgIHZhciBsaW5lID0gaW5zZXJ0LmxpbmVzW2luc2VydC5pbmRleCsrXTtcbiAgICBodW5rLmxpbmVzLnB1c2gobGluZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29sbGVjdENoYW5nZShzdGF0ZSkge1xuICB2YXIgcmV0ID0gW10sXG4gICAgICBvcGVyYXRpb24gPSBzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleF1bMF07XG5cbiAgd2hpbGUgKHN0YXRlLmluZGV4IDwgc3RhdGUubGluZXMubGVuZ3RoKSB7XG4gICAgdmFyIGxpbmUgPSBzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleF07IC8vIEdyb3VwIGFkZGl0aW9ucyB0aGF0IGFyZSBpbW1lZGlhdGVseSBhZnRlciBzdWJ0cmFjdGlvbnMgYW5kIHRyZWF0IHRoZW0gYXMgb25lIFwiYXRvbWljXCIgbW9kaWZ5IGNoYW5nZS5cblxuICAgIGlmIChvcGVyYXRpb24gPT09ICctJyAmJiBsaW5lWzBdID09PSAnKycpIHtcbiAgICAgIG9wZXJhdGlvbiA9ICcrJztcbiAgICB9XG5cbiAgICBpZiAob3BlcmF0aW9uID09PSBsaW5lWzBdKSB7XG4gICAgICByZXQucHVzaChsaW5lKTtcbiAgICAgIHN0YXRlLmluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3RDb250ZXh0KHN0YXRlLCBtYXRjaENoYW5nZXMpIHtcbiAgdmFyIGNoYW5nZXMgPSBbXSxcbiAgICAgIG1lcmdlZCA9IFtdLFxuICAgICAgbWF0Y2hJbmRleCA9IDAsXG4gICAgICBjb250ZXh0Q2hhbmdlcyA9IGZhbHNlLFxuICAgICAgY29uZmxpY3RlZCA9IGZhbHNlO1xuXG4gIHdoaWxlIChtYXRjaEluZGV4IDwgbWF0Y2hDaGFuZ2VzLmxlbmd0aCAmJiBzdGF0ZS5pbmRleCA8IHN0YXRlLmxpbmVzLmxlbmd0aCkge1xuICAgIHZhciBjaGFuZ2UgPSBzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleF0sXG4gICAgICAgIG1hdGNoID0gbWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXhdOyAvLyBPbmNlIHdlJ3ZlIGhpdCBvdXIgYWRkLCB0aGVuIHdlIGFyZSBkb25lXG5cbiAgICBpZiAobWF0Y2hbMF0gPT09ICcrJykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29udGV4dENoYW5nZXMgPSBjb250ZXh0Q2hhbmdlcyB8fCBjaGFuZ2VbMF0gIT09ICcgJztcbiAgICBtZXJnZWQucHVzaChtYXRjaCk7XG4gICAgbWF0Y2hJbmRleCsrOyAvLyBDb25zdW1lIGFueSBhZGRpdGlvbnMgaW4gdGhlIG90aGVyIGJsb2NrIGFzIGEgY29uZmxpY3QgdG8gYXR0ZW1wdFxuICAgIC8vIHRvIHB1bGwgaW4gdGhlIHJlbWFpbmluZyBjb250ZXh0IGFmdGVyIHRoaXNcblxuICAgIGlmIChjaGFuZ2VbMF0gPT09ICcrJykge1xuICAgICAgY29uZmxpY3RlZCA9IHRydWU7XG5cbiAgICAgIHdoaWxlIChjaGFuZ2VbMF0gPT09ICcrJykge1xuICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgY2hhbmdlID0gc3RhdGUubGluZXNbKytzdGF0ZS5pbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLnN1YnN0cigxKSA9PT0gY2hhbmdlLnN1YnN0cigxKSkge1xuICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICBzdGF0ZS5pbmRleCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25mbGljdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoKG1hdGNoQ2hhbmdlc1ttYXRjaEluZGV4XSB8fCAnJylbMF0gPT09ICcrJyAmJiBjb250ZXh0Q2hhbmdlcykge1xuICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGNvbmZsaWN0ZWQpIHtcbiAgICByZXR1cm4gY2hhbmdlcztcbiAgfVxuXG4gIHdoaWxlIChtYXRjaEluZGV4IDwgbWF0Y2hDaGFuZ2VzLmxlbmd0aCkge1xuICAgIG1lcmdlZC5wdXNoKG1hdGNoQ2hhbmdlc1ttYXRjaEluZGV4KytdKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWVyZ2VkOiBtZXJnZWQsXG4gICAgY2hhbmdlczogY2hhbmdlc1xuICB9O1xufVxuXG5mdW5jdGlvbiBhbGxSZW1vdmVzKGNoYW5nZXMpIHtcbiAgcmV0dXJuIGNoYW5nZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjaGFuZ2UpIHtcbiAgICByZXR1cm4gcHJldiAmJiBjaGFuZ2VbMF0gPT09ICctJztcbiAgfSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHNraXBSZW1vdmVTdXBlcnNldChzdGF0ZSwgcmVtb3ZlQ2hhbmdlcywgZGVsdGEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YTsgaSsrKSB7XG4gICAgdmFyIGNoYW5nZUNvbnRlbnQgPSByZW1vdmVDaGFuZ2VzW3JlbW92ZUNoYW5nZXMubGVuZ3RoIC0gZGVsdGEgKyBpXS5zdWJzdHIoMSk7XG5cbiAgICBpZiAoc3RhdGUubGluZXNbc3RhdGUuaW5kZXggKyBpXSAhPT0gJyAnICsgY2hhbmdlQ29udGVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmluZGV4ICs9IGRlbHRhO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lcykge1xuICB2YXIgb2xkTGluZXMgPSAwO1xuICB2YXIgbmV3TGluZXMgPSAwO1xuICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgaWYgKHR5cGVvZiBsaW5lICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFyIG15Q291bnQgPSBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmUubWluZSk7XG4gICAgICB2YXIgdGhlaXJDb3VudCA9IGNhbGNPbGROZXdMaW5lQ291bnQobGluZS50aGVpcnMpO1xuXG4gICAgICBpZiAob2xkTGluZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobXlDb3VudC5vbGRMaW5lcyA9PT0gdGhlaXJDb3VudC5vbGRMaW5lcykge1xuICAgICAgICAgIG9sZExpbmVzICs9IG15Q291bnQub2xkTGluZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkTGluZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG15Q291bnQubmV3TGluZXMgPT09IHRoZWlyQ291bnQubmV3TGluZXMpIHtcbiAgICAgICAgICBuZXdMaW5lcyArPSBteUNvdW50Lm5ld0xpbmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0xpbmVzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkICYmIChsaW5lWzBdID09PSAnKycgfHwgbGluZVswXSA9PT0gJyAnKSkge1xuICAgICAgICBuZXdMaW5lcysrO1xuICAgICAgfVxuXG4gICAgICBpZiAob2xkTGluZXMgIT09IHVuZGVmaW5lZCAmJiAobGluZVswXSA9PT0gJy0nIHx8IGxpbmVbMF0gPT09ICcgJykpIHtcbiAgICAgICAgb2xkTGluZXMrKztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG9sZExpbmVzOiBvbGRMaW5lcyxcbiAgICBuZXdMaW5lczogbmV3TGluZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVBhdGNoKHN0cnVjdHVyZWRQYXRjaCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHJ1Y3R1cmVkUGF0Y2gpKSB7XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRQYXRjaC5tYXAocmV2ZXJzZVBhdGNoKS5yZXZlcnNlKCk7XG4gIH1cblxuICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHN0cnVjdHVyZWRQYXRjaCksIHt9LCB7XG4gICAgb2xkRmlsZU5hbWU6IHN0cnVjdHVyZWRQYXRjaC5uZXdGaWxlTmFtZSxcbiAgICBvbGRIZWFkZXI6IHN0cnVjdHVyZWRQYXRjaC5uZXdIZWFkZXIsXG4gICAgbmV3RmlsZU5hbWU6IHN0cnVjdHVyZWRQYXRjaC5vbGRGaWxlTmFtZSxcbiAgICBuZXdIZWFkZXI6IHN0cnVjdHVyZWRQYXRjaC5vbGRIZWFkZXIsXG4gICAgaHVua3M6IHN0cnVjdHVyZWRQYXRjaC5odW5rcy5tYXAoZnVuY3Rpb24gKGh1bmspIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9sZExpbmVzOiBodW5rLm5ld0xpbmVzLFxuICAgICAgICBvbGRTdGFydDogaHVuay5uZXdTdGFydCxcbiAgICAgICAgbmV3TGluZXM6IGh1bmsub2xkTGluZXMsXG4gICAgICAgIG5ld1N0YXJ0OiBodW5rLm9sZFN0YXJ0LFxuICAgICAgICBsaW5lZGVsaW1pdGVyczogaHVuay5saW5lZGVsaW1pdGVycyxcbiAgICAgICAgbGluZXM6IGh1bmsubGluZXMubWFwKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgaWYgKGwuc3RhcnRzV2l0aCgnLScpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIrXCIuY29uY2F0KGwuc2xpY2UoMSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsLnN0YXJ0c1dpdGgoJysnKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiLVwiLmNvbmNhdChsLnNsaWNlKDEpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSlcbiAgfSk7XG59XG5cbi8vIFNlZTogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL3dpa2kvQVBJXG5mdW5jdGlvbiBjb252ZXJ0Q2hhbmdlc1RvRE1QKGNoYW5nZXMpIHtcbiAgdmFyIHJldCA9IFtdLFxuICAgICAgY2hhbmdlLFxuICAgICAgb3BlcmF0aW9uO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIGNoYW5nZSA9IGNoYW5nZXNbaV07XG5cbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICBvcGVyYXRpb24gPSAxO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIG9wZXJhdGlvbiA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcGVyYXRpb24gPSAwO1xuICAgIH1cblxuICAgIHJldC5wdXNoKFtvcGVyYXRpb24sIGNoYW5nZS52YWx1ZV0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gY29udmVydENoYW5nZXNUb1hNTChjaGFuZ2VzKSB7XG4gIHZhciByZXQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tpXTtcblxuICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8aW5zPicpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8ZGVsPicpO1xuICAgIH1cblxuICAgIHJldC5wdXNoKGVzY2FwZUhUTUwoY2hhbmdlLnZhbHVlKSk7XG5cbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICByZXQucHVzaCgnPC9pbnM+Jyk7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xuICAgICAgcmV0LnB1c2goJzwvZGVsPicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUhUTUwocykge1xuICB2YXIgbiA9IHM7XG4gIG4gPSBuLnJlcGxhY2UoLyYvZywgJyZhbXA7Jyk7XG4gIG4gPSBuLnJlcGxhY2UoLzwvZywgJyZsdDsnKTtcbiAgbiA9IG4ucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICBuID0gbi5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gIHJldHVybiBuO1xufVxuXG5leHBvcnQgeyBEaWZmLCBhcHBseVBhdGNoLCBhcHBseVBhdGNoZXMsIGNhbm9uaWNhbGl6ZSwgY29udmVydENoYW5nZXNUb0RNUCwgY29udmVydENoYW5nZXNUb1hNTCwgY3JlYXRlUGF0Y2gsIGNyZWF0ZVR3b0ZpbGVzUGF0Y2gsIGRpZmZBcnJheXMsIGRpZmZDaGFycywgZGlmZkNzcywgZGlmZkpzb24sIGRpZmZMaW5lcywgZGlmZlNlbnRlbmNlcywgZGlmZlRyaW1tZWRMaW5lcywgZGlmZldvcmRzLCBkaWZmV29yZHNXaXRoU3BhY2UsIGZvcm1hdFBhdGNoLCBtZXJnZSwgcGFyc2VQYXRjaCwgcmV2ZXJzZVBhdGNoLCBzdHJ1Y3R1cmVkUGF0Y2ggfTtcbiJdLCJuYW1lcyI6WyJEaWZmIiwicHJvdG90eXBlIiwiZGlmZiIsIm9sZFN0cmluZyIsIm5ld1N0cmluZyIsIl9vcHRpb25zJHRpbWVvdXQiLCJvcHRpb25zIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiY2FsbGJhY2siLCJzZWxmIiwiZG9uZSIsInZhbHVlIiwic2V0VGltZW91dCIsImNhc3RJbnB1dCIsInJlbW92ZUVtcHR5IiwidG9rZW5pemUiLCJuZXdMZW4iLCJvbGRMZW4iLCJlZGl0TGVuZ3RoIiwibWF4RWRpdExlbmd0aCIsIk1hdGgiLCJtaW4iLCJtYXhFeGVjdXRpb25UaW1lIiwidGltZW91dCIsIkluZmluaXR5IiwiYWJvcnRBZnRlclRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJiZXN0UGF0aCIsIm9sZFBvcyIsImxhc3RDb21wb25lbnQiLCJuZXdQb3MiLCJleHRyYWN0Q29tbW9uIiwiam9pbiIsImNvdW50IiwibWluRGlhZ29uYWxUb0NvbnNpZGVyIiwibWF4RGlhZ29uYWxUb0NvbnNpZGVyIiwiZXhlY0VkaXRMZW5ndGgiLCJkaWFnb25hbFBhdGgiLCJtYXgiLCJiYXNlUGF0aCIsInJlbW92ZVBhdGgiLCJhZGRQYXRoIiwiY2FuQWRkIiwiYWRkUGF0aE5ld1BvcyIsImNhblJlbW92ZSIsImFkZFRvUGF0aCIsImJ1aWxkVmFsdWVzIiwidXNlTG9uZ2VzdFRva2VuIiwiZXhlYyIsInJldCIsInBhdGgiLCJhZGRlZCIsInJlbW92ZWQiLCJvbGRQb3NJbmMiLCJsYXN0IiwicHJldmlvdXNDb21wb25lbnQiLCJjb21tb25Db3VudCIsImVxdWFscyIsImxlZnQiLCJyaWdodCIsImNvbXBhcmF0b3IiLCJpZ25vcmVDYXNlIiwidG9Mb3dlckNhc2UiLCJhcnJheSIsImkiLCJwdXNoIiwic3BsaXQiLCJjaGFycyIsImNvbXBvbmVudHMiLCJuZXh0Q29tcG9uZW50IiwicmV2ZXJzZSIsImNvbXBvbmVudFBvcyIsImNvbXBvbmVudExlbiIsImNvbXBvbmVudCIsInNsaWNlIiwibWFwIiwib2xkVmFsdWUiLCJ0bXAiLCJmaW5hbENvbXBvbmVudCIsInBvcCIsImNoYXJhY3RlckRpZmYiLCJkaWZmQ2hhcnMiLCJvbGRTdHIiLCJuZXdTdHIiLCJnZW5lcmF0ZU9wdGlvbnMiLCJkZWZhdWx0cyIsIm5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsImV4dGVuZGVkV29yZENoYXJzIiwicmVXaGl0ZXNwYWNlIiwid29yZERpZmYiLCJpZ25vcmVXaGl0ZXNwYWNlIiwidGVzdCIsInRva2VucyIsInNwbGljZSIsImRpZmZXb3JkcyIsImRpZmZXb3Jkc1dpdGhTcGFjZSIsImxpbmVEaWZmIiwic3RyaXBUcmFpbGluZ0NyIiwicmVwbGFjZSIsInJldExpbmVzIiwibGluZXNBbmROZXdsaW5lcyIsImxpbmUiLCJuZXdsaW5lSXNUb2tlbiIsInRyaW0iLCJkaWZmTGluZXMiLCJkaWZmVHJpbW1lZExpbmVzIiwic2VudGVuY2VEaWZmIiwiZGlmZlNlbnRlbmNlcyIsImNzc0RpZmYiLCJkaWZmQ3NzIiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJfZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkMiIsInRhcmdldCIsInNvdXJjZSIsImZvckVhY2giLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl90b0NvbnN1bWFibGVBcnJheSIsImFyciIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJBcnJheSIsImlzQXJyYXkiLCJfYXJyYXlMaWtlVG9BcnJheSIsIml0ZXIiLCJmcm9tIiwibyIsIm1pbkxlbiIsIm4iLCJ0b1N0cmluZyIsImNhbGwiLCJsZW4iLCJhcnIyIiwiVHlwZUVycm9yIiwib2JqZWN0UHJvdG90eXBlVG9TdHJpbmciLCJqc29uRGlmZiIsIl90aGlzJG9wdGlvbnMiLCJ1bmRlZmluZWRSZXBsYWNlbWVudCIsIl90aGlzJG9wdGlvbnMkc3RyaW5naSIsInN0cmluZ2lmeVJlcGxhY2VyIiwiayIsInYiLCJKU09OIiwic3RyaW5naWZ5IiwiY2Fub25pY2FsaXplIiwiZGlmZkpzb24iLCJvbGRPYmoiLCJuZXdPYmoiLCJzdGFjayIsInJlcGxhY2VtZW50U3RhY2siLCJyZXBsYWNlciIsImNhbm9uaWNhbGl6ZWRPYmoiLCJ0b0pTT04iLCJzb3J0ZWRLZXlzIiwiX2tleSIsInNvcnQiLCJhcnJheURpZmYiLCJkaWZmQXJyYXlzIiwib2xkQXJyIiwibmV3QXJyIiwicGFyc2VQYXRjaCIsInVuaURpZmYiLCJkaWZmc3RyIiwiZGVsaW1pdGVycyIsIm1hdGNoIiwibGlzdCIsInBhcnNlSW5kZXgiLCJpbmRleCIsImhlYWRlciIsInBhcnNlRmlsZUhlYWRlciIsImh1bmtzIiwiX2xpbmUiLCJwYXJzZUh1bmsiLCJzdHJpY3QiLCJFcnJvciIsImZpbGVIZWFkZXIiLCJrZXlQcmVmaXgiLCJkYXRhIiwiZmlsZU5hbWUiLCJzdWJzdHIiLCJjaHVua0hlYWRlckluZGV4IiwiY2h1bmtIZWFkZXJMaW5lIiwiY2h1bmtIZWFkZXIiLCJodW5rIiwib2xkU3RhcnQiLCJvbGRMaW5lcyIsIm5ld1N0YXJ0IiwibmV3TGluZXMiLCJsaW5lcyIsImxpbmVkZWxpbWl0ZXJzIiwiYWRkQ291bnQiLCJyZW1vdmVDb3VudCIsImluZGV4T2YiLCJvcGVyYXRpb24iLCJkaXN0YW5jZUl0ZXJhdG9yIiwic3RhcnQiLCJtaW5MaW5lIiwibWF4TGluZSIsIndhbnRGb3J3YXJkIiwiYmFja3dhcmRFeGhhdXN0ZWQiLCJmb3J3YXJkRXhoYXVzdGVkIiwibG9jYWxPZmZzZXQiLCJhcHBseVBhdGNoIiwiY29tcGFyZUxpbmUiLCJsaW5lTnVtYmVyIiwicGF0Y2hDb250ZW50IiwiZXJyb3JDb3VudCIsImZ1enpGYWN0b3IiLCJvZmZzZXQiLCJyZW1vdmVFT0ZOTCIsImFkZEVPRk5MIiwiaHVua0ZpdHMiLCJ0b1BvcyIsImoiLCJjb250ZW50IiwiZGlmZk9mZnNldCIsIl9pIiwiX2h1bmsiLCJfdG9Qb3MiLCJkZWxpbWl0ZXIiLCJwcmV2aW91c09wZXJhdGlvbiIsIl9rIiwiYXBwbHlQYXRjaGVzIiwiY3VycmVudEluZGV4IiwicHJvY2Vzc0luZGV4IiwiY29tcGxldGUiLCJsb2FkRmlsZSIsImVyciIsInVwZGF0ZWRDb250ZW50IiwicGF0Y2hlZCIsInN0cnVjdHVyZWRQYXRjaCIsIm9sZEZpbGVOYW1lIiwibmV3RmlsZU5hbWUiLCJvbGRIZWFkZXIiLCJuZXdIZWFkZXIiLCJjb250ZXh0IiwiY29udGV4dExpbmVzIiwiZW50cnkiLCJvbGRSYW5nZVN0YXJ0IiwibmV3UmFuZ2VTdGFydCIsImN1clJhbmdlIiwib2xkTGluZSIsIm5ld0xpbmUiLCJfbG9vcCIsImN1cnJlbnQiLCJfY3VyUmFuZ2UiLCJwcmV2IiwiX2N1clJhbmdlMiIsIl9jdXJSYW5nZTMiLCJjb250ZXh0U2l6ZSIsIm9sZEVPRk5ld2xpbmUiLCJuZXdFT0ZOZXdsaW5lIiwibm9ObEJlZm9yZUFkZHMiLCJmb3JtYXRQYXRjaCIsImNyZWF0ZVR3b0ZpbGVzUGF0Y2giLCJjcmVhdGVQYXRjaCIsImFycmF5RXF1YWwiLCJhIiwiYiIsImFycmF5U3RhcnRzV2l0aCIsImNhbGNMaW5lQ291bnQiLCJfY2FsY09sZE5ld0xpbmVDb3VudCIsImNhbGNPbGROZXdMaW5lQ291bnQiLCJtZXJnZSIsIm1pbmUiLCJ0aGVpcnMiLCJiYXNlIiwibG9hZFBhdGNoIiwiZmlsZU5hbWVDaGFuZ2VkIiwic2VsZWN0RmllbGQiLCJtaW5lSW5kZXgiLCJ0aGVpcnNJbmRleCIsIm1pbmVPZmZzZXQiLCJ0aGVpcnNPZmZzZXQiLCJtaW5lQ3VycmVudCIsInRoZWlyc0N1cnJlbnQiLCJodW5rQmVmb3JlIiwiY2xvbmVIdW5rIiwibWVyZ2VkSHVuayIsIm1lcmdlTGluZXMiLCJwYXJhbSIsInBhdGNoIiwiY29uZmxpY3QiLCJjaGVjayIsIm1pbmVMaW5lcyIsInRoZWlyT2Zmc2V0IiwidGhlaXJMaW5lcyIsInRoZWlyIiwiaW5zZXJ0TGVhZGluZyIsInRoZWlyQ3VycmVudCIsIm11dHVhbENoYW5nZSIsIl9odW5rJGxpbmVzIiwiY29sbGVjdENoYW5nZSIsIl9odW5rJGxpbmVzMiIsInJlbW92YWwiLCJpbnNlcnRUcmFpbGluZyIsIm15Q2hhbmdlcyIsInRoZWlyQ2hhbmdlcyIsImFsbFJlbW92ZXMiLCJza2lwUmVtb3ZlU3VwZXJzZXQiLCJfaHVuayRsaW5lczMiLCJfaHVuayRsaW5lczQiLCJfaHVuayRsaW5lczUiLCJzd2FwIiwiY29sbGVjdENvbnRleHQiLCJtZXJnZWQiLCJfaHVuayRsaW5lczYiLCJpbnNlcnQiLCJzdGF0ZSIsIm1hdGNoQ2hhbmdlcyIsImNoYW5nZXMiLCJtYXRjaEluZGV4IiwiY29udGV4dENoYW5nZXMiLCJjb25mbGljdGVkIiwiY2hhbmdlIiwicmVkdWNlIiwicmVtb3ZlQ2hhbmdlcyIsImRlbHRhIiwiY2hhbmdlQ29udGVudCIsIm15Q291bnQiLCJ0aGVpckNvdW50IiwicmV2ZXJzZVBhdGNoIiwibCIsInN0YXJ0c1dpdGgiLCJjb25jYXQiLCJjb252ZXJ0Q2hhbmdlc1RvRE1QIiwiY29udmVydENoYW5nZXNUb1hNTCIsImVzY2FwZUhUTUwiLCJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/diff/lib/index.mjs\n");

/***/ })

};
;